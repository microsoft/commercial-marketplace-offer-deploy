//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package api

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// DeploymentManagementClient contains the methods for the DeploymentManagementClient group.
// Don't use this type directly, use a constructor function instead.
type DeploymentManagementClient struct {
	internal *azcore.Client
	endpoint string
}

// CreateDeployment - Creates a new deployment instances
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - body - Deployment object that needs to be added to the store
//   - options - DeploymentManagementClientCreateDeploymentOptions contains the optional parameters for the DeploymentManagementClient.CreateDeployment
//     method.
func (client *DeploymentManagementClient) CreateDeployment(ctx context.Context, body CreateDeployment, options *DeploymentManagementClientCreateDeploymentOptions) (DeploymentManagementClientCreateDeploymentResponse, error) {
	req, err := client.createDeploymentCreateRequest(ctx, body, options)
	if err != nil {
		return DeploymentManagementClientCreateDeploymentResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientCreateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMethodNotAllowed) {
		return DeploymentManagementClientCreateDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.createDeploymentHandleResponse(resp)
}

// createDeploymentCreateRequest creates the CreateDeployment request.
func (client *DeploymentManagementClient) createDeploymentCreateRequest(ctx context.Context, body CreateDeployment, options *DeploymentManagementClientCreateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/deployments"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// createDeploymentHandleResponse handles the CreateDeployment response.
func (client *DeploymentManagementClient) createDeploymentHandleResponse(resp *http.Response) (DeploymentManagementClientCreateDeploymentResponse, error) {
	result := DeploymentManagementClientCreateDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return DeploymentManagementClientCreateDeploymentResponse{}, err
	}
	return result, nil
}

// CreateEvenHook - Create an event hook
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - body - Create event hook
//   - options - DeploymentManagementClientCreateEvenHookOptions contains the optional parameters for the DeploymentManagementClient.CreateEvenHook
//     method.
func (client *DeploymentManagementClient) CreateEvenHook(ctx context.Context, body CreateEventHookRequest, options *DeploymentManagementClientCreateEvenHookOptions) (DeploymentManagementClientCreateEvenHookResponse, error) {
	req, err := client.createEvenHookCreateRequest(ctx, body, options)
	if err != nil {
		return DeploymentManagementClientCreateEvenHookResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientCreateEvenHookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMethodNotAllowed) {
		return DeploymentManagementClientCreateEvenHookResponse{}, runtime.NewResponseError(resp)
	}
	return client.createEvenHookHandleResponse(resp)
}

// createEvenHookCreateRequest creates the CreateEvenHook request.
func (client *DeploymentManagementClient) createEvenHookCreateRequest(ctx context.Context, body CreateEventHookRequest, options *DeploymentManagementClientCreateEvenHookOptions) (*policy.Request, error) {
	urlPath := "/events/hooks"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// createEvenHookHandleResponse handles the CreateEvenHook response.
func (client *DeploymentManagementClient) createEvenHookHandleResponse(resp *http.Response) (DeploymentManagementClientCreateEvenHookResponse, error) {
	result := DeploymentManagementClientCreateEvenHookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateEventHookResponse); err != nil {
		return DeploymentManagementClientCreateEvenHookResponse{}, err
	}
	return result, nil
}

// DeleteEventHook - Deletes an event hook by id
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - hookID - ID of the hook
//   - options - DeploymentManagementClientDeleteEventHookOptions contains the optional parameters for the DeploymentManagementClient.DeleteEventHook
//     method.
func (client *DeploymentManagementClient) DeleteEventHook(ctx context.Context, hookID string, options *DeploymentManagementClientDeleteEventHookOptions) (DeploymentManagementClientDeleteEventHookResponse, error) {
	req, err := client.deleteEventHookCreateRequest(ctx, hookID, options)
	if err != nil {
		return DeploymentManagementClientDeleteEventHookResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientDeleteEventHookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound) {
		return DeploymentManagementClientDeleteEventHookResponse{}, runtime.NewResponseError(resp)
	}
	return DeploymentManagementClientDeleteEventHookResponse{}, nil
}

// deleteEventHookCreateRequest creates the DeleteEventHook request.
func (client *DeploymentManagementClient) deleteEventHookCreateRequest(ctx context.Context, hookID string, options *DeploymentManagementClientDeleteEventHookOptions) (*policy.Request, error) {
	urlPath := "/events/hooks/{hookId}"
	urlPath = strings.ReplaceAll(urlPath, "{hookId}", url.PathEscape(hookID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetDeployment - Returns a single deployment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - deploymentID - ID of deployment to return
//   - options - DeploymentManagementClientGetDeploymentOptions contains the optional parameters for the DeploymentManagementClient.GetDeployment
//     method.
func (client *DeploymentManagementClient) GetDeployment(ctx context.Context, deploymentID int32, options *DeploymentManagementClientGetDeploymentOptions) (DeploymentManagementClientGetDeploymentResponse, error) {
	req, err := client.getDeploymentCreateRequest(ctx, deploymentID, options)
	if err != nil {
		return DeploymentManagementClientGetDeploymentResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientGetDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound) {
		return DeploymentManagementClientGetDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeploymentHandleResponse(resp)
}

// getDeploymentCreateRequest creates the GetDeployment request.
func (client *DeploymentManagementClient) getDeploymentCreateRequest(ctx context.Context, deploymentID int32, options *DeploymentManagementClientGetDeploymentOptions) (*policy.Request, error) {
	urlPath := "/deployments/{deploymentId}"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentId}", url.PathEscape(strconv.FormatInt(int64(deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeploymentHandleResponse handles the GetDeployment response.
func (client *DeploymentManagementClient) getDeploymentHandleResponse(resp *http.Response) (DeploymentManagementClientGetDeploymentResponse, error) {
	result := DeploymentManagementClientGetDeploymentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return DeploymentManagementClientGetDeploymentResponse{}, err
	}
	return result, nil
}

// GetEventHook - Gets an event hook instance
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - hookID - ID of the hook
//   - options - DeploymentManagementClientGetEventHookOptions contains the optional parameters for the DeploymentManagementClient.GetEventHook
//     method.
func (client *DeploymentManagementClient) GetEventHook(ctx context.Context, hookID string, options *DeploymentManagementClientGetEventHookOptions) (DeploymentManagementClientGetEventHookResponse, error) {
	req, err := client.getEventHookCreateRequest(ctx, hookID, options)
	if err != nil {
		return DeploymentManagementClientGetEventHookResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientGetEventHookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest) {
		return DeploymentManagementClientGetEventHookResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEventHookHandleResponse(resp)
}

// getEventHookCreateRequest creates the GetEventHook request.
func (client *DeploymentManagementClient) getEventHookCreateRequest(ctx context.Context, hookID string, options *DeploymentManagementClientGetEventHookOptions) (*policy.Request, error) {
	urlPath := "/events/hooks/{hookId}"
	urlPath = strings.ReplaceAll(urlPath, "{hookId}", url.PathEscape(hookID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventHookHandleResponse handles the GetEventHook response.
func (client *DeploymentManagementClient) getEventHookHandleResponse(resp *http.Response) (DeploymentManagementClientGetEventHookResponse, error) {
	result := DeploymentManagementClientGetEventHookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventHookResponse); err != nil {
		return DeploymentManagementClientGetEventHookResponse{}, err
	}
	return result, nil
}

// GetEventTypes - Returns a list of all event types
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - options - DeploymentManagementClientGetEventTypesOptions contains the optional parameters for the DeploymentManagementClient.GetEventTypes
//     method.
func (client *DeploymentManagementClient) GetEventTypes(ctx context.Context, options *DeploymentManagementClientGetEventTypesOptions) (DeploymentManagementClientGetEventTypesResponse, error) {
	req, err := client.getEventTypesCreateRequest(ctx, options)
	if err != nil {
		return DeploymentManagementClientGetEventTypesResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientGetEventTypesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientGetEventTypesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEventTypesHandleResponse(resp)
}

// getEventTypesCreateRequest creates the GetEventTypes request.
func (client *DeploymentManagementClient) getEventTypesCreateRequest(ctx context.Context, options *DeploymentManagementClientGetEventTypesOptions) (*policy.Request, error) {
	urlPath := "/events"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventTypesHandleResponse handles the GetEventTypes response.
func (client *DeploymentManagementClient) getEventTypesHandleResponse(resp *http.Response) (DeploymentManagementClientGetEventTypesResponse, error) {
	result := DeploymentManagementClientGetEventTypesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventTypeArray); err != nil {
		return DeploymentManagementClientGetEventTypesResponse{}, err
	}
	return result, nil
}

// GetInvokedDeploymentOperation - Gets the state of a command operation that's been invoked
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - operationID - ID of the triggered operation
//   - options - DeploymentManagementClientGetInvokedDeploymentOperationOptions contains the optional parameters for the DeploymentManagementClient.GetInvokedDeploymentOperation
//     method.
func (client *DeploymentManagementClient) GetInvokedDeploymentOperation(ctx context.Context, operationID string, options *DeploymentManagementClientGetInvokedDeploymentOperationOptions) (DeploymentManagementClientGetInvokedDeploymentOperationResponse, error) {
	req, err := client.getInvokedDeploymentOperationCreateRequest(ctx, operationID, options)
	if err != nil {
		return DeploymentManagementClientGetInvokedDeploymentOperationResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientGetInvokedDeploymentOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientGetInvokedDeploymentOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInvokedDeploymentOperationHandleResponse(resp)
}

// getInvokedDeploymentOperationCreateRequest creates the GetInvokedDeploymentOperation request.
func (client *DeploymentManagementClient) getInvokedDeploymentOperationCreateRequest(ctx context.Context, operationID string, options *DeploymentManagementClientGetInvokedDeploymentOperationOptions) (*policy.Request, error) {
	urlPath := "/operations/{operationId}"
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInvokedDeploymentOperationHandleResponse handles the GetInvokedDeploymentOperation response.
func (client *DeploymentManagementClient) getInvokedDeploymentOperationHandleResponse(resp *http.Response) (DeploymentManagementClientGetInvokedDeploymentOperationResponse, error) {
	result := DeploymentManagementClientGetInvokedDeploymentOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GetInvokedOperationResponse); err != nil {
		return DeploymentManagementClientGetInvokedDeploymentOperationResponse{}, err
	}
	return result, nil
}

// InvokeDeploymentOperation - Invokes a deployment operation with parameters
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - deploymentID - ID of deployment
//   - body - Deployment operation invocation
//   - options - DeploymentManagementClientInvokeDeploymentOperationOptions contains the optional parameters for the DeploymentManagementClient.InvokeDeploymentOperation
//     method.
func (client *DeploymentManagementClient) InvokeDeploymentOperation(ctx context.Context, deploymentID int32, body InvokeDeploymentOperationRequest, options *DeploymentManagementClientInvokeDeploymentOperationOptions) (DeploymentManagementClientInvokeDeploymentOperationResponse, error) {
	req, err := client.invokeDeploymentOperationCreateRequest(ctx, deploymentID, body, options)
	if err != nil {
		return DeploymentManagementClientInvokeDeploymentOperationResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientInvokeDeploymentOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientInvokeDeploymentOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.invokeDeploymentOperationHandleResponse(resp)
}

// invokeDeploymentOperationCreateRequest creates the InvokeDeploymentOperation request.
func (client *DeploymentManagementClient) invokeDeploymentOperationCreateRequest(ctx context.Context, deploymentID int32, body InvokeDeploymentOperationRequest, options *DeploymentManagementClientInvokeDeploymentOperationOptions) (*policy.Request, error) {
	urlPath := "/deployments/{deploymentId}/operation"
	urlPath = strings.ReplaceAll(urlPath, "{deploymentId}", url.PathEscape(strconv.FormatInt(int64(deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// invokeDeploymentOperationHandleResponse handles the InvokeDeploymentOperation response.
func (client *DeploymentManagementClient) invokeDeploymentOperationHandleResponse(resp *http.Response) (DeploymentManagementClientInvokeDeploymentOperationResponse, error) {
	result := DeploymentManagementClientInvokeDeploymentOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.InvokedDeploymentOperationResponse); err != nil {
		return DeploymentManagementClientInvokeDeploymentOperationResponse{}, err
	}
	return result, nil
}

// ListDeployments - List all deployments
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - options - DeploymentManagementClientListDeploymentsOptions contains the optional parameters for the DeploymentManagementClient.ListDeployments
//     method.
func (client *DeploymentManagementClient) ListDeployments(ctx context.Context, options *DeploymentManagementClientListDeploymentsOptions) (DeploymentManagementClientListDeploymentsResponse, error) {
	req, err := client.listDeploymentsCreateRequest(ctx, options)
	if err != nil {
		return DeploymentManagementClientListDeploymentsResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientListDeploymentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientListDeploymentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listDeploymentsHandleResponse(resp)
}

// listDeploymentsCreateRequest creates the ListDeployments request.
func (client *DeploymentManagementClient) listDeploymentsCreateRequest(ctx context.Context, options *DeploymentManagementClientListDeploymentsOptions) (*policy.Request, error) {
	urlPath := "/deployments"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Status != nil {
			for _, qv := range options.Status {
		reqQP.Add("status", string(qv))
	}
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDeploymentsHandleResponse handles the ListDeployments response.
func (client *DeploymentManagementClient) listDeploymentsHandleResponse(resp *http.Response) (DeploymentManagementClientListDeploymentsResponse, error) {
	result := DeploymentManagementClientListDeploymentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentArray); err != nil {
		return DeploymentManagementClientListDeploymentsResponse{}, err
	}
	return result, nil
}

// ListEventHooks - List all event hooks
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - options - DeploymentManagementClientListEventHooksOptions contains the optional parameters for the DeploymentManagementClient.ListEventHooks
//     method.
func (client *DeploymentManagementClient) ListEventHooks(ctx context.Context, options *DeploymentManagementClientListEventHooksOptions) (DeploymentManagementClientListEventHooksResponse, error) {
	req, err := client.listEventHooksCreateRequest(ctx, options)
	if err != nil {
		return DeploymentManagementClientListEventHooksResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientListEventHooksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientListEventHooksResponse{}, runtime.NewResponseError(resp)
	}
	return client.listEventHooksHandleResponse(resp)
}

// listEventHooksCreateRequest creates the ListEventHooks request.
func (client *DeploymentManagementClient) listEventHooksCreateRequest(ctx context.Context, options *DeploymentManagementClientListEventHooksOptions) (*policy.Request, error) {
	urlPath := "/events/hooks"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listEventHooksHandleResponse handles the ListEventHooks response.
func (client *DeploymentManagementClient) listEventHooksHandleResponse(resp *http.Response) (DeploymentManagementClientListEventHooksResponse, error) {
	result := DeploymentManagementClientListEventHooksResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventHookResponseArray); err != nil {
		return DeploymentManagementClientListEventHooksResponse{}, err
	}
	return result, nil
}

// ListInvokedOperations - Returns a list of invoked operations
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - options - DeploymentManagementClientListInvokedOperationsOptions contains the optional parameters for the DeploymentManagementClient.ListInvokedOperations
//     method.
func (client *DeploymentManagementClient) ListInvokedOperations(ctx context.Context, options *DeploymentManagementClientListInvokedOperationsOptions) (DeploymentManagementClientListInvokedOperationsResponse, error) {
	req, err := client.listInvokedOperationsCreateRequest(ctx, options)
	if err != nil {
		return DeploymentManagementClientListInvokedOperationsResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientListInvokedOperationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DeploymentManagementClientListInvokedOperationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listInvokedOperationsHandleResponse(resp)
}

// listInvokedOperationsCreateRequest creates the ListInvokedOperations request.
func (client *DeploymentManagementClient) listInvokedOperationsCreateRequest(ctx context.Context, options *DeploymentManagementClientListInvokedOperationsOptions) (*policy.Request, error) {
	urlPath := "/operations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listInvokedOperationsHandleResponse handles the ListInvokedOperations response.
func (client *DeploymentManagementClient) listInvokedOperationsHandleResponse(resp *http.Response) (DeploymentManagementClientListInvokedOperationsResponse, error) {
	result := DeploymentManagementClientListInvokedOperationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListInvokedOperationResponse); err != nil {
		return DeploymentManagementClientListInvokedOperationsResponse{}, err
	}
	return result, nil
}

// UpdateDeployment - Update an existing deployment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 0.1.0
//   - body - Deployment object that needs to be added to the store
//   - options - DeploymentManagementClientUpdateDeploymentOptions contains the optional parameters for the DeploymentManagementClient.UpdateDeployment
//     method.
func (client *DeploymentManagementClient) UpdateDeployment(ctx context.Context, body Deployment, options *DeploymentManagementClientUpdateDeploymentOptions) (DeploymentManagementClientUpdateDeploymentResponse, error) {
	req, err := client.updateDeploymentCreateRequest(ctx, body, options)
	if err != nil {
		return DeploymentManagementClientUpdateDeploymentResponse{}, err
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return DeploymentManagementClientUpdateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest, http.StatusNotFound, http.StatusMethodNotAllowed) {
		return DeploymentManagementClientUpdateDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return DeploymentManagementClientUpdateDeploymentResponse{}, nil
}

// updateDeploymentCreateRequest creates the UpdateDeployment request.
func (client *DeploymentManagementClient) updateDeploymentCreateRequest(ctx context.Context, body Deployment, options *DeploymentManagementClientUpdateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/deployments"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

