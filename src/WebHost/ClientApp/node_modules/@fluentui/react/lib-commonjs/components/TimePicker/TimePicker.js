"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimePicker = void 0;
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../Utilities");
var date_time_utilities_1 = require("@fluentui/date-time-utilities");
var ComboBox_1 = require("../../ComboBox");
var Utilities_2 = require("../../Utilities");
var react_hooks_1 = require("@fluentui/react-hooks");
var REGEX_SHOW_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):([0-5][0-9]):([0-5][0-9])\s([AaPp][Mm]))$/;
var REGEX_HIDE_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):[0-5][0-9]\s([AaPp][Mm]))$/;
var REGEX_SHOW_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;
var REGEX_HIDE_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
var TIME_LOWER_BOUND = 0;
var TIME_UPPER_BOUND = 23;
var getDefaultStrings = function (useHour12, showSeconds) {
    var hourUnits = useHour12 ? '12-hour' : '24-hour';
    var timeFormat = "hh:mm".concat(showSeconds ? ':ss' : '').concat(useHour12 ? ' AP' : '');
    var invalidInputErrorMessage = "Enter a valid time in the ".concat(hourUnits, " format: ").concat(timeFormat);
    var timeOutOfBoundsErrorMessage = "Please enter a time within the range of {0} and {1}";
    return {
        invalidInputErrorMessage: invalidInputErrorMessage,
        timeOutOfBoundsErrorMessage: timeOutOfBoundsErrorMessage,
    };
};
/**
 * {@docCategory TimePicker}
 */
var TimePicker = function (_a) {
    var label = _a.label, _b = _a.increments, increments = _b === void 0 ? 30 : _b, _c = _a.showSeconds, showSeconds = _c === void 0 ? false : _c, _d = _a.allowFreeform, allowFreeform = _d === void 0 ? true : _d, _e = _a.useHour12, useHour12 = _e === void 0 ? false : _e, timeRange = _a.timeRange, _f = _a.strings, strings = _f === void 0 ? getDefaultStrings(useHour12, showSeconds) : _f, defaultValue = _a.defaultValue, value = _a.value, dateAnchor = _a.dateAnchor, onChange = _a.onChange, onFormatDate = _a.onFormatDate, onValidateUserInput = _a.onValidateUserInput, onValidationResult = _a.onValidationResult, rest = tslib_1.__rest(_a, ["label", "increments", "showSeconds", "allowFreeform", "useHour12", "timeRange", "strings", "defaultValue", "value", "dateAnchor", "onChange", "onFormatDate", "onValidateUserInput", "onValidationResult"]);
    var _g = React.useState(''), comboBoxText = _g[0], setComboBoxText = _g[1];
    var _h = React.useState(), selectedKey = _h[0], setSelectedKey = _h[1];
    var _j = React.useState(''), errorMessage = _j[0], setErrorMessage = _j[1];
    var fallbackDateAnchor = (0, react_hooks_1.useConst)(new Date());
    var _k = (0, react_hooks_1.useControllableValue)(value, defaultValue), selectedTime = _k[0], setSelectedTime = _k[1];
    var optionsCount = getDropdownOptionsCount(increments, timeRange);
    var internalDateAnchor = dateAnchor || value || defaultValue || fallbackDateAnchor;
    var dateStartAnchor = React.useMemo(function () { return getDateAnchor(internalDateAnchor, 'start', increments, timeRange); }, [internalDateAnchor, increments, timeRange]);
    var dateEndAnchor = React.useMemo(function () { return getDateAnchor(internalDateAnchor, 'end', increments, timeRange); }, [internalDateAnchor, increments, timeRange]);
    var timePickerOptions = React.useMemo(function () {
        var optionsList = Array(optionsCount);
        for (var i = 0; i < optionsCount; i++) {
            optionsList[i] = 0;
        }
        return optionsList.map(function (_, index) {
            var option = (0, date_time_utilities_1.addMinutes)(dateStartAnchor, increments * index);
            option.setSeconds(0);
            var formattedTimeString = (0, date_time_utilities_1.formatTimeString)(option, showSeconds, useHour12);
            var optionText = onFormatDate ? onFormatDate(option) : formattedTimeString;
            return {
                key: formattedTimeString,
                text: optionText,
                data: option,
            };
        });
    }, [dateStartAnchor, increments, optionsCount, showSeconds, onFormatDate, useHour12]);
    React.useEffect(function () {
        if (selectedTime && !isNaN(selectedTime.valueOf())) {
            var formattedTimeString_1 = (0, date_time_utilities_1.formatTimeString)(selectedTime, showSeconds, useHour12);
            var comboboxOption = timePickerOptions.find(function (option) { return option.key === formattedTimeString_1; });
            setSelectedKey(comboboxOption === null || comboboxOption === void 0 ? void 0 : comboboxOption.key);
            setComboBoxText(comboboxOption ? comboboxOption.text : formattedTimeString_1);
        }
        else {
            setSelectedKey(null);
        }
    }, [selectedTime, timePickerOptions, onFormatDate, showSeconds, useHour12]);
    var onInputChange = React.useCallback(function (ev, option, _index, input) {
        var validateUserInput = function (userInput) {
            var errorMessageToDisplay = '';
            var regex;
            if (useHour12) {
                regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_12 : REGEX_HIDE_SECONDS_HOUR_12;
            }
            else {
                regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_24 : REGEX_HIDE_SECONDS_HOUR_24;
            }
            if (!regex.test(userInput)) {
                errorMessageToDisplay = strings.invalidInputErrorMessage;
            }
            else if (timeRange && strings.timeOutOfBoundsErrorMessage) {
                var optionDate = (0, date_time_utilities_1.getDateFromTimeSelection)(useHour12, dateStartAnchor, userInput);
                if (optionDate < dateStartAnchor || optionDate > dateEndAnchor) {
                    errorMessageToDisplay = (0, Utilities_2.format)(strings.timeOutOfBoundsErrorMessage, dateStartAnchor.toString(), dateEndAnchor.toString());
                }
            }
            return errorMessageToDisplay;
        };
        var errorMessageToDisplay = '';
        if (input) {
            if (allowFreeform && !option) {
                if (!onFormatDate) {
                    // Validate only if user did not add onFormatDate
                    errorMessageToDisplay = validateUserInput(input);
                }
                else {
                    // Use user provided validation if onFormatDate is provided
                    if (onValidateUserInput) {
                        errorMessageToDisplay = onValidateUserInput(input);
                    }
                }
            }
        }
        if (onValidationResult && errorMessage !== errorMessageToDisplay) {
            // only call onValidationResult if stored errorMessage state value is different from latest error message
            onValidationResult(ev, { errorMessage: errorMessageToDisplay });
        }
        var changedTime;
        if (errorMessageToDisplay || (input !== undefined && !input.length)) {
            var timeSelection = input || (option === null || option === void 0 ? void 0 : option.text) || '';
            setComboBoxText(timeSelection);
            setSelectedTime(errorMessageToDisplay ? new Date('invalid') : undefined);
            changedTime = new Date('invalid');
        }
        else {
            var updatedTime = void 0;
            if ((option === null || option === void 0 ? void 0 : option.data) instanceof Date) {
                updatedTime = option.data;
            }
            else {
                var timeSelection = (option === null || option === void 0 ? void 0 : option.key) || input || '';
                updatedTime = (0, date_time_utilities_1.getDateFromTimeSelection)(useHour12, dateStartAnchor, timeSelection);
            }
            setSelectedTime(updatedTime);
            changedTime = updatedTime;
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(ev, changedTime);
        setErrorMessage(errorMessageToDisplay);
    }, [
        timeRange,
        dateStartAnchor,
        dateEndAnchor,
        allowFreeform,
        onFormatDate,
        onValidateUserInput,
        showSeconds,
        useHour12,
        strings.invalidInputErrorMessage,
        strings.timeOutOfBoundsErrorMessage,
        setSelectedTime,
        onValidationResult,
        onChange,
        errorMessage,
    ]);
    var evaluatePressedKey = function (event) {
        // eslint-disable-next-line deprecation/deprecation
        var charCode = event.charCode;
        if (!onFormatDate &&
            // Only permit input of digits, space, colon, A/P/M characters
            !((charCode >= Utilities_1.KeyCodes.zero && charCode <= Utilities_1.KeyCodes.colon) ||
                charCode === Utilities_1.KeyCodes.space ||
                charCode === Utilities_1.KeyCodes.a ||
                charCode === Utilities_1.KeyCodes.m ||
                charCode === Utilities_1.KeyCodes.p)) {
            event.preventDefault();
        }
    };
    return (React.createElement(ComboBox_1.ComboBox, tslib_1.__assign({}, rest, { allowFreeform: allowFreeform, selectedKey: selectedKey, label: label, errorMessage: errorMessage, options: timePickerOptions, onChange: onInputChange, text: comboBoxText, 
        //eslint-disable-next-line
        onKeyPress: evaluatePressedKey, useComboBoxAsMenuWidth: true })));
};
exports.TimePicker = TimePicker;
exports.TimePicker.displayName = 'TimePicker';
var getDateAnchor = function (internalDateAnchor, startEnd, increments, timeRange) {
    var clampedDateAnchor = new Date(internalDateAnchor.getTime());
    if (timeRange) {
        var clampedTimeRange = clampTimeRange(timeRange);
        var timeRangeHours = startEnd === 'start' ? clampedTimeRange.start : clampedTimeRange.end;
        if (clampedDateAnchor.getHours() !== timeRangeHours) {
            clampedDateAnchor.setHours(timeRangeHours);
        }
    }
    else if (startEnd === 'end') {
        clampedDateAnchor.setDate(clampedDateAnchor.getDate() + 1);
    }
    clampedDateAnchor.setMinutes(0);
    clampedDateAnchor.setSeconds(0);
    clampedDateAnchor.setMilliseconds(0);
    return (0, date_time_utilities_1.ceilMinuteToIncrement)(clampedDateAnchor, increments);
};
var clampTimeRange = function (timeRange) {
    return {
        start: Math.min(Math.max(timeRange.start, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
        end: Math.min(Math.max(timeRange.end, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
    };
};
var getHoursInRange = function (timeRange) {
    var hoursInRange = date_time_utilities_1.TimeConstants.HoursInOneDay;
    if (timeRange) {
        var clampedTimeRange = clampTimeRange(timeRange);
        if (clampedTimeRange.start > clampedTimeRange.end) {
            hoursInRange = date_time_utilities_1.TimeConstants.HoursInOneDay - timeRange.start - timeRange.end;
        }
        else if (timeRange.end > timeRange.start) {
            hoursInRange = timeRange.end - timeRange.start;
        }
    }
    return hoursInRange;
};
var getDropdownOptionsCount = function (increments, timeRange) {
    var hoursInRange = getHoursInRange(timeRange);
    return Math.floor((date_time_utilities_1.TimeConstants.MinutesInOneHour * hoursInRange) / increments);
};
//# sourceMappingURL=TimePicker.js.map