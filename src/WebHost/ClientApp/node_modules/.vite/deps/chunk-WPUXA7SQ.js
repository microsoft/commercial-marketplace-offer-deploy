import {
  getTheme
} from "./chunk-53BTC5C3.js";
import {
  KeyCodes,
  __assign,
  __extends,
  createMergedRef,
  css,
  elementContains,
  findScrollableParent,
  getDocument,
  getElementIndexPath,
  getFocusableByIndexPath,
  getId,
  getNativeProps,
  getNextElement,
  getParent,
  getPreviousElement,
  getRTL,
  hoistMethods,
  htmlElementProperties,
  initializeComponentRef,
  isElementFocusSubZone,
  isElementFocusZone,
  isElementTabbable,
  isElementVisibleAndNotHidden,
  mergeStyles,
  portalContainsElement,
  setVersion,
  shouldWrapFocus,
  unhoistMethods,
  warnDeprecations
} from "./chunk-T5LOAC42.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.types.js
var FocusZoneTabbableElements = {
  /** Tabbing is not allowed */
  none: 0,
  /** All tabbing action is allowed */
  all: 1,
  /** Tabbing is allowed only on input elements */
  inputOnly: 2
};
var FocusZoneDirection;
(function(FocusZoneDirection2) {
  FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
  FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
  FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
  FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
})(FocusZoneDirection || (FocusZoneDirection = {}));

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var React = __toESM(require_react());
var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
var TABINDEX = "tabindex";
var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var focusZoneStyles;
var focusZoneClass = "ms-FocusZone";
function raiseClickFromKeyboardEvent(target, ev) {
  var event;
  if (typeof MouseEvent === "function") {
    event = new MouseEvent("click", {
      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
    });
  } else {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click",
      ev ? ev.bubbles : false,
      ev ? ev.cancelable : false,
      window,
      // not using getWindow() since this can only be run client side
      0,
      // detail
      0,
      // screen x
      0,
      // screen y
      0,
      // client x
      0,
      // client y
      ev ? ev.ctrlKey : false,
      ev ? ev.altKey : false,
      ev ? ev.shiftKey : false,
      ev ? ev.metaKey : false,
      0,
      // button
      null
    );
  }
  target.dispatchEvent(event);
}
function getRootClass() {
  if (!focusZoneStyles) {
    focusZoneStyles = mergeStyles({
      selectors: {
        ":focus": {
          outline: "none"
        }
      }
    }, focusZoneClass);
  }
  return focusZoneStyles;
}
var _allInstances = {};
var _outerZones = /* @__PURE__ */ new Set();
var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search", "textarea"];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = (
  /** @class */
  function(_super) {
    __extends(FocusZone2, _super);
    function FocusZone2(props) {
      var _this = this;
      var _a, _b, _c, _d;
      _this = _super.call(this, props) || this;
      _this._root = React.createRef();
      _this._mergedRef = createMergedRef();
      _this._onFocus = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a2 = _this.props, onActiveElementChanged = _a2.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a2.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a2.stopFocusPropagation, onFocusNotification = _a2.onFocusNotification, onFocus = _a2.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a2.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a2.defaultTabbableElement;
        var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
        var newActiveElement;
        if (isImmediateDescendant) {
          newActiveElement = ev.target;
        } else {
          var parentElement = ev.target;
          while (parentElement && parentElement !== _this._root.current) {
            if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
              newActiveElement = parentElement;
              break;
            }
            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
          }
        }
        if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
          var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
          if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
            newActiveElement = maybeElementToFocus;
            maybeElementToFocus.focus();
          } else {
            _this.focus(true);
            if (_this._activeElement) {
              newActiveElement = null;
            }
          }
        }
        var initialElementFocused = !_this._activeElement;
        if (newActiveElement && newActiveElement !== _this._activeElement) {
          if (isImmediateDescendant || initialElementFocused) {
            _this._setFocusAlignment(newActiveElement, true, true);
          }
          _this._activeElement = newActiveElement;
          if (initialElementFocused) {
            _this._updateTabIndexes();
          }
        }
        if (onActiveElementChanged) {
          onActiveElementChanged(_this._activeElement, ev);
        }
        if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
          ev.stopPropagation();
        }
        if (onFocus) {
          onFocus(ev);
        } else if (onFocusNotification) {
          onFocusNotification();
        }
      };
      _this._onBlur = function() {
        _this._setParkedFocus(false);
      };
      _this._onMouseDown = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var disabled = _this.props.disabled;
        if (disabled) {
          return;
        }
        var target = ev.target;
        var path = [];
        while (target && target !== _this._root.current) {
          path.push(target);
          target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        }
        while (path.length) {
          target = path.pop();
          if (target && isElementTabbable(target)) {
            _this._setActiveElement(target, true);
          }
          if (isElementFocusZone(target)) {
            break;
          }
        }
      };
      _this._onKeyDown = function(ev, theme) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a2 = _this.props, direction = _a2.direction, disabled = _a2.disabled, isInnerZoneKeystroke = _a2.isInnerZoneKeystroke, pagingSupportDisabled = _a2.pagingSupportDisabled, shouldEnterInnerZone = _a2.shouldEnterInnerZone;
        if (disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        if (ev.isDefaultPrevented()) {
          return;
        }
        if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
          return;
        }
        if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
          var innerZone = _this._getFirstInnerZone();
          if (innerZone) {
            if (!innerZone.focus(true)) {
              return;
            }
          } else if (isElementFocusSubZone(ev.target)) {
            if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
              return;
            }
          } else {
            return;
          }
        } else if (ev.altKey) {
          return;
        } else {
          switch (ev.which) {
            case KeyCodes.space:
              if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            case KeyCodes.left:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusLeft(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.right:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusRight(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.up:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusUp()) {
                  break;
                }
              }
              return;
            case KeyCodes.down:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusDown()) {
                  break;
                }
              }
              return;
            case KeyCodes.pageDown:
              if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                break;
              }
              return;
            case KeyCodes.pageUp:
              if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                break;
              }
              return;
            case KeyCodes.tab:
              if (
                // eslint-disable-next-line deprecation/deprecation
                _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)
              ) {
                var focusChanged = false;
                _this._processingTabKey = true;
                if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                  focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                } else {
                  var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                  focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                }
                _this._processingTabKey = false;
                if (focusChanged) {
                  break;
                } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                  _this._activeElement = null;
                }
              }
              return;
            case KeyCodes.home:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
                return false;
              }
              var firstChild = _this._root.current && _this._root.current.firstChild;
              if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                break;
              }
              return;
            case KeyCodes.end:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
                return false;
              }
              var lastChild = _this._root.current && _this._root.current.lastChild;
              if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                break;
              }
              return;
            case KeyCodes.enter:
              if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            default:
              return;
          }
        }
        ev.preventDefault();
        ev.stopPropagation();
      };
      _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
        var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(targetRect.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
        var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
        if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            return 0;
          }
          return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      };
      initializeComponentRef(_this);
      if (true) {
        warnDeprecations("FocusZone", props, {
          rootProps: void 0,
          allowTabKey: "handleTabKey",
          elementType: "as",
          ariaDescribedBy: "aria-describedby",
          ariaLabelledBy: "aria-labelledby"
        });
      }
      _this._id = getId("FocusZone");
      _this._focusAlignment = {
        left: 0,
        top: 0
      };
      _this._processingTabKey = false;
      var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;
      _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;
      _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;
      return _this;
    }
    FocusZone2.getOuterZones = function() {
      return _outerZones.size;
    };
    FocusZone2._onKeyDownCapture = function(ev) {
      if (ev.which === KeyCodes.tab) {
        _outerZones.forEach(function(zone) {
          return zone._updateTabIndexes();
        });
      }
    };
    FocusZone2.prototype.componentDidMount = function() {
      var root = this._root.current;
      _allInstances[this._id] = this;
      if (root) {
        var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
          if (isElementFocusZone(parentElement)) {
            this._isInnerZone = true;
            break;
          }
          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        if (!this._isInnerZone) {
          _outerZones.add(this);
          this._root.current && this._root.current.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
        }
        this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
        this._updateTabIndexes();
        if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
          this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
        } else if (this.props.defaultActiveElement) {
          this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
        }
        if (this.props.shouldFocusOnMount) {
          this.focus();
        }
      }
    };
    FocusZone2.prototype.componentDidUpdate = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {
        this._activeElement = null;
        this._defaultFocusElement = null;
        this._updateTabIndexes();
      }
      if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {
        var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);
        if (elementToFocus) {
          this._setActiveElement(elementToFocus, true);
          elementToFocus.focus();
          this._setParkedFocus(false);
        } else {
          this._setParkedFocus(true);
        }
      }
    };
    FocusZone2.prototype.componentWillUnmount = function() {
      delete _allInstances[this._id];
      if (!this._isInnerZone) {
        _outerZones.delete(this);
        this._root.current && this._root.current.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
      }
      if (this._root.current) {
        this._root.current.removeEventListener("blur", this._onBlur, true);
      }
      this._activeElement = null;
      this._defaultFocusElement = null;
    };
    FocusZone2.prototype.render = function() {
      var _this = this;
      var _a = this.props, tag = _a.as, elementType = _a.elementType, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;
      var divProps = getNativeProps(this.props, htmlElementProperties);
      var Tag = tag || elementType || "div";
      this._evaluateFocusBeforeRender();
      var theme = getTheme();
      return React.createElement(Tag, __assign({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
        // Once the getClassName correctly memoizes inputs this should
        // be replaced so that className is passed to getRootClass and is included there so
        // the class names will always be in the same order.
        className: css(getRootClass(), className),
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._root),
        "data-focuszone-id": this._id,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: function(ev) {
          return _this._onKeyDown(ev, theme);
        },
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    };
    FocusZone2.prototype.focus = function(forceIntoFirstElement, bypassHiddenElements) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      if (bypassHiddenElements === void 0) {
        bypassHiddenElements = false;
      }
      if (this._root.current) {
        if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && this._isInnerZone) {
          var ownerZoneElement = this._getOwnerZone(this._root.current);
          if (ownerZoneElement !== this._root.current) {
            var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            return !!ownerZone && ownerZone.focusElement(this._root.current);
          }
          return false;
        } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement) && (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {
          this._activeElement.focus();
          return true;
        } else {
          var firstChild = this._root.current.firstChild;
          return this.focusElement(getNextElement(this._root.current, firstChild, true, void 0, void 0, void 0, void 0, void 0, bypassHiddenElements));
        }
      }
      return false;
    };
    FocusZone2.prototype.focusLast = function() {
      if (this._root.current) {
        var lastChild = this._root.current && this._root.current.lastChild;
        return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
      }
      return false;
    };
    FocusZone2.prototype.focusElement = function(element, forceAlignment) {
      var _a = this.props, onBeforeFocus = _a.onBeforeFocus, shouldReceiveFocus = _a.shouldReceiveFocus;
      if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {
        return false;
      }
      if (element) {
        this._setActiveElement(element, forceAlignment);
        if (this._activeElement) {
          this._activeElement.focus();
        }
        return true;
      }
      return false;
    };
    FocusZone2.prototype.setFocusAlignment = function(point) {
      this._focusAlignment = point;
    };
    Object.defineProperty(FocusZone2.prototype, "defaultFocusElement", {
      get: function() {
        return this._defaultFocusElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FocusZone2.prototype, "activeElement", {
      get: function() {
        return this._activeElement;
      },
      enumerable: false,
      configurable: true
    });
    FocusZone2.prototype._evaluateFocusBeforeRender = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (doc) {
        var focusedElement = doc.activeElement;
        if (focusedElement !== root) {
          var shouldRestoreFocus = elementContains(root, focusedElement, false);
          this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : void 0;
        }
      }
    };
    FocusZone2.prototype._setParkedFocus = function(isParked) {
      var root = this._root.current;
      if (root && this._isParked !== isParked) {
        this._isParked = isParked;
        if (isParked) {
          if (!this.props.allowFocusRoot) {
            this._parkedTabIndex = root.getAttribute("tabindex");
            root.setAttribute("tabindex", "-1");
          }
          root.focus();
        } else if (!this.props.allowFocusRoot) {
          if (this._parkedTabIndex) {
            root.setAttribute("tabindex", this._parkedTabIndex);
            this._parkedTabIndex = void 0;
          } else {
            root.removeAttribute("tabindex");
          }
        }
      }
    };
    FocusZone2.prototype._setActiveElement = function(element, forceAlignment) {
      var previousActiveElement = this._activeElement;
      this._activeElement = element;
      if (previousActiveElement) {
        if (isElementFocusZone(previousActiveElement)) {
          this._updateTabIndexes(previousActiveElement);
        }
        previousActiveElement.tabIndex = -1;
      }
      if (this._activeElement) {
        if (!this._focusAlignment || forceAlignment) {
          this._setFocusAlignment(element, true, true);
        }
        this._activeElement.tabIndex = 0;
      }
    };
    FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
      this.props.preventDefaultWhenHandled && ev.preventDefault();
    };
    FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
      var target = targetElement;
      if (target === this._root.current) {
        return false;
      }
      do {
        if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SUMMARY") {
          return false;
        }
        if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
          raiseClickFromKeyboardEvent(target, ev);
          return true;
        }
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      } while (target !== this._root.current);
      return false;
    };
    FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
      rootElement = rootElement || this._activeElement || this._root.current;
      if (!rootElement) {
        return null;
      }
      if (isElementFocusZone(rootElement)) {
        return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }
      var child = rootElement.firstElementChild;
      while (child) {
        if (isElementFocusZone(child)) {
          return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
        }
        var match = this._getFirstInnerZone(child);
        if (match) {
          return match;
        }
        child = child.nextElementSibling;
      }
      return null;
    };
    FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      var candidateDistance = -1;
      var candidateElement = void 0;
      var changedFocus = false;
      var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (isBidirectional) {
          if (element) {
            var targetRect = element.getBoundingClientRect();
            var elementDistance = getDistanceFromCenter(activeRect, targetRect);
            if (elementDistance === -1 && candidateDistance === -1) {
              candidateElement = element;
              break;
            }
            if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
            if (candidateDistance >= 0 && elementDistance < 0) {
              break;
            }
          }
        } else {
          candidateElement = element;
          break;
        }
      } while (element);
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        } else {
          return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
      }
      return changedFocus;
    };
    FocusZone2.prototype._moveFocusDown = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(true, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          if (targetRectTop < activeRectBottom) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusUp = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(false, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectBottom = Math.floor(targetRect.bottom);
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectTop = Math.floor(activeRect.top);
          if (targetRectBottom > activeRectTop) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusLeft = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        getRTL(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL(theme)) {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          }
          if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = activeRect.right - targetRect.right;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusRight = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        !getRTL(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL(theme)) {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          }
          if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = targetRect.left - activeRect.left;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var scrollableParent = findScrollableParent(element);
      if (!scrollableParent) {
        return false;
      }
      var candidateDistance = -1;
      var candidateElement = void 0;
      var targetTop = -1;
      var targetBottom = -1;
      var pagesize = scrollableParent.clientHeight;
      var activeRect = element.getBoundingClientRect();
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (element) {
          var targetRect = element.getBoundingClientRect();
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          var targetRectBottom = Math.floor(targetRect.bottom);
          var activeRectTop = Math.floor(activeRect.top);
          var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
          var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
          var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
          if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
            break;
          }
          if (elementDistance > -1) {
            if (isForward && targetRectTop > targetTop) {
              targetTop = targetRectTop;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (!isForward && targetRectBottom < targetBottom) {
              targetBottom = targetRectBottom;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
          }
        }
      } while (element);
      var changedFocus = false;
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
        this._setFocusAlignment(candidateElement, false, true);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }
        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }
      return changedFocus;
    };
    FocusZone2.prototype._setFocusAlignment = function(element, isHorizontal, isVertical) {
      if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
        var rect = element.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top_1 = rect.top + rect.height / 2;
        if (!this._focusAlignment) {
          this._focusAlignment = { left, top: top_1 };
        }
        if (isHorizontal) {
          this._focusAlignment.left = left;
        }
        if (isVertical) {
          this._focusAlignment.top = top_1;
        }
      }
    };
    FocusZone2.prototype._isImmediateDescendantOfZone = function(element) {
      return this._getOwnerZone(element) === this._root.current;
    };
    FocusZone2.prototype._getOwnerZone = function(element) {
      var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
      while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
        if (isElementFocusZone(parentElement)) {
          return parentElement;
        }
        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }
      return parentElement;
    };
    FocusZone2.prototype._updateTabIndexes = function(element) {
      if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
        this._activeElement = this.props.defaultTabbableElement(this._root.current);
      }
      if (!element && this._root.current) {
        this._defaultFocusElement = null;
        element = this._root.current;
        if (this._activeElement && !elementContains(element, this._activeElement)) {
          this._activeElement = null;
        }
      }
      if (this._activeElement && !isElementTabbable(this._activeElement)) {
        this._activeElement = null;
      }
      var childNodes = element && element.children;
      for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
        var child = childNodes[childIndex];
        if (!isElementFocusZone(child)) {
          if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "false") {
            child.setAttribute(TABINDEX, "-1");
          }
          if (isElementTabbable(child)) {
            if (this.props.disabled) {
              child.setAttribute(TABINDEX, "-1");
            } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
              this._defaultFocusElement = child;
              if (child.getAttribute(TABINDEX) !== "0") {
                child.setAttribute(TABINDEX, "0");
              }
            } else if (child.getAttribute(TABINDEX) !== "-1") {
              child.setAttribute(TABINDEX, "-1");
            }
          } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
            child.setAttribute("focusable", "false");
          }
        } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true") {
          if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;
            if (child.getAttribute(TABINDEX) !== "0") {
              child.setAttribute(TABINDEX, "0");
            }
          } else if (child.getAttribute(TABINDEX) !== "-1") {
            child.setAttribute(TABINDEX, "-1");
          }
        }
        this._updateTabIndexes(child);
      }
    };
    FocusZone2.prototype._isContentEditableElement = function(element) {
      return element && element.getAttribute("contenteditable") === "true";
    };
    FocusZone2.prototype._isElementInput = function(element) {
      if (element && element.tagName && (element.tagName.toLowerCase() === "input" || element.tagName.toLowerCase() === "textarea")) {
        return true;
      }
      return false;
    };
    FocusZone2.prototype._shouldInputLoseFocus = function(element, isForward) {
      if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
        var selectionStart = element.selectionStart;
        var selectionEnd = element.selectionEnd;
        var isRangeSelected = selectionStart !== selectionEnd;
        var inputValue = element.value;
        var isReadonly = element.readOnly;
        if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
          return false;
        }
      }
      return true;
    };
    FocusZone2.prototype._shouldWrapFocus = function(element, noWrapDataAttribute) {
      return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
    };
    FocusZone2.prototype._portalContainsElement = function(element) {
      return element && !!this._root.current && portalContainsElement(element, this._root.current);
    };
    FocusZone2.prototype._getDocument = function() {
      return getDocument(this._root.current);
    };
    FocusZone2.defaultProps = {
      isCircularNavigation: false,
      direction: FocusZoneDirection.bidirectional,
      shouldRaiseClicks: true
    };
    return FocusZone2;
  }(React.Component)
);

// node_modules/@fluentui/react-focus/lib/version.js
setVersion("@fluentui/react-focus", "8.8.31");

// node_modules/@fluentui/react/lib/utilities/decorators/BaseDecorator.js
var React2 = __toESM(require_react());
var BaseDecorator = (
  /** @class */
  function(_super) {
    __extends(BaseDecorator2, _super);
    function BaseDecorator2(props) {
      var _this = _super.call(this, props) || this;
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      return _this;
    }
    BaseDecorator2.prototype._updateComposedComponentRef = function(composedComponentInstance) {
      this._composedComponentInstance = composedComponentInstance;
      if (composedComponentInstance) {
        this._hoisted = hoistMethods(this, composedComponentInstance);
      } else if (this._hoisted) {
        unhoistMethods(this, this._hoisted);
      }
    };
    return BaseDecorator2;
  }(React2.Component)
);

export {
  FocusZoneTabbableElements,
  FocusZoneDirection,
  FocusZone,
  BaseDecorator
};
//# sourceMappingURL=chunk-WPUXA7SQ.js.map
