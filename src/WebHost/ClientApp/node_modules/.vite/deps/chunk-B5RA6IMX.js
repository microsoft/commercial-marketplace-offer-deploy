import {
  __assign,
  divProperties,
  elementContains,
  focusAsync,
  getFirstTabbable,
  getLastTabbable,
  getNativeProps,
  getNextElement,
  getPropsWithDefaults,
  modalize,
  on,
  useConst,
  useDocument,
  useEventCallback,
  useId,
  useMergedRefs,
  usePrevious,
  useUnmount
} from "./chunk-T5LOAC42.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@fluentui/react/lib/components/FocusTrapZone/FocusTrapZone.js
var React = __toESM(require_react());
var COMPONENT_NAME = "FocusTrapZone";
var DEFAULT_PROPS = {
  disabled: false,
  disableFirstFocus: false,
  forceFocusInsideTrap: true,
  isClickableOutsideFocusTrap: false
};
var useComponentRef = function(componentRef, previouslyFocusedElement, focusFTZ) {
  React.useImperativeHandle(componentRef, function() {
    return {
      get previouslyFocusedElement() {
        return previouslyFocusedElement;
      },
      focus: focusFTZ
    };
  }, [focusFTZ, previouslyFocusedElement]);
};
var FocusTrapZone = React.forwardRef(function(propsWithoutDefaults, ref) {
  var _a;
  var root = React.useRef(null);
  var firstBumper = React.useRef(null);
  var lastBumper = React.useRef(null);
  var mergedRootRef = useMergedRefs(root, ref);
  var doc = useDocument();
  var isFirstRender = (_a = usePrevious(false)) !== null && _a !== void 0 ? _a : true;
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var internalState = useConst({
    hasFocus: false,
    focusStackId: useId("ftz-", props.id)
  });
  var children = props.children, componentRef = props.componentRef, disabled = props.disabled, disableFirstFocus = props.disableFirstFocus, forceFocusInsideTrap = props.forceFocusInsideTrap, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, _b = props.disableRestoreFocus, disableRestoreFocus = _b === void 0 ? props.ignoreExternalFocusing : _b, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
  var bumperProps = {
    "aria-hidden": true,
    style: {
      pointerEvents: "none",
      position: "fixed"
      // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
    },
    tabIndex: disabled ? -1 : 0,
    "data-is-visible": true,
    "data-is-focus-trap-zone-bumper": true
  };
  var focusElementAsync = React.useCallback(function(element) {
    if (element !== firstBumper.current && element !== lastBumper.current) {
      focusAsync(element);
    }
  }, []);
  var focusFTZ = useEventCallback(function() {
    if (!root.current) {
      return;
    }
    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;
    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {
      focusElementAsync(previouslyFocusedElementInTrapZone);
      return;
    }
    var firstFocusableChild = null;
    if (typeof firstFocusableTarget === "string") {
      firstFocusableChild = root.current.querySelector(firstFocusableTarget);
    } else if (firstFocusableTarget) {
      firstFocusableChild = firstFocusableTarget(root.current);
    } else if (firstFocusableSelector) {
      var focusSelector = typeof firstFocusableSelector === "string" ? firstFocusableSelector : firstFocusableSelector();
      firstFocusableChild = root.current.querySelector("." + focusSelector);
    }
    if (!firstFocusableChild) {
      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);
    }
    if (firstFocusableChild) {
      focusElementAsync(firstFocusableChild);
    }
  });
  var focusBumper = function(isFirstBumper) {
    if (disabled || !root.current) {
      return;
    }
    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false) : getFirstTabbable(root.current, firstBumper.current, true, false);
    if (nextFocusable) {
      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
        focusFTZ();
      } else {
        nextFocusable.focus();
      }
    }
  };
  var onRootBlurCapture = function(ev) {
    var _a2;
    (_a2 = props.onBlurCapture) === null || _a2 === void 0 ? void 0 : _a2.call(props, ev);
    var relatedTarget = ev.relatedTarget;
    if (ev.relatedTarget === null) {
      relatedTarget = doc.activeElement;
    }
    if (!elementContains(root.current, relatedTarget)) {
      internalState.hasFocus = false;
    }
  };
  var onRootFocusCapture = function(ev) {
    var _a2;
    (_a2 = props.onFocusCapture) === null || _a2 === void 0 ? void 0 : _a2.call(props, ev);
    if (ev.target === firstBumper.current) {
      focusBumper(true);
    } else if (ev.target === lastBumper.current) {
      focusBumper(false);
    }
    internalState.hasFocus = true;
    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
      internalState.previouslyFocusedElementInTrapZone = ev.target;
    }
  };
  var returnFocusToInitiator = useEventCallback(function(elementToFocusOnDismiss) {
    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function(value) {
      return internalState.focusStackId !== value;
    });
    if (!doc) {
      return;
    }
    var activeElement = doc.activeElement;
    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === "function" && // only restore focus if the current focused element is within the FTZ, or if nothing is focused
    (elementContains(root.current, activeElement) || activeElement === doc.body)) {
      focusElementAsync(elementToFocusOnDismiss);
    }
  });
  var forceFocusOrClickInTrap = useEventCallback(function(ev) {
    if (disabled) {
      return;
    }
    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {
      var targetElement = ev.target;
      if (targetElement && !elementContains(root.current, targetElement)) {
        if (doc && doc.activeElement === doc.body) {
          setTimeout(function() {
            if (doc && doc.activeElement === doc.body) {
              focusFTZ();
              internalState.hasFocus = true;
            }
          }, 0);
        } else {
          focusFTZ();
          internalState.hasFocus = true;
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  });
  React.useEffect(function() {
    var disposables = [];
    if (forceFocusInsideTrap) {
      disposables.push(on(window, "focus", forceFocusOrClickInTrap, true));
    }
    if (!isClickableOutsideFocusTrap) {
      disposables.push(on(window, "click", forceFocusOrClickInTrap, true));
    }
    return function() {
      disposables.forEach(function(dispose) {
        return dispose();
      });
    };
  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);
  React.useEffect(function() {
    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {
      return;
    }
    FocusTrapZone.focusStack.push(internalState.focusStackId);
    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;
    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {
      focusFTZ();
    }
    return function() {
      return returnFocusToInitiator(elementToFocusOnDismiss);
    };
  }, [forceFocusInsideTrap, disabled]);
  React.useEffect(function() {
    if (!disabled && enableAriaHiddenSiblings) {
      var unmodalize = modalize(root.current);
      return unmodalize;
    }
  }, [disabled, enableAriaHiddenSiblings, root]);
  useUnmount(function() {
    delete internalState.previouslyFocusedElementInTrapZone;
  });
  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);
  return React.createElement(
    "div",
    __assign({ "aria-labelledby": props.ariaLabelledBy }, getNativeProps(props, divProperties), { ref: mergedRootRef, onFocusCapture: onRootFocusCapture, onBlurCapture: onRootBlurCapture }),
    React.createElement("div", __assign({}, bumperProps, { ref: firstBumper })),
    children,
    React.createElement("div", __assign({}, bumperProps, { ref: lastBumper }))
  );
});
FocusTrapZone.displayName = COMPONENT_NAME;
FocusTrapZone.focusStack = [];

export {
  FocusTrapZone
};
//# sourceMappingURL=chunk-B5RA6IMX.js.map
