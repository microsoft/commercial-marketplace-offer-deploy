{
  "version": 3,
  "sources": ["../../@fluentui/react-focus/lib/components/FocusZone/components/FocusZone/FocusZone.types.ts", "../../@fluentui/react-focus/lib/components/FocusZone/components/FocusZone/FocusZone.tsx", "../../@fluentui/react-focus/lib/version.ts", "../../@fluentui/react/lib/utilities/decorators/utilities/decorators/BaseDecorator.ts"],
  "sourcesContent": ["import * as React from 'react';\nimport type { IRefObject, Point } from '@fluentui/utilities';\n\n/**\n * FocusZone component class interface.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZone {\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement?: boolean, bypassHiddenElements?: boolean): boolean;\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean;\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param childElement - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(childElement?: HTMLElement, forceAlignment?: boolean): boolean;\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference, rather\n   * than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  setFocusAlignment(point: Point): void;\n}\n\n/**\n * FocusZone component props.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZoneProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * Optional callback to access the IFocusZone interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<IFocusZone>;\n\n  /**\n   * Optional callback to access the root DOM element.\n   * @deprecated Temporary solution which will be replaced with ref in the V8 release.\n   */\n  elementRef?: React.Ref<HTMLElement>;\n\n  /**\n   * Additional class name to provide on the root element, in addition to the ms-FocusZone class.\n   */\n  className?: string;\n\n  /**\n   * Defines which arrows to react to.\n   * @defaultvalue FocusZoneDirection.bidirectional\n   */\n  direction?: FocusZoneDirection;\n\n  /**\n   * Optionally defines the initial tabbable element inside the FocusZone.\n   * If a string is passed then it is treated as a selector for identifying the initial tabbable element.\n   * If a function is passed then it uses the root element as a parameter to return the initial tabbable element.\n   */\n  defaultTabbableElement?: string | ((root: HTMLElement) => HTMLElement);\n\n  /**\n   * Optionally provide a selector for identifying the initial active element.\n   * @deprecated Use `defaultTabbableElement` instead.\n   */\n  defaultActiveElement?: string;\n\n  /**\n   * Determines if a default tabbable element should be force focused on FocusZone mount.\n   * @default false\n   */\n  shouldFocusOnMount?: boolean;\n\n  /**\n   * If set, the FocusZone will not be tabbable and keyboard navigation will be disabled.\n   * This does not affect disabled attribute of any child.\n   */\n  disabled?: boolean;\n\n  /**\n   * Element type the root element will use. Default is \"div\".\n   * @deprecated Use `as` instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  elementType?: any /* TODO should be `keyof React.ReactHTML`, tracking with https://github.com/Microsoft/TypeScript/issues/30050 */;\n\n  /**\n   * A component that should be used as the root element of the FocusZone component.\n   */\n  as?: React.ElementType;\n\n  /**\n   * If set, will cycle to the beginning of the targets once the user navigates to the\n   * next target while at the end, and to the end when navigate to the previous at the beginning.\n   */\n  isCircularNavigation?: boolean;\n\n  /**\n   * If provided, this callback will be executed on keypresses to determine if the user\n   * intends to navigate into the inner zone. Returning true will ask the first inner zone to\n   * set focus.\n   * @deprecated Use `shouldEnterInnerZone` instead.\n   */\n  isInnerZoneKeystroke?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Callback function that will be executed on keypresses to determine if the user intends to navigate into\n   * the inner (nested) zone. Returning true will ask the first inner zone to set focus.\n   */\n  shouldEnterInnerZone?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Sets the aria-labelledby attribute.\n   * @deprecated Directly use the `aria-labelledby` attribute instead\n   */\n  ariaLabelledBy?: string;\n\n  /**\n   * Sets the aria-describedby attribute.\n   * @deprecated Directly use the `aria-describedby` attribute instead\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * Callback for when one of immediate children elements gets active by getting focused\n   * or by having one of its respective children elements focused.\n   */\n  onActiveElementChanged?: (element?: HTMLElement, ev?: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * @deprecated Div props provided to the FocusZone will be mixed into the root element.\n   * Deprecated at v1.12.1.\n   */\n  rootProps?: React.HTMLAttributes<HTMLDivElement>;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   * @deprecated Use `shouldReceiveFocus` instead.\n   */\n  onBeforeFocus?: (childElement?: HTMLElement) => boolean;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   */\n  shouldReceiveFocus?: (childElement?: HTMLElement) => boolean;\n\n  /** Allows focus to park on root when focus is in the `FocusZone` at render time. */\n  allowFocusRoot?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   * @deprecated Use `handleTabKey` instead.\n   *\n   */\n  allowTabKey?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   */\n  handleTabKey?: FocusZoneTabbableElements;\n\n  /**\n   * If true and FocusZone's root element (container) receives focus, the focus will land either on the\n   * defaultTabbableElement (if set) or on the first tabbable element of this FocusZone.\n   * Usually a case for nested focus zones, when the nested focus zone's container is a focusable element.\n   */\n  shouldFocusInnerElementWhenReceivedFocus?: boolean;\n\n  /**\n   * If true and TAB key is not handled by FocusZone, resets current active element to null value.\n   * For example, when roving index is not desirable and focus should always reset to the default tabbable element.\n   */\n  shouldResetActiveElementWhenTabFromZone?: boolean;\n\n  /**\n   * Determines whether the FocusZone will walk up the DOM trying to invoke click callbacks on focusable elements on\n   * Enter and Space keydowns to ensure accessibility for tags that don't guarantee this behavior.\n   * @defaultvalue true\n   */\n  shouldRaiseClicks?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Enter\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnEnter?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Space\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnSpace?: boolean;\n\n  /**\n   * A callback method to determine if an input or textarea element should lose focus on arrow keys\n   *  @param inputElement - The input or textarea element which is to lose focus.\n   *  @returns True if input element should loose focus or false otherwise.\n   */\n  shouldInputLoseFocusOnArrowKey?: (inputElement: HTMLInputElement | HTMLTextAreaElement) => boolean;\n\n  /**\n   * Determines whether to disable the paging support for Page Up and Page Down keyboard scenarios.\n   * @defaultvalue false\n   */\n  pagingSupportDisabled?: boolean;\n\n  /**\n   * Determines whether to check for data-no-horizontal-wrap or data-no-vertical-wrap attributes\n   * when determining how to move focus\n   * @defaultvalue false\n   */\n  checkForNoWrap?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   * @deprecated Use `stopFocusPropagation` instead.\n   */\n  doNotAllowFocusEventToPropagate?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   */\n  stopFocusPropagation?: boolean;\n\n  /**\n   * Callback to notify creators that focus has been set on the FocusZone\n   * @deprecated Use `onFocus` instead.\n   */\n  onFocusNotification?: () => void;\n\n  /**\n   * Callback called when \"focus\" event triggered in FocusZone.\n   * @param event - React's original FocusEvent.\n   */\n  onFocus?: (event: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * If true, FocusZone prevents the default behavior of Keyboard events when changing focus between elements.\n   * @defaultvalue false\n   */\n  preventDefaultWhenHandled?: boolean;\n\n  /**\n   * If true, prevents the FocusZone from attempting to restore the focus to the inner element when the focus is on the\n   * root element after componentDidUpdate.\n   * @defaultvalue false\n   */\n  preventFocusRestoration?: boolean;\n}\n/**\n * {@docCategory FocusZone}\n */\nexport const FocusZoneTabbableElements = {\n  /** Tabbing is not allowed */\n  none: 0 as 0,\n\n  /** All tabbing action is allowed */\n  all: 1 as 1,\n\n  /** Tabbing is allowed only on input elements */\n  inputOnly: 2 as 2,\n};\n\n/**\n * {@docCategory FocusZone}\n */\nexport type FocusZoneTabbableElements = (typeof FocusZoneTabbableElements)[keyof typeof FocusZoneTabbableElements];\n\n/**\n * {@docCategory FocusZone}\n */\nexport enum FocusZoneDirection {\n  /** Only react to up/down arrows. */\n  vertical = 0,\n\n  /** Only react to left/right arrows. */\n  horizontal = 1,\n\n  /** React to all arrows. */\n  bidirectional = 2,\n\n  /**\n   * React to all arrows. Navigate next item in DOM on right/down arrow keys and previous - left/up arrow keys.\n   * Right and Left arrow keys are swapped in RTL mode.\n   */\n  domOrder = 3,\n}\n", "import * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport {\n  KeyCodes,\n  css,\n  elementContains,\n  getDocument,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  getId,\n  getNativeProps,\n  getNextElement,\n  getParent,\n  getPreviousElement,\n  getRTL,\n  htmlElementProperties,\n  initializeComponentRef,\n  isElementFocusSubZone,\n  isElementFocusZone,\n  isElementTabbable,\n  shouldWrapFocus,\n  warnDeprecations,\n  portalContainsElement,\n  findScrollableParent,\n  createMergedRef,\n  isElementVisibleAndNotHidden,\n} from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nimport type { IFocusZone, IFocusZoneProps } from './FocusZone.types';\nimport type { Point } from '@fluentui/utilities';\nimport type { ITheme } from '@fluentui/style-utilities';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nlet focusZoneStyles: string;\n\nconst focusZoneClass: string = 'ms-FocusZone';\n\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target: Element, ev?: React.KeyboardEvent<HTMLElement>): void {\n  let event;\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev?.ctrlKey,\n      metaKey: ev?.metaKey,\n      shiftKey: ev?.shiftKey,\n      altKey: ev?.altKey,\n      bubbles: ev?.bubbles,\n      cancelable: ev?.cancelable,\n    });\n  } else {\n    event = document.createEvent('MouseEvents');\n    // eslint-disable-next-line deprecation/deprecation\n    event.initMouseEvent(\n      'click',\n      ev ? ev.bubbles : false,\n      ev ? ev.cancelable : false,\n      window, // not using getWindow() since this can only be run client side\n      0, // detail\n      0, // screen x\n      0, // screen y\n      0, // client x\n      0, // client y\n      ev ? ev.ctrlKey : false,\n      ev ? ev.altKey : false,\n      ev ? ev.shiftKey : false,\n      ev ? ev.metaKey : false,\n      0, // button\n      null, // relatedTarget\n    );\n  }\n\n  target.dispatchEvent(event);\n}\n\n// Helper function that will return a class for when the root is focused\nfunction getRootClass(): string {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles(\n      {\n        selectors: {\n          ':focus': {\n            outline: 'none',\n          },\n        },\n      },\n      focusZoneClass,\n    );\n  }\n  return focusZoneStyles;\n}\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\nconst _outerZones: Set<FocusZone> = new Set();\n\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\nexport class FocusZone extends React.Component<IFocusZoneProps> implements IFocusZone {\n  public static defaultProps: IFocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true,\n  };\n\n  private _root: React.RefObject<HTMLElement> = React.createRef();\n  private _mergedRef = createMergedRef<HTMLElement>();\n\n  private _id: string;\n\n  /** The most recently focused child element. */\n  private _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  private _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  private _isParked: boolean;\n\n  /** The child element with tabindex=0. */\n  private _defaultFocusElement: HTMLElement | null;\n  private _focusAlignment: Point;\n  private _isInnerZone: boolean;\n  private _parkedTabIndex: string | null | undefined;\n\n  /** Used to allow moving to next focusable element even when we're focusing on a input element when pressing tab */\n  private _processingTabKey: boolean;\n\n  /** Provides granular control over `shouldRaiseClicks` and should be preferred over `props.shouldRaiseClicks`. */\n  private _shouldRaiseClicksOnEnter: boolean;\n  private _shouldRaiseClicksOnSpace: boolean;\n\n  /** Used for testing purposes only. */\n  public static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n  private static _onKeyDownCapture(ev: KeyboardEvent): void {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach((zone: FocusZone) => zone._updateTabIndexes());\n    }\n  }\n\n  constructor(props: IFocusZoneProps) {\n    super(props);\n    // Manage componentRef resolution.\n    initializeComponentRef(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby',\n      });\n    }\n\n    this._id = getId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n\n    const shouldRaiseClicksFallback = props.shouldRaiseClicks ?? FocusZone.defaultProps.shouldRaiseClicks ?? true;\n    this._shouldRaiseClicksOnEnter = props.shouldRaiseClicksOnEnter ?? shouldRaiseClicksFallback;\n    this._shouldRaiseClicksOnSpace = props.shouldRaiseClicksOnSpace ?? shouldRaiseClicksFallback;\n  }\n\n  public componentDidMount(): void {\n    const { current: root } = this._root;\n\n    _allInstances[this._id] = this;\n\n    if (root) {\n      let parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n\n        this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\n      this._updateTabIndexes();\n\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n        // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement) as HTMLElement;\n      }\n\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  }\n\n  public componentDidUpdate(): void {\n    const { current: root } = this._root;\n    const doc = this._getDocument();\n\n    // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n    // reset those variables (and update tab indexes) to avoid memory leaks\n    if (\n      (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||\n      (this._defaultFocusElement &&\n        !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))\n    ) {\n      this._activeElement = null;\n      this._defaultFocusElement = null;\n      this._updateTabIndexes();\n    }\n\n    if (\n      !this.props.preventFocusRestoration &&\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(root as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  public render(): React.ReactNode {\n    // eslint-disable-next-line deprecation/deprecation\n    const { as: tag, elementType, rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;\n    const divProps = getNativeProps(this.props, htmlElementProperties);\n\n    const Tag = tag || elementType || 'div';\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this._evaluateFocusBeforeRender();\n\n    // Only support RTL defined in global theme, not contextual theme/RTL.\n    const theme: ITheme = getTheme();\n\n    return (\n      <Tag\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        {...divProps}\n        {\n          // root props has been deprecated and should get removed.\n          // it needs to be marked as \"any\" since root props expects a div element, but really Tag can\n          // be any native element so typescript rightly flags this as a problem.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ...(rootProps as any)\n        }\n        // Once the getClassName correctly memoizes inputs this should\n        // be replaced so that className is passed to getRootClass and is included there so\n        // the class names will always be in the same order.\n        className={css(getRootClass(), className)}\n        // eslint-disable-next-line deprecation/deprecation\n        ref={this._mergedRef(this.props.elementRef, this._root)}\n        data-focuszone-id={this._id}\n        // eslint-disable-next-line react/jsx-no-bind\n        onKeyDown={(ev: React.KeyboardEvent<HTMLElement>) => this._onKeyDown(ev, theme)}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement: boolean = false, bypassHiddenElements: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this._getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      } else if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement) &&\n        isElementTabbable(this._activeElement) &&\n        (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))\n      ) {\n        this._activeElement.focus();\n        return true;\n      } else {\n        const firstChild = this._root.current.firstChild as HTMLElement;\n\n        return this.focusElement(\n          getNextElement(\n            this._root.current,\n            firstChild,\n            true,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            bypassHiddenElements,\n          ) as HTMLElement,\n        );\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(element: HTMLElement, forceAlignment?: boolean): boolean {\n    // eslint-disable-next-line deprecation/deprecation\n    const { onBeforeFocus, shouldReceiveFocus } = this.props;\n\n    if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n      return false;\n    }\n\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  public setFocusAlignment(point: Point): void {\n    this._focusAlignment = point;\n  }\n\n  public get defaultFocusElement() {\n    return this._defaultFocusElement;\n  }\n\n  public get activeElement() {\n    return this._activeElement;\n  }\n\n  private _evaluateFocusBeforeRender(): void {\n    const { current: root } = this._root;\n\n    const doc = this._getDocument();\n    if (doc) {\n      const focusedElement = doc.activeElement as HTMLElement;\n\n      // Only update the index path if we are not parked on the root.\n      if (focusedElement !== root) {\n        const shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root as HTMLElement, focusedElement) : undefined;\n      }\n    }\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const {\n      onActiveElementChanged,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotAllowFocusEventToPropagate,\n      stopFocusPropagation,\n      // eslint-disable-next-line deprecation/deprecation\n      onFocusNotification,\n      onFocus,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n    const isImmediateDescendant = this._isImmediateDescendantOfZone(ev.target as HTMLElement);\n    let newActiveElement: HTMLElement | null | undefined;\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        this._root.current &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n          newActiveElement = null;\n        }\n      }\n    }\n\n    const initialElementFocused = !this._activeElement;\n\n    // If the new active element is a child of this zone and received focus,\n    // update alignment an immediate descendant\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      if (isImmediateDescendant || initialElementFocused) {\n        this._setFocusAlignment(newActiveElement, true, true);\n      }\n\n      this._activeElement = newActiveElement;\n\n      if (initialElementFocused) {\n        this._updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n      ev.stopPropagation();\n    }\n\n    if (onFocus) {\n      onFocus(ev);\n    } else if (onFocusNotification) {\n      onFocusNotification();\n    }\n  };\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  private _setParkedFocus(isParked: boolean): void {\n    const { current: root } = this._root;\n\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  private _onBlur = (): void => {\n    this._setParkedFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this._setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  private _setActiveElement(element: HTMLElement, forceAlignment?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  private _preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>, theme: ITheme): boolean | undefined => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { direction, disabled, isInnerZoneKeystroke, pagingSupportDisabled, shouldEnterInnerZone } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n\n    if (this._getDocument().activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return;\n    }\n\n    if (\n      ((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n      this._isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this._getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return;\n        }\n      } else {\n        return;\n      }\n    } else if (ev.altKey) {\n      return;\n    } else {\n      // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.space:\n          if (this._shouldRaiseClicksOnSpace && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.left:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusLeft(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.right:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusRight(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.up:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusUp()) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.down:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusDown()) {\n              break;\n            }\n          }\n          return;\n        case KeyCodes.pageDown:\n          if (!pagingSupportDisabled && this._moveFocusPaging(true)) {\n            break;\n          }\n          return;\n        case KeyCodes.pageUp:\n          if (!pagingSupportDisabled && this._moveFocusPaging(false)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.tab:\n          if (\n            // eslint-disable-next-line deprecation/deprecation\n            this.props.allowTabKey ||\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this._isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();\n            } else {\n              const tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this._moveFocusLeft(theme) : this._moveFocusRight(theme);\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n              this._activeElement = null;\n            }\n          }\n          return;\n\n        case KeyCodes.home:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.end:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, true))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.enter:\n          if (this._shouldRaiseClicksOnEnter && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        default:\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  private _tryInvokeClickForFocusable(targetElement: HTMLElement, ev?: React.KeyboardEvent<HTMLElement>): boolean {\n    let target = targetElement;\n    if (target === this._root.current) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA' ||\n        target.tagName === 'SUMMARY'\n      ) {\n        return false;\n      }\n\n      if (\n        this._isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  private _getFirstInnerZone(rootElement?: HTMLElement | null): FocusZone | null {\n    rootElement = rootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this._getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  private _moveFocus(\n    isForward: boolean,\n    // eslint-disable-next-line deprecation/deprecation\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (\n        isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element)\n      ) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          // eslint-disable-next-line deprecation/deprecation\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      } else {\n        return this.focusElement(\n          getPreviousElement(\n            this._root.current,\n            this._root.current.lastElementChild as HTMLElement,\n            true,\n            true,\n            true,\n          ) as HTMLElement,\n        );\n      }\n    }\n\n    return changedFocus;\n  }\n\n  private _moveFocusDown(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      // eslint-disable-next-line deprecation/deprecation\n      this._moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusUp(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      // eslint-disable-next-line deprecation/deprecation\n      this._moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusLeft(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        getRTL(theme),\n        // eslint-disable-next-line deprecation/deprecation\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusRight(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        !getRTL(theme),\n        // eslint-disable-next-line deprecation/deprecation\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _getHorizontalDistanceFromCenter = (\n    isForward: boolean,\n    // eslint-disable-next-line deprecation/deprecation\n    activeRect: ClientRect,\n    // eslint-disable-next-line deprecation/deprecation\n    targetRect: ClientRect,\n  ): number => {\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  private _moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this._setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  private _setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean): void {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  private _isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this._getOwnerZone(element) === this._root.current;\n  }\n\n  private _getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return parentElement;\n  }\n\n  private _updateTabIndexes(element?: HTMLElement): void {\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this._updateTabIndexes(child);\n    }\n  }\n\n  private _isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  private _isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _shouldInputLoseFocus(element: HTMLInputElement | HTMLTextAreaElement, isForward?: boolean): boolean {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n  private _portalContainsElement(element: HTMLElement): boolean {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  }\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/react-focus', '8.8.31');", "import * as React from 'react';\nimport { hoistMethods, unhoistMethods } from '../../Utilities';\n\nexport class BaseDecorator<TProps, TState> extends React.Component<TProps, TState> {\n  protected _composedComponentInstance: React.Component<TProps, TState>;\n\n  private _hoisted: string[];\n\n  constructor(props: TProps) {\n    super(props);\n    this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);\n  }\n\n  /**\n   * Updates the ref to the component composed by the decorator, which will also take care of hoisting\n   * (and unhoisting as appropriate) methods from said component.\n   *\n   * Pass this method as the argument to the 'ref' property of the composed component.\n   */\n  protected _updateComposedComponentRef(composedComponentInstance: React.Component<TProps, TState>): void {\n    this._composedComponentInstance = composedComponentInstance;\n    if (composedComponentInstance) {\n      this._hoisted = hoistMethods(this, composedComponentInstance);\n    } else if (this._hoisted) {\n      unhoistMethods(this, this._hoisted);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["FocusZoneDirection", "FocusZone", "_a", "React", "BaseDecorator"]
}
