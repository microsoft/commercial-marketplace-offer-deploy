import {
  AnimationClassNames,
  HighContrastSelector,
  Layer,
  ZIndexes,
  focusClear,
  getGlobalClassNames,
  hiddenContentStyle
} from "./chunk-53BTC5C3.js";
import {
  FocusTrapZone
} from "./chunk-B5RA6IMX.js";
import {
  Async,
  KeyCodes,
  Rectangle,
  __assign,
  __extends,
  __rest,
  assign,
  classNamesFunction,
  css,
  divProperties,
  doesElementContainFocus,
  elementContains,
  focusFirstChild,
  getDocument,
  getId,
  getNativeProps,
  getPropsWithDefaults,
  getRTL,
  getScrollbarWidth,
  getWindow,
  hasOverflow,
  initializeComponentRef,
  modalize,
  on,
  portalContainsElement,
  shallowCompare,
  styled,
  useAsync,
  useConst,
  useMergedRefs,
  useOnEvent,
  useTarget,
  useWindow
} from "./chunk-T5LOAC42.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@fluentui/react/lib/common/DirectionalHint.js
var DirectionalHint = {
  /**
   * Appear above the target element, with the left edges of the callout and target aligning.
   */
  topLeftEdge: 0,
  /**
   * Appear above the target element, with the centers of the callout and target aligning.
   */
  topCenter: 1,
  /**
   * Appear above the target element, with the right edges of the callout and target aligning.
   */
  topRightEdge: 2,
  /**
   * Appear above the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  topAutoEdge: 3,
  /**
   * Appear below the target element, with the left edges of the callout and target aligning.
   */
  bottomLeftEdge: 4,
  /**
   * Appear below the target element, with the centers of the callout and target aligning.
   */
  bottomCenter: 5,
  /**
   * Appear below the target element, with the right edges of the callout and target aligning.
   */
  bottomRightEdge: 6,
  /**
   * Appear below the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  bottomAutoEdge: 7,
  /**
   * Appear to the left of the target element, with the top edges of the callout and target aligning.
   */
  leftTopEdge: 8,
  /**
   * Appear to the left of the target element, with the centers of the callout and target aligning.
   */
  leftCenter: 9,
  /**
   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
   */
  leftBottomEdge: 10,
  /**
   * Appear to the right of the target element, with the top edges of the callout and target aligning.
   */
  rightTopEdge: 11,
  /**
   * Appear to the right of the target element, with the centers of the callout and target aligning.
   */
  rightCenter: 12,
  /**
   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
   */
  rightBottomEdge: 13
};

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.types.js
var RectangleEdge;
(function(RectangleEdge2) {
  RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
  RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
  RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
  RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function(Position2) {
  Position2[Position2["top"] = 0] = "top";
  Position2[Position2["bottom"] = 1] = "bottom";
  Position2[Position2["start"] = 2] = "start";
  Position2[Position2["end"] = 3] = "end";
})(Position || (Position = {}));

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.js
var _a;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
  return {
    targetEdge,
    alignmentEdge,
    isAuto
  };
}
var DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);
function _isRectangleWithinBounds(rect, boundingRect) {
  if (rect.top < boundingRect.top) {
    return false;
  }
  if (rect.bottom > boundingRect.bottom) {
    return false;
  }
  if (rect.left < boundingRect.left) {
    return false;
  }
  if (rect.right > boundingRect.right) {
    return false;
  }
  return true;
}
function _getOutOfBoundsEdges(rect, boundingRect) {
  var outOfBounds = [];
  if (rect.top < boundingRect.top) {
    outOfBounds.push(RectangleEdge.top);
  }
  if (rect.bottom > boundingRect.bottom) {
    outOfBounds.push(RectangleEdge.bottom);
  }
  if (rect.left < boundingRect.left) {
    outOfBounds.push(RectangleEdge.left);
  }
  if (rect.right > boundingRect.right) {
    outOfBounds.push(RectangleEdge.right);
  }
  return outOfBounds;
}
function _getEdgeValue(rect, edge) {
  return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
  rect[RectangleEdge[edge]] = value;
  return rect;
}
function _getCenterValue(rect, edge) {
  var edges = _getFlankingEdges(edge);
  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
function _getRelativeEdgeValue(edge, value) {
  if (edge > 0) {
    return value;
  } else {
    return value * -1;
  }
}
function _getRelativeRectEdgeValue(edge, rect) {
  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
  return _getRelativeEdgeValue(edge, edgeDifference);
}
function _moveEdge(rect, edge, newValue, maintainSize) {
  if (maintainSize === void 0) {
    maintainSize = true;
  }
  var difference = _getEdgeValue(rect, edge) - newValue;
  var returnRect = _setEdgeValue(rect, edge, newValue);
  if (maintainSize) {
    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
  }
  return returnRect;
}
function _alignEdges(rect, target, edge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
function _alignOppositeEdges(rect, target, targetEdge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var oppositeEdge = targetEdge * -1;
  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
function _isEdgeInBounds(rect, bounds, edge) {
  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
function _getOutOfBoundsDegree(rect, bounds) {
  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
  var total = 0;
  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
    var edge = breakingEdges_1[_i];
    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
  }
  return total;
}
function _flipToFit(rect, target, bounding, positionData, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var directions = [
    RectangleEdge.left,
    RectangleEdge.right,
    RectangleEdge.bottom,
    RectangleEdge.top
  ];
  if (getRTL()) {
    directions[0] *= -1;
    directions[1] *= -1;
  }
  var currentEstimate = rect;
  var currentEdge = positionData.targetEdge;
  var currentAlignment = positionData.alignmentEdge;
  var oobDegree;
  var bestEdge = currentEdge;
  var bestAlignment = currentAlignment;
  for (var i = 0; i < 4; i++) {
    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
      if (!oobDegree || currentOOBDegree < oobDegree) {
        oobDegree = currentOOBDegree;
        bestEdge = currentEdge;
        bestAlignment = currentAlignment;
      }
      directions.splice(directions.indexOf(currentEdge), 1);
      if (directions.length > 0) {
        if (directions.indexOf(currentEdge * -1) > -1) {
          currentEdge = currentEdge * -1;
        } else {
          currentAlignment = currentEdge;
          currentEdge = directions.slice(-1)[0];
        }
        currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
      }
    } else {
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment
      };
    }
  }
  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
  return {
    elementRectangle: currentEstimate,
    targetEdge: bestEdge,
    alignmentEdge: bestAlignment
  };
}
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
  var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
  var oppositeEdge = alignmentEdge * -1;
  var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
  return {
    elementRectangle: newEstimate,
    targetEdge,
    alignmentEdge: oppositeEdge
  };
}
function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
  var elementEstimate = {
    elementRectangle: element,
    targetEdge: positionData.targetEdge,
    alignmentEdge
  };
  if (!directionalHintFixed && !coverTarget) {
    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
  }
  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
  if (outOfBounds.length > 0) {
    if (alignTargetEdge) {
      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
          return flippedElementEstimate;
        } else {
          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
        }
      } else {
        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
      }
    } else {
      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
    }
  }
  return elementEstimate;
}
function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
    var direction = outOfBoundsEdges_1[_i];
    var edgeAttempt = void 0;
    if (preserveEdge && preserveEdge === direction * -1) {
      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
      elementEstimate.forcedInBounds = true;
    } else {
      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
      if (!inBounds) {
        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
        elementEstimate.forcedInBounds = true;
      }
    }
    elementEstimate.elementRectangle = edgeAttempt;
  }
  return elementEstimate;
}
function _centerEdgeToPoint(rect, edge, point) {
  var positiveEdge = _getFlankingEdges(edge).positiveEdge;
  var elementMiddle = _getCenterValue(rect, edge);
  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
  var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
  if (!alignmentEdge) {
    var targetMiddlePoint = _getCenterValue(target, targetEdge);
    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
  } else {
    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
  }
  return estimatedElementPosition;
}
function _getFlankingEdges(edge) {
  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
    return {
      positiveEdge: RectangleEdge.left,
      negativeEdge: RectangleEdge.right
    };
  } else {
    return {
      positiveEdge: RectangleEdge.top,
      negativeEdge: RectangleEdge.bottom
    };
  }
}
function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
    return returnEdge * -1;
  }
  return returnEdge;
}
function _isEdgeOnBounds(elementRectangle, edge, bounds) {
  return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
}
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
  var returnValue = {};
  var hostRect = _getRectangleFromElement(hostElement);
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
  }
  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
  if (forceWithinBounds) {
    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
  }
  return returnValue;
}
function _calculateActualBeakWidthInPixels(beakWidth) {
  return Math.sqrt(beakWidth * beakWidth * 2);
}
function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
  if (directionalHint === void 0) {
    directionalHint = DirectionalHint.bottomAutoEdge;
  }
  if (previousPositions) {
    return {
      alignmentEdge: previousPositions.alignmentEdge,
      isAuto: previousPositions.isAuto,
      targetEdge: previousPositions.targetEdge
    };
  }
  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);
  if (getRTL()) {
    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
    }
    return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
  }
  return positionInformation;
}
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
  if (positionData.isAuto) {
    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
  }
  positionData.alignTargetEdge = alignTargetEdge;
  return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
  var targetCenter = _getCenterValue(target, targetEdge);
  var boundingCenter = _getCenterValue(boundingRect, targetEdge);
  var _a3 = _getFlankingEdges(targetEdge), positiveEdge = _a3.positiveEdge, negativeEdge = _a3.negativeEdge;
  if (targetCenter <= boundingCenter) {
    return positiveEdge;
  } else {
    return negativeEdge;
  }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
    return {
      elementRectangle: estimatedElementPosition,
      targetEdge: positionData.targetEdge,
      alignmentEdge: positionData.alignmentEdge
    };
  } else {
    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
  }
}
function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
  var targetEdge = elementPosition.targetEdge * -1;
  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
  var returnValue = {};
  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
  return {
    elementPosition: __assign({}, returnValue),
    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
    targetEdge,
    hideBeak: !showBeak
  };
}
function _positionBeak(beakWidth, elementPosition) {
  var target = elementPosition.targetRectangle;
  var _a3 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a3.positiveEdge, negativeEdge = _a3.negativeEdge;
  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
  }
  return beakPosition;
}
function _getRectangleFromElement(element) {
  var clientRect = element.getBoundingClientRect();
  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
  var targetRectangle;
  if (target) {
    if (!!target.preventDefault) {
      var ev = target;
      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
    } else if (!!target.getBoundingClientRect) {
      targetRectangle = _getRectangleFromElement(target);
    } else {
      var rectOrPoint = target;
      var left = rectOrPoint.left || rectOrPoint.x;
      var top_1 = rectOrPoint.top || rectOrPoint.y;
      var right = rectOrPoint.right || left;
      var bottom = rectOrPoint.bottom || top_1;
      targetRectangle = new Rectangle(left, right, top_1, bottom);
    }
    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
        var direction = outOfBounds_1[_i];
        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
      }
    }
  } else {
    targetRectangle = new Rectangle(0, 0, 0, 0);
  }
  return targetRectangle;
}
function _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {
  var maxHeight = 0;
  var directionalHint = DirectionalDictionary[targetEdge];
  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;
  if (target === RectangleEdge.top) {
    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;
  } else if (target === RectangleEdge.bottom) {
    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;
  } else {
    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;
  }
  return maxHeight > 0 ? maxHeight : bounds.height;
}
function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
  var gap = props.gapSpace ? props.gapSpace : 0;
  var targetRect = _getTargetRect(boundingRect, props.target);
  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
  return __assign(__assign({}, positionedElement), { targetRectangle: targetRect });
}
function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
  return {
    elementPosition: finalizedElement,
    targetEdge: positionedElement.targetEdge,
    alignmentEdge: positionedElement.alignmentEdge
  };
}
function _positionElement(props, hostElement, elementToPosition, previousPositions) {
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);
  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);
}
function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
  var positionProps = props;
  positionProps.gapSpace = gap;
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
  var beakPositioned = _positionBeak(beakWidth, positionedElement);
  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
}
function _positionCard(props, hostElement, callout, previousPositions) {
  return _positionCallout(props, hostElement, callout, previousPositions, true);
}
function positionElement(props, hostElement, elementToPosition, previousPositions) {
  return _positionElement(props, hostElement, elementToPosition, previousPositions);
}
function positionCallout(props, hostElement, elementToPosition, previousPositions) {
  return _positionCallout(props, hostElement, elementToPosition, previousPositions);
}
function positionCard(props, hostElement, elementToPosition, previousPositions) {
  return _positionCard(props, hostElement, elementToPosition, previousPositions);
}
function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget) {
  if (gapSpace === void 0) {
    gapSpace = 0;
  }
  var mouseTarget = target;
  var elementTarget = target;
  var rectOrPointTarget = target;
  var targetRect;
  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var left = rectOrPointTarget.left || rectOrPointTarget.x;
  var top = rectOrPointTarget.top || rectOrPointTarget.y;
  var right = rectOrPointTarget.right || left;
  var bottom = rectOrPointTarget.bottom || top;
  if (!!mouseTarget.stopPropagation) {
    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
  } else if (left !== void 0 && top !== void 0) {
    targetRect = new Rectangle(left, right, top, bottom);
  } else {
    targetRect = _getRectangleFromElement(elementTarget);
  }
  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);
}
function getOppositeEdge(edge) {
  return edge * -1;
}
function _getBoundsFromTargetWindow(target, targetWindow) {
  var segments = void 0;
  if (targetWindow.getWindowSegments) {
    segments = targetWindow.getWindowSegments();
  }
  if (segments === void 0 || segments.length <= 1) {
    return {
      top: 0,
      left: 0,
      right: targetWindow.innerWidth,
      bottom: targetWindow.innerHeight,
      width: targetWindow.innerWidth,
      height: targetWindow.innerHeight
    };
  }
  var x = 0;
  var y = 0;
  if (target !== null && !!target.getBoundingClientRect) {
    var clientRect = target.getBoundingClientRect();
    x = (clientRect.left + clientRect.right) / 2;
    y = (clientRect.top + clientRect.bottom) / 2;
  } else if (target !== null) {
    x = target.left || target.x;
    y = target.top || target.y;
  }
  var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
      bounds = {
        top: segment.top,
        left: segment.left,
        right: segment.right,
        bottom: segment.bottom,
        width: segment.width,
        height: segment.height
      };
    }
  }
  return bounds;
}
function getBoundsFromTargetWindow(target, targetWindow) {
  return _getBoundsFromTargetWindow(target, targetWindow);
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
var React = __toESM(require_react());
function useScrollbarAsync(props, root) {
  var async = useAsync();
  var _a3 = React.useState(false), needsVerticalScrollBarState = _a3[0], setNeedsVerticalScrollBar = _a3[1];
  React.useEffect(function() {
    async.requestAnimationFrame(function() {
      var _a4;
      if (props.style && props.style.overflowY) {
        return;
      }
      var needsVerticalScrollBar = false;
      if (root && root.current && ((_a4 = root.current) === null || _a4 === void 0 ? void 0 : _a4.firstElementChild)) {
        var rootHeight = root.current.clientHeight;
        var firstChildHeight = root.current.firstElementChild.clientHeight;
        if (rootHeight > 0 && firstChildHeight > rootHeight) {
          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
        }
      }
      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
        setNeedsVerticalScrollBar(needsVerticalScrollBar);
      }
    });
    return function() {
      return async.dispose();
    };
  });
  return needsVerticalScrollBarState;
}
function defaultFocusRestorer(options) {
  var originalElement = options.originalElement, containsFocus = options.containsFocus;
  if (originalElement && containsFocus && originalElement !== getWindow()) {
    setTimeout(function() {
      var _a3;
      (_a3 = originalElement.focus) === null || _a3 === void 0 ? void 0 : _a3.call(originalElement);
    }, 0);
  }
}
function useRestoreFocus(props, root) {
  var _a3 = props.onRestoreFocus, onRestoreFocus = _a3 === void 0 ? defaultFocusRestorer : _a3;
  var originalFocusedElement = React.useRef();
  var containsFocus = React.useRef(false);
  React.useEffect(function() {
    originalFocusedElement.current = getDocument().activeElement;
    if (doesElementContainFocus(root.current)) {
      containsFocus.current = true;
    }
    return function() {
      var _a4;
      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
        originalElement: originalFocusedElement.current,
        containsFocus: containsFocus.current,
        documentContainsFocus: ((_a4 = getDocument()) === null || _a4 === void 0 ? void 0 : _a4.hasFocus()) || false
      });
      originalFocusedElement.current = void 0;
    };
  }, []);
  useOnEvent(root, "focus", React.useCallback(function() {
    containsFocus.current = true;
  }, []), true);
  useOnEvent(root, "blur", React.useCallback(function(ev) {
    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {
      containsFocus.current = false;
    }
  }, []), true);
}
function useHideSiblingNodes(props, root) {
  var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
  React.useEffect(function() {
    if (!(shouldHideSiblings && root.current)) {
      return;
    }
    var unmodalize = modalize(root.current);
    return unmodalize;
  }, [root, shouldHideSiblings]);
}
var Popup = React.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
  var root = React.useRef();
  var mergedRootRef = useMergedRefs(root, forwardedRef);
  useHideSiblingNodes(props, root);
  useRestoreFocus(props, root);
  var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
  var needsVerticalScrollBar = useScrollbarAsync(props, root);
  var onKeyDown = React.useCallback(function(ev) {
    switch (ev.which) {
      case KeyCodes.escape:
        if (onDismiss) {
          onDismiss(ev);
          ev.preventDefault();
          ev.stopPropagation();
        }
        break;
    }
  }, [onDismiss]);
  var win = useWindow();
  useOnEvent(win, "keydown", onKeyDown);
  return React.createElement("div", __assign({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style) }), children);
});
Popup.displayName = "Popup";

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var React2 = __toESM(require_react());
var _a2;
var COMPONENT_NAME = "CalloutContentBase";
var ANIMATIONS = (_a2 = {}, _a2[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a2[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a2[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a2[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a2);
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
var OFF_SCREEN_STYLE = {
  opacity: 0,
  filter: "opacity(0)",
  pointerEvents: "none"
};
var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
var DEFAULT_PROPS = {
  preventDismissOnLostFocus: false,
  preventDismissOnScroll: false,
  preventDismissOnResize: false,
  isBeakVisible: true,
  beakWidth: 16,
  gapSpace: 0,
  minPagePadding: 8,
  directionalHint: DirectionalHint.bottomAutoEdge
};
var getClassNames = classNamesFunction({
  disableCaching: true
  // disabling caching because stylesProp.position mutates often
});
function useBounds(_a3, targetRef, targetWindow) {
  var bounds = _a3.bounds, _b = _a3.minPagePadding, minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b, target = _a3.target;
  var _c = React2.useState(false), targetWindowResized = _c[0], setTargetWindowResized = _c[1];
  var cachedBounds = React2.useRef();
  var getBounds = React2.useCallback(function() {
    if (!cachedBounds.current || targetWindowResized) {
      var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
      if (!currentBounds && targetWindow) {
        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
        currentBounds = {
          top: currentBounds.top + minPagePadding,
          left: currentBounds.left + minPagePadding,
          right: currentBounds.right - minPagePadding,
          bottom: currentBounds.bottom - minPagePadding,
          width: currentBounds.width - minPagePadding * 2,
          height: currentBounds.height - minPagePadding * 2
        };
      }
      cachedBounds.current = currentBounds;
      targetWindowResized && setTargetWindowResized(false);
    }
    return cachedBounds.current;
  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
  var async = useAsync();
  useOnEvent(targetWindow, "resize", async.debounce(function() {
    setTargetWindowResized(true);
  }, 500, { leading: true }));
  return getBounds;
}
function useMaxHeight(_a3, getBounds, positions) {
  var _b;
  var calloutMaxHeight = _a3.calloutMaxHeight, finalHeight = _a3.finalHeight, directionalHint = _a3.directionalHint, directionalHintFixed = _a3.directionalHintFixed, hidden = _a3.hidden;
  var _c = React2.useState(), maxHeight = _c[0], setMaxHeight = _c[1];
  var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {}, top = _d.top, bottom = _d.bottom;
  React2.useEffect(function() {
    var _a4;
    var _b2 = (_a4 = getBounds()) !== null && _a4 !== void 0 ? _a4 : {}, topBounds = _b2.top, bottomBounds = _b2.bottom;
    var calculatedHeight;
    if (typeof top === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - top;
    } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - topBounds - bottom;
    }
    if (!calloutMaxHeight && !hidden || calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight) {
      setMaxHeight(calculatedHeight);
    } else if (calloutMaxHeight) {
      setMaxHeight(calloutMaxHeight);
    } else {
      setMaxHeight(void 0);
    }
  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
  return maxHeight;
}
function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
  var _a3 = React2.useState(), positions = _a3[0], setPositions = _a3[1];
  var positionAttempts = React2.useRef(0);
  var previousTarget = React2.useRef();
  var async = useAsync();
  var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
  React2.useEffect(function() {
    if (!hidden) {
      var timerId_1 = async.requestAnimationFrame(function() {
        var _a4, _b;
        if (hostElement.current && calloutElement) {
          var currentProps = __assign(__assign({}, props), { target: targetRef.current, bounds: getBounds() });
          var dupeCalloutElement = calloutElement.cloneNode(true);
          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "".concat(calloutMaxHeight) : "";
          dupeCalloutElement.style.visibility = "hidden";
          (_a4 = calloutElement.parentElement) === null || _a4 === void 0 ? void 0 : _a4.appendChild(dupeCalloutElement);
          var previousPositions = previousTarget.current === target ? positions : void 0;
          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
          (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement);
          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
            positionAttempts.current++;
            setPositions(newPositions);
          } else if (positionAttempts.current > 0) {
            positionAttempts.current = 0;
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
          }
        }
      }, calloutElement);
      previousTarget.current = target;
      return function() {
        async.cancelAnimationFrame(timerId_1);
        previousTarget.current = void 0;
      };
    } else {
      setPositions(void 0);
      positionAttempts.current = 0;
    }
  }, [
    hidden,
    directionalHint,
    async,
    calloutElement,
    calloutMaxHeight,
    hostElement,
    targetRef,
    finalHeight,
    getBounds,
    onPositioned,
    positions,
    props,
    target
  ]);
  return positions;
}
function useAutoFocus(_a3, positions, calloutElement) {
  var hidden = _a3.hidden, setInitialFocus = _a3.setInitialFocus;
  var async = useAsync();
  var hasPositions = !!positions;
  React2.useEffect(function() {
    if (!hidden && setInitialFocus && hasPositions && calloutElement) {
      var timerId_2 = async.requestAnimationFrame(function() {
        return focusFirstChild(calloutElement);
      }, calloutElement);
      return function() {
        return async.cancelAnimationFrame(timerId_2);
      };
    }
  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
}
function useDismissHandlers(_a3, positions, hostElement, targetRef, targetWindow) {
  var hidden = _a3.hidden, onDismiss = _a3.onDismiss, preventDismissOnScroll = _a3.preventDismissOnScroll, preventDismissOnResize = _a3.preventDismissOnResize, preventDismissOnLostFocus = _a3.preventDismissOnLostFocus, dismissOnTargetClick = _a3.dismissOnTargetClick, shouldDismissOnWindowFocus = _a3.shouldDismissOnWindowFocus, preventDismissOnEvent = _a3.preventDismissOnEvent;
  var isMouseDownOnPopup = React2.useRef(false);
  var async = useAsync();
  var mouseDownHandlers = useConst([
    function() {
      isMouseDownOnPopup.current = true;
    },
    function() {
      isMouseDownOnPopup.current = false;
    }
  ]);
  var positionsExists = !!positions;
  React2.useEffect(function() {
    var dismissOnScroll = function(ev) {
      if (positionsExists && !preventDismissOnScroll) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnResize = function(ev) {
      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnLostFocus = function(ev) {
      if (!preventDismissOnLostFocus) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnClickOrScroll = function(ev) {
      var eventPaths = ev.composedPath ? ev.composedPath() : [];
      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
        isMouseDownOnPopup.current = false;
        return;
      }
      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {
        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
          return;
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnTargetWindowBlur = function(ev) {
      if (!shouldDismissOnWindowFocus) {
        return;
      }
      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var disposablesPromise = new Promise(function(resolve) {
      async.setTimeout(function() {
        if (!hidden && targetWindow) {
          var disposables_1 = [
            on(targetWindow, "scroll", dismissOnScroll, true),
            on(targetWindow, "resize", dismissOnResize, true),
            on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
            on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
            on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
          ];
          resolve(function() {
            disposables_1.forEach(function(dispose) {
              return dispose();
            });
          });
        }
      }, 0);
    });
    return function() {
      disposablesPromise.then(function(dispose) {
        return dispose();
      });
    };
  }, [
    hidden,
    async,
    hostElement,
    targetRef,
    targetWindow,
    onDismiss,
    shouldDismissOnWindowFocus,
    dismissOnTargetClick,
    preventDismissOnLostFocus,
    preventDismissOnResize,
    preventDismissOnScroll,
    positionsExists,
    preventDismissOnEvent
  ]);
  return mouseDownHandlers;
}
var CalloutContentBase = React2.memo(React2.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var styles = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a3 = props.hideOverflow, hideOverflow = _a3 === void 0 ? !!finalHeight : _a3, backgroundColor = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b = props.shouldRestoreFocus, shouldRestoreFocus = _b === void 0 ? true : _b, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted, popupProps = props.popupProps;
  var hostElement = React2.useRef(null);
  var _c = React2.useState(null), calloutElement = _c[0], setCalloutElement = _c[1];
  var calloutCallback = React2.useCallback(function(calloutEl) {
    setCalloutElement(calloutEl);
  }, []);
  var rootRef = useMergedRefs(hostElement, forwardedRef);
  var _d = useTarget(props.target, {
    current: calloutElement
  }), targetRef = _d[0], targetWindow = _d[1];
  var getBounds = useBounds(props, targetRef, targetWindow);
  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
  var maxHeight = useMaxHeight(props, getBounds, positions);
  var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e[0], mouseUpOnPopup = _e[1];
  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
  if (isForcedInBounds) {
    cssPositions.bottom = void 0;
  }
  useAutoFocus(props, positions, calloutElement);
  React2.useEffect(function() {
    if (!hidden) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
    }
  }, [hidden]);
  if (!targetWindow) {
    return null;
  }
  var overflowYHidden = hideOverflow;
  var beakVisible = isBeakVisible && !!target;
  var classNames = getClassNames(styles, {
    theme: props.theme,
    className,
    overflowYHidden,
    calloutWidth,
    positions,
    beakWidth,
    backgroundColor,
    calloutMaxWidth,
    calloutMinWidth,
    doNotLayer
  });
  var overflowStyle = __assign(__assign({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style), overflowYHidden && { overflowY: "hidden" });
  var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
  return React2.createElement(
    "div",
    { ref: rootRef, className: classNames.container, style: visibilityStyle },
    React2.createElement(
      "div",
      __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
        className: css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
        style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,
        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        tabIndex: -1,
        ref: calloutCallback
      }),
      beakVisible && React2.createElement("div", { className: classNames.beak, style: getBeakPosition(positions) }),
      beakVisible && React2.createElement("div", { className: classNames.beakCurtain }),
      React2.createElement(
        Popup,
        __assign({
          // don't use getNativeElementProps for role and roledescription because it will also
          // pass through data-* props (resulting in them being used in two places)
          role: props.role,
          "aria-roledescription": props["aria-roledescription"],
          ariaDescribedBy,
          ariaLabel,
          ariaLabelledBy,
          className: classNames.calloutMain,
          onDismiss: props.onDismiss,
          onMouseDown: mouseDownOnPopup,
          onMouseUp: mouseUpOnPopup,
          onRestoreFocus: props.onRestoreFocus,
          onScroll,
          shouldRestoreFocus,
          style: overflowStyle
        }, popupProps),
        children
      )
    )
  );
}), function(previousProps, nextProps) {
  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
    return true;
  }
  return shallowCompare(previousProps, nextProps);
});
function getBeakPosition(positions) {
  var _a3, _b;
  var beakPositionStyle = __assign(__assign({}, (_a3 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a3 === void 0 ? void 0 : _a3.elementPosition), { display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? "none" : void 0 });
  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
  }
  return beakPositionStyle;
}
function arePositionsEqual(prevElementPositions, newElementPosition) {
  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
}
function comparePositions(prevElementPositions, newElementPositions) {
  for (var key in newElementPositions) {
    if (newElementPositions.hasOwnProperty(key)) {
      var oldPositionEdge = prevElementPositions[key];
      var newPositionEdge = newElementPositions[key];
      if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}
CalloutContentBase.displayName = COMPONENT_NAME;

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.styles.js
function getBeakStyle(beakWidth) {
  return {
    height: beakWidth,
    width: beakWidth
  };
}
var GlobalClassNames = {
  container: "ms-Callout-container",
  root: "ms-Callout",
  beak: "ms-Callout-beak",
  beakCurtain: "ms-Callout-beakCurtain",
  calloutMain: "ms-Callout-main"
};
var getStyles = function(props) {
  var _a3;
  var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
  var classNames = getGlobalClassNames(GlobalClassNames, theme);
  var semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    container: [
      classNames.container,
      {
        position: "relative"
      }
    ],
    root: [
      classNames.root,
      theme.fonts.medium,
      {
        position: "absolute",
        display: "flex",
        zIndex: doNotLayer ? ZIndexes.Layer : void 0,
        boxSizing: "border-box",
        borderRadius: effects.roundedCorner2,
        boxShadow: effects.elevation16,
        selectors: (_a3 = {}, _a3[HighContrastSelector] = {
          borderWidth: 1,
          borderStyle: "solid",
          borderColor: "WindowText"
        }, _a3)
      },
      focusClear(),
      className,
      !!calloutWidth && { width: calloutWidth },
      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
      !!calloutMinWidth && { minWidth: calloutMinWidth }
    ],
    beak: [
      classNames.beak,
      {
        position: "absolute",
        backgroundColor: semanticColors.menuBackground,
        boxShadow: "inherit",
        border: "inherit",
        boxSizing: "border-box",
        transform: "rotate(45deg)"
      },
      getBeakStyle(beakWidth),
      backgroundColor && {
        backgroundColor
      }
    ],
    beakCurtain: [
      classNames.beakCurtain,
      {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundColor: semanticColors.menuBackground,
        borderRadius: effects.roundedCorner2
      }
    ],
    calloutMain: [
      classNames.calloutMain,
      {
        backgroundColor: semanticColors.menuBackground,
        overflowX: "hidden",
        overflowY: "auto",
        position: "relative",
        width: "100%",
        borderRadius: effects.roundedCorner2
      },
      overflowYHidden && {
        overflowY: "hidden"
      },
      backgroundColor && {
        backgroundColor
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.js
var CalloutContent = styled(CalloutContentBase, getStyles, void 0, {
  scope: "CalloutContent"
});

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var React3 = __toESM(require_react());
var Callout = React3.forwardRef(function(_a3, forwardedRef) {
  var layerProps = _a3.layerProps, doNotLayer = _a3.doNotLayer, rest = __rest(_a3, ["layerProps", "doNotLayer"]);
  var content = React3.createElement(CalloutContent, __assign({}, rest, { doNotLayer, ref: forwardedRef }));
  return doNotLayer ? content : React3.createElement(Layer, __assign({}, layerProps), content);
});
Callout.displayName = "Callout";

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var React4 = __toESM(require_react());
var FocusTrapCallout = function(props) {
  return React4.createElement(
    Callout,
    __assign({}, props),
    React4.createElement(FocusTrapZone, __assign({ disabled: props.hidden }, props.focusTrapProps), props.children)
  );
};

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.base.js
var React5 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var TooltipBase = (
  /** @class */
  function(_super) {
    __extends(TooltipBase2, _super);
    function TooltipBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._onRenderContent = function(props) {
        if (typeof props.content === "string") {
          return React5.createElement("p", { className: _this._classNames.subText }, props.content);
        } else {
          return React5.createElement("div", { className: _this._classNames.subText }, props.content);
        }
      };
      return _this;
    }
    TooltipBase2.prototype.render = function() {
      var _a3 = this.props, className = _a3.className, calloutProps = _a3.calloutProps, directionalHint = _a3.directionalHint, directionalHintForRTL = _a3.directionalHintForRTL, styles = _a3.styles, id = _a3.id, maxWidth = _a3.maxWidth, _b = _a3.onRenderContent, onRenderContent = _b === void 0 ? this._onRenderContent : _b, targetElement = _a3.targetElement, theme = _a3.theme;
      this._classNames = getClassNames2(styles, {
        theme,
        className: className || calloutProps && calloutProps.className,
        beakWidth: calloutProps && calloutProps.isBeakVisible ? calloutProps.beakWidth : 0,
        gapSpace: calloutProps && calloutProps.gapSpace,
        maxWidth
      });
      return React5.createElement(
        Callout,
        __assign({ target: targetElement, directionalHint, directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ["id"]), { className: this._classNames.root }),
        React5.createElement("div", { className: this._classNames.content, id, onFocus: this.props.onFocus, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))
      );
    };
    TooltipBase2.defaultProps = {
      directionalHint: DirectionalHint.topCenter,
      maxWidth: "364px",
      calloutProps: {
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false
      }
    };
    return TooltipBase2;
  }(React5.Component)
);

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.styles.js
var getStyles2 = function(props) {
  var className = props.className, _a3 = props.beakWidth, beakWidth = _a3 === void 0 ? 16 : _a3, _b = props.gapSpace, gapSpace = _b === void 0 ? 0 : _b, maxWidth = props.maxWidth, theme = props.theme;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
  var tooltipGapSpace = -(Math.sqrt(beakWidth * beakWidth / 2) + gapSpace) + 1 / window.devicePixelRatio;
  return {
    root: [
      "ms-Tooltip",
      theme.fonts.medium,
      AnimationClassNames.fadeIn200,
      {
        background: semanticColors.menuBackground,
        boxShadow: effects.elevation8,
        padding: "8px",
        maxWidth,
        selectors: {
          ":after": {
            content: "''",
            position: "absolute",
            bottom: tooltipGapSpace,
            left: tooltipGapSpace,
            right: tooltipGapSpace,
            top: tooltipGapSpace,
            zIndex: 0
          }
        }
      },
      className
    ],
    content: [
      "ms-Tooltip-content",
      fonts.small,
      {
        position: "relative",
        zIndex: 1,
        color: semanticColors.menuItemText,
        wordWrap: "break-word",
        overflowWrap: "break-word",
        overflow: "hidden"
      }
    ],
    subText: [
      "ms-Tooltip-subtext",
      {
        // Using inherit here to avoid unintentional global overrides of the <p> tag.
        fontSize: "inherit",
        fontWeight: "inherit",
        color: "inherit",
        margin: 0
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.js
var Tooltip = styled(TooltipBase, getStyles2, void 0, {
  scope: "Tooltip"
});

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.types.js
var TooltipDelay;
(function(TooltipDelay2) {
  TooltipDelay2[TooltipDelay2["zero"] = 0] = "zero";
  TooltipDelay2[TooltipDelay2["medium"] = 1] = "medium";
  TooltipDelay2[TooltipDelay2["long"] = 2] = "long";
})(TooltipDelay || (TooltipDelay = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.types.js
var TooltipOverflowMode;
(function(TooltipOverflowMode2) {
  TooltipOverflowMode2[TooltipOverflowMode2["Parent"] = 0] = "Parent";
  TooltipOverflowMode2[TooltipOverflowMode2["Self"] = 1] = "Self";
})(TooltipOverflowMode || (TooltipOverflowMode = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.base.js
var React6 = __toESM(require_react());
var getClassNames3 = classNamesFunction();
var TooltipHostBase = (
  /** @class */
  function(_super) {
    __extends(TooltipHostBase2, _super);
    function TooltipHostBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._tooltipHost = React6.createRef();
      _this._defaultTooltipId = getId("tooltip");
      _this.show = function() {
        _this._toggleTooltip(true);
      };
      _this.dismiss = function() {
        _this._hideTooltip();
      };
      _this._getTargetElement = function() {
        if (!_this._tooltipHost.current) {
          return void 0;
        }
        var overflowMode = _this.props.overflowMode;
        if (overflowMode !== void 0) {
          switch (overflowMode) {
            case TooltipOverflowMode.Parent:
              return _this._tooltipHost.current.parentElement;
            case TooltipOverflowMode.Self:
              return _this._tooltipHost.current;
          }
        }
        return _this._tooltipHost.current;
      };
      _this._onTooltipFocus = function(ev) {
        if (_this._ignoreNextFocusEvent) {
          _this._ignoreNextFocusEvent = false;
          return;
        }
        _this._onTooltipMouseEnter(ev);
      };
      _this._onTooltipContentFocus = function(ev) {
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
      };
      _this._onTooltipBlur = function(ev) {
        _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;
        _this._dismissTimerId = _this._async.setTimeout(function() {
          _this._hideTooltip();
        }, 0);
      };
      _this._onTooltipMouseEnter = function(ev) {
        var _a3 = _this.props, overflowMode = _a3.overflowMode, delay = _a3.delay;
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        if (overflowMode !== void 0) {
          var overflowElement = _this._getTargetElement();
          if (overflowElement && !hasOverflow(overflowElement)) {
            return;
          }
        }
        if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {
          return;
        }
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (delay !== TooltipDelay.zero) {
          var delayTime = _this._getDelayTime(delay);
          _this._openTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(true);
          }, delayTime);
        } else {
          _this._toggleTooltip(true);
        }
      };
      _this._onTooltipMouseLeave = function(ev) {
        var closeDelay = _this.props.closeDelay;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (closeDelay) {
          _this._dismissTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(false);
          }, closeDelay);
        } else {
          _this._toggleTooltip(false);
        }
        if (TooltipHostBase2._currentVisibleTooltip === _this) {
          TooltipHostBase2._currentVisibleTooltip = void 0;
        }
      };
      _this._onTooltipKeyDown = function(ev) {
        if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {
          _this._hideTooltip();
          ev.stopPropagation();
        }
      };
      _this._clearDismissTimer = function() {
        _this._async.clearTimeout(_this._dismissTimerId);
      };
      _this._clearOpenTimer = function() {
        _this._async.clearTimeout(_this._openTimerId);
      };
      _this._hideTooltip = function() {
        _this._clearOpenTimer();
        _this._clearDismissTimer();
        _this._toggleTooltip(false);
      };
      _this._toggleTooltip = function(isTooltipVisible) {
        if (_this.state.isTooltipVisible !== isTooltipVisible) {
          _this.setState({ isTooltipVisible }, function() {
            return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);
          });
        }
      };
      _this._getDelayTime = function(delay) {
        switch (delay) {
          case TooltipDelay.medium:
            return 300;
          case TooltipDelay.long:
            return 500;
          default:
            return 0;
        }
      };
      initializeComponentRef(_this);
      _this.state = {
        isAriaPlaceholderRendered: false,
        isTooltipVisible: false
      };
      _this._async = new Async(_this);
      return _this;
    }
    TooltipHostBase2.prototype.render = function() {
      var _a3 = this.props, calloutProps = _a3.calloutProps, children = _a3.children, content = _a3.content, directionalHint = _a3.directionalHint, directionalHintForRTL = _a3.directionalHintForRTL, className = _a3.hostClassName, id = _a3.id, _b = _a3.setAriaDescribedBy, setAriaDescribedBy = _b === void 0 ? true : _b, tooltipProps = _a3.tooltipProps, styles = _a3.styles, theme = _a3.theme;
      this._classNames = getClassNames3(styles, {
        theme,
        className
      });
      var isTooltipVisible = this.state.isTooltipVisible;
      var tooltipId = id || this._defaultTooltipId;
      var tooltipRenderProps = __assign(__assign({ id: "".concat(tooltipId, "--tooltip"), content, targetElement: this._getTargetElement(), directionalHint, directionalHintForRTL, calloutProps: assign({}, calloutProps, {
        onDismiss: this._hideTooltip,
        onFocus: this._onTooltipContentFocus,
        onMouseEnter: this._onTooltipMouseEnter,
        onMouseLeave: this._onTooltipMouseLeave
      }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties, ["id"])), tooltipProps);
      var tooltipContent = (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.onRenderContent) ? tooltipProps.onRenderContent(tooltipRenderProps, function(props) {
        return (props === null || props === void 0 ? void 0 : props.content) ? React6.createElement(React6.Fragment, null, props.content) : null;
      }) : content;
      var showTooltip = isTooltipVisible && !!tooltipContent;
      var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : void 0;
      return React6.createElement(
        "div",
        __assign({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipFocus }, { onBlurCapture: this._onTooltipBlur }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, onKeyDown: this._onTooltipKeyDown, role: "none", "aria-describedby": ariaDescribedBy }),
        children,
        showTooltip && React6.createElement(Tooltip, __assign({}, tooltipRenderProps)),
        React6.createElement("div", { hidden: true, id: tooltipId, style: hiddenContentStyle }, tooltipContent)
      );
    };
    TooltipHostBase2.prototype.componentWillUnmount = function() {
      if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip === this) {
        TooltipHostBase2._currentVisibleTooltip = void 0;
      }
      this._async.dispose();
    };
    TooltipHostBase2.defaultProps = {
      delay: TooltipDelay.medium
    };
    return TooltipHostBase2;
  }(React6.Component)
);

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.styles.js
var GlobalClassNames2 = {
  root: "ms-TooltipHost",
  ariaPlaceholder: "ms-TooltipHost-aria-placeholder"
};
var getStyles3 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames = getGlobalClassNames(GlobalClassNames2, theme);
  return {
    root: [
      classNames.root,
      {
        display: "inline"
      },
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.js
var TooltipHost = styled(TooltipHostBase, getStyles3, void 0, {
  scope: "TooltipHost"
});

export {
  DirectionalHint,
  RectangleEdge,
  Position,
  positionElement,
  positionCallout,
  positionCard,
  getMaxHeight,
  getOppositeEdge,
  getBoundsFromTargetWindow,
  Popup,
  CalloutContentBase,
  CalloutContent,
  Callout,
  FocusTrapCallout,
  TooltipBase,
  Tooltip,
  TooltipDelay,
  TooltipOverflowMode,
  TooltipHostBase,
  TooltipHost
};
//# sourceMappingURL=chunk-KDVNYAWK.js.map
