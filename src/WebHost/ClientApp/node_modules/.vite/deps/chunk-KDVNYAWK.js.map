{
  "version": 3,
  "sources": ["../../@fluentui/react/lib/common/common/DirectionalHint.ts", "../../@fluentui/react/lib/utilities/positioning/utilities/positioning/positioning.types.ts", "../../@fluentui/react/lib/utilities/positioning/utilities/positioning/positioning.ts", "../../@fluentui/react/lib/components/Popup/components/Popup/Popup.tsx", "../../@fluentui/react/lib/components/Callout/components/Callout/CalloutContent.base.tsx", "../../@fluentui/react/lib/components/Callout/components/Callout/CalloutContent.styles.ts", "../../@fluentui/react/lib/components/Callout/components/Callout/CalloutContent.tsx", "../../@fluentui/react/lib/components/Callout/components/Callout/Callout.tsx", "../../@fluentui/react/lib/components/Callout/components/Callout/FocusTrapCallout.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.base.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.styles.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.types.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.types.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.base.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.styles.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.ts"],
  "sourcesContent": ["export const DirectionalHint = {\n  /**\n   * Appear above the target element, with the left edges of the callout and target aligning.\n   */\n  topLeftEdge: 0 as 0,\n\n  /**\n   * Appear above the target element, with the centers of the callout and target aligning.\n   */\n  topCenter: 1 as 1,\n\n  /**\n   * Appear above the target element, with the right edges of the callout and target aligning.\n   */\n  topRightEdge: 2 as 2,\n\n  /**\n   * Appear above the target element, aligning with the target element such that the callout tends toward\n   * the center of the screen.\n   */\n  topAutoEdge: 3 as 3,\n\n  /**\n   * Appear below the target element, with the left edges of the callout and target aligning.\n   */\n  bottomLeftEdge: 4 as 4,\n\n  /**\n   * Appear below the target element, with the centers of the callout and target aligning.\n   */\n  bottomCenter: 5 as 5,\n\n  /**\n   * Appear below the target element, with the right edges of the callout and target aligning.\n   */\n  bottomRightEdge: 6 as 6,\n\n  /**\n   * Appear below the target element, aligning with the target element such that the callout tends toward\n   * the center of the screen.\n   */\n  bottomAutoEdge: 7 as 7,\n\n  /**\n   * Appear to the left of the target element, with the top edges of the callout and target aligning.\n   */\n  leftTopEdge: 8 as 8,\n\n  /**\n   * Appear to the left of the target element, with the centers of the callout and target aligning.\n   */\n  leftCenter: 9 as 9,\n\n  /**\n   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.\n   */\n  leftBottomEdge: 10 as 10,\n\n  /**\n   * Appear to the right of the target element, with the top edges of the callout and target aligning.\n   */\n  rightTopEdge: 11 as 11,\n\n  /**\n   * Appear to the right of the target element, with the centers of the callout and target aligning.\n   */\n  rightCenter: 12 as 12,\n\n  /**\n   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.\n   */\n  rightBottomEdge: 13 as 13,\n};\n\nexport type DirectionalHint = (typeof DirectionalHint)[keyof typeof DirectionalHint];\n", "import { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IRectangle, Point } from '../../Utilities';\n\nexport enum RectangleEdge {\n  top = 1,\n  bottom = -1,\n  left = 2,\n  right = -2,\n}\n\nexport enum Position {\n  top = 0,\n  bottom = 1,\n  start = 2,\n  end = 3,\n}\n\n/**\n * Window with typings for experimental features regarding Dual Screen devices.\n */\nexport interface IWindowWithSegments extends Window {\n  getWindowSegments?: () => DOMRect[];\n}\n\nexport interface IPositionProps {\n  target?: Element | MouseEvent | Point;\n  /** how the element should be positioned */\n  directionalHint?: DirectionalHint;\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n  /** The gap between the callout and the target */\n  gapSpace?: number;\n  /**\n   * The bounding rectangle for which  the contextual menu can appear in.\n   */\n  bounds?: IRectangle;\n  /**\n   * If true the position returned will have the menu element cover the target.\n   * If false then it will position next to the target;\n   */\n  coverTarget?: boolean;\n  /**\n   * If true the position will not change edges in an attempt to fit the rectangle within bounds.\n   * It will still attempt to align it to whatever bounds are given.\n   * @defaultvalue false\n   */\n  directionalHintFixed?: boolean;\n\n  /**\n   * If true the positioning logic will prefer flipping edges over nudging the rectangle to fit within bounds,\n   * thus making sure the element align perfectly with target.\n   */\n  alignTargetEdge?: boolean;\n}\n\nexport interface ICalloutPositionProps extends IPositionProps {\n  /**\n   * The width of the beak.\n   */\n  beakWidth?: number;\n\n  /**\n   * Whether or not the beak is visible\n   */\n  isBeakVisible?: boolean;\n}\n\nexport interface IPositionedData {\n  /**\n   * The new position of the element.\n   */\n  elementPosition: IPosition;\n  /**\n   * The finalized target edge that element is aligning to. For instance RectangleEdge.bottom would mean\n   * that the bottom edge of the target is being aligned to by the RectangleEdge.top of the element\n   * that is being positioned.\n   */\n  targetEdge: RectangleEdge;\n  /**\n   * The finalized alignment edge that the element is aligning too. For instance, RectangleEdge.left means\n   * that the left edge of the target should be in line with the left edge of the element being positioned.\n   */\n  alignmentEdge?: RectangleEdge;\n}\n\nexport interface ICalloutPositionedInfo extends IPositionedData {\n  beakPosition: ICalloutBeakPositionedInfo;\n}\n\nexport interface ICalloutBeakPositionedInfo extends IPositionedData {\n  closestEdge: RectangleEdge;\n  hideBeak?: boolean;\n}\n\n/**\n * Gives the position of some element on the page. Only a pair of vertical and horizontal edges need to be\n * given. So top/left or bottom/left is sufficient.\n * The number given is the distance in pixels from whatever host was given..\n * So bottom: 100 would be 100px up from the bottom of the host while top: 100px from the top.\n */\nexport interface IPosition {\n  top?: number;\n  left?: number;\n  bottom?: number;\n  right?: number;\n  [key: string]: number | undefined;\n}\n\nexport interface IPositionDirectionalHintData {\n  targetEdge: RectangleEdge;\n  alignmentEdge?: RectangleEdge;\n  isAuto?: boolean;\n  alignTargetEdge?: boolean;\n}\n\nexport interface IRelativePositions {\n  calloutPosition: IPosition;\n  beakPosition: { position: IPosition | undefined; display: 'block' };\n  directionalClassName: string;\n  submenuDirection: DirectionalHint;\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type { Point, IPoint } from '../../Utilities';\n", "import { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nimport type { IRectangle, Point } from '../../Utilities';\nimport type {\n  IPositionDirectionalHintData,\n  IPositionedData,\n  ICalloutPositionedInfo,\n  ICalloutBeakPositionedInfo,\n  IPositionProps,\n  ICalloutPositionProps,\n  IWindowWithSegments,\n} from './positioning.types';\n\nfunction _createPositionData(\n  targetEdge: RectangleEdge,\n  alignmentEdge?: RectangleEdge,\n  isAuto?: boolean,\n): IPositionDirectionalHintData {\n  return {\n    targetEdge,\n    alignmentEdge,\n    isAuto,\n  };\n}\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n};\n\n/**\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\n * utilizes them.\n * START Private functions and interfaces\n */\n\nexport interface IElementPosition {\n  elementRectangle: Rectangle;\n  targetEdge: RectangleEdge;\n  alignmentEdge: RectangleEdge | undefined;\n  forcedInBounds?: boolean;\n}\n\nexport interface IElementPositionInfo extends IElementPosition {\n  targetRectangle: Rectangle;\n}\n\ntype PartialIRectangle = Partial<IRectangle>;\n\ninterface IPartialIRectangle extends PartialIRectangle {\n  [key: string]: number | undefined;\n}\n\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n  const outOfBounds: RectangleEdge[] = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\n  return (rect as any)[RectangleEdge[edge]] as number;\n}\n\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\n  (rect as any)[RectangleEdge[edge]] = value;\n  return rect;\n}\n\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\n  const edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number, maintainSize = true): Rectangle {\n  const difference = _getEdgeValue(rect, edge) - newValue;\n  let returnRect = _setEdgeValue(rect, edge, newValue);\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n  return returnRect;\n}\n\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(\n  rect: Rectangle,\n  target: Rectangle,\n  targetEdge: RectangleEdge,\n  gap: number = 0,\n): Rectangle {\n  const oppositeEdge = targetEdge * -1;\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect: Rectangle, bounds: Rectangle) {\n  const breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n  let total = 0;\n  for (const edge of breakingEdges) {\n    total += _getRelativeEdgeDifference(rect, bounds, edge) ** 2;\n  }\n\n  return total;\n}\n\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(\n  rect: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n): IElementPosition {\n  const directions: RectangleEdge[] = [\n    RectangleEdge.left,\n    RectangleEdge.right,\n    RectangleEdge.bottom,\n    RectangleEdge.top,\n  ];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  let currentEstimate = rect;\n  let currentEdge = positionData.targetEdge;\n  let currentAlignment = positionData.alignmentEdge;\n\n  // keep track of least bad option, in case no sides fit\n  let oobDegree;\n  let bestEdge = currentEdge;\n  let bestAlignment = currentAlignment;\n\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (let i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // update least-bad edges\n      const currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(\n          rect,\n          target,\n          { targetEdge: currentEdge, alignmentEdge: currentAlignment },\n          gap,\n        );\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n      };\n    }\n  }\n\n  // nothing fits, use least-bad option\n  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment,\n  };\n}\n\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(\n  elementEstimate: IElementPosition,\n  target: Rectangle,\n  gap: number,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\n  const oppositeEdge = alignmentEdge! * -1;\n  const newEstimate = _estimatePosition(\n    elementRectangle,\n    target,\n    { targetEdge, alignmentEdge: oppositeEdge },\n    gap,\n    coverTarget,\n  );\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge,\n    alignmentEdge: oppositeEdge,\n  };\n}\n\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(\n  element: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, alignTargetEdge } = positionData;\n  let elementEstimate: IElementPosition = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge,\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n  const outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n  // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n  const fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(\n            _getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding),\n            elementEstimate,\n            bounding,\n            fixedEdge,\n          );\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(\n  outOfBoundsEdges: RectangleEdge[],\n  elementEstimate: IElementPosition,\n  bounding: Rectangle,\n  preserveEdge?: RectangleEdge,\n) {\n  for (const direction of outOfBoundsEdges) {\n    let edgeAttempt;\n\n    // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n      const inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n      // only update estimate if the attempt didn't break out of the opposite bounding edge\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\n  const { positiveEdge } = _getFlankingEdges(edge);\n  const elementMiddle = _getCenterValue(rect, edge);\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  coverTarget?: boolean,\n): Rectangle {\n  let estimatedElementPosition = new Rectangle(\n    elementToPosition.left,\n    elementToPosition.right,\n    elementToPosition.top,\n    elementToPosition.bottom,\n  );\n  const { alignmentEdge, targetEdge } = positionData;\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget\n    ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)\n    : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right,\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom,\n    };\n  }\n}\n\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(\n  elementRectangle: Rectangle,\n  returnEdge: RectangleEdge,\n  bounds?: Rectangle,\n): RectangleEdge {\n  if (\n    bounds &&\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\n  ) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle: Rectangle, edge: RectangleEdge, bounds?: Rectangle): boolean {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(\n  elementRectangle: Rectangle,\n  hostElement: HTMLElement,\n  targetEdge: RectangleEdge,\n  bounds?: Rectangle,\n  alignmentEdge?: RectangleEdge,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n  forceWithinBounds?: boolean,\n): IPartialIRectangle {\n  const returnValue: IPartialIRectangle = {};\n\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  let returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n\n  // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n\n  // if the positioned element will still overflow, return all four edges with in-bounds values\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      elementEdge * -1,\n    );\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      returnEdge * -1,\n    );\n  }\n\n  return returnValue;\n}\n\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\n  directionalHintForRTL?: DirectionalHint,\n  previousPositions?: IPositionDirectionalHintData,\n): IPositionDirectionalHintData {\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge,\n    };\n  }\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(\n  positionData: IPositionDirectionalHintData,\n  target: Rectangle,\n  boundingRect: Rectangle,\n  coverTarget?: boolean,\n  alignTargetEdge?: boolean,\n): IPositionDirectionalHintData {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\n  const targetCenter: number = _getCenterValue(target, targetEdge);\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const estimatedElementPosition: Rectangle = _estimatePosition(\n    elementToPosition,\n    target,\n    positionData,\n    gap,\n    coverTarget,\n  );\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge,\n    };\n  } else {\n    return _adjustFitWithinBounds(\n      estimatedElementPosition,\n      target,\n      bounding,\n      positionData,\n      gap,\n      directionalHintFixed,\n      coverTarget,\n    );\n  }\n}\n\nfunction _finalizeBeakPosition(\n  elementPosition: IElementPositionInfo,\n  positionedBeak: Rectangle,\n  bounds?: Rectangle,\n): ICalloutBeakPositionedInfo {\n  const targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  const actualElement = new Rectangle(\n    0,\n    elementPosition.elementRectangle.width,\n    0,\n    elementPosition.elementRectangle.height,\n  );\n  const returnValue: IPartialIRectangle = {};\n  const returnEdge = _finalizeReturnEdge(\n    elementPosition.elementRectangle,\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\n    bounds,\n  );\n\n  // only show the beak if the callout is not fully covering the target\n  const beakEdgeDifference = _getRelativeEdgeDifference(\n    elementPosition.elementRectangle,\n    elementPosition.targetRectangle,\n    targetEdge,\n  );\n  const showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n\n  return {\n    elementPosition: { ...returnValue },\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge,\n    hideBeak: !showBeak,\n  };\n}\n\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\n  const target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  const elementBounds = new Rectangle(\n    beakWidth / 2,\n    elementPosition.elementRectangle.width - beakWidth / 2,\n    beakWidth / 2,\n    elementPosition.elementRectangle.height - beakWidth / 2,\n  );\n\n  let beakPosition: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n\n  beakPosition = _centerEdgeToPoint(\n    beakPosition,\n    elementPosition.targetEdge * -1,\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle),\n  );\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element: Element): Rectangle {\n  // eslint-disable-next-line deprecation/deprecation\n  const clientRect: ClientRect = element.getBoundingClientRect();\n\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | Point | Rectangle | undefined): Rectangle {\n  let targetRectangle: Rectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!(target as MouseEvent).preventDefault) {\n      const ev = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!(target as Element).getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target as Element);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      const rectOrPoint: Point & Rectangle = target as Point & Rectangle;\n      // eslint-disable-next-line deprecation/deprecation\n      const left = rectOrPoint.left || rectOrPoint.x;\n      // eslint-disable-next-line deprecation/deprecation\n      const top = rectOrPoint.top || rectOrPoint.y;\n      const right = rectOrPoint.right || left;\n      const bottom = rectOrPoint.bottom || top;\n      targetRectangle = new Rectangle(left, right, top, bottom);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (const direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(\n  targetRectangle: Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number,\n  bounds: Rectangle,\n  coverTarget?: boolean,\n) {\n  let maxHeight = 0;\n  const directionalHint = DirectionalDictionary[targetEdge];\n\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(\n  props: IPositionProps,\n  elementToPosition: HTMLElement,\n  boundingRect: Rectangle,\n  previousPositions?: IPositionedData,\n): IElementPositionInfo {\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget,\n    props.alignTargetEdge,\n  );\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\n    _getRectangleFromElement(elementToPosition),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    props.directionalHintFixed,\n    props.coverTarget,\n  );\n  return { ...positionedElement, targetRectangle: targetRect };\n}\n\nfunction _finalizePositionData(\n  positionedElement: IElementPosition,\n  hostElement: HTMLElement,\n  bounds?: Rectangle,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPositionedData {\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\n    positionedElement.elementRectangle,\n    hostElement,\n    positionedElement.targetEdge,\n    bounds,\n    positionedElement.alignmentEdge,\n    coverTarget,\n    doNotFinalizeReturnEdge,\n    positionedElement.forcedInBounds,\n  );\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge,\n  };\n}\n\nfunction _positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPosition = _positionElementRelative(\n    props,\n    elementToPosition,\n    boundingRect,\n    previousPositions,\n  );\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  doNotFinalizeReturnEdge?: boolean,\n): ICalloutPositionedInfo {\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  const gap: number = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  const positionProps: IPositionProps = props;\n  positionProps.gapSpace = gap;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPositionInfo = _positionElementRelative(\n    positionProps,\n    callout,\n    boundingRect,\n    previousPositions,\n  );\n\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(\n    positionedElement,\n    beakPositioned,\n    boundingRect,\n  );\n\n  return {\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge),\n    beakPosition: finalizedBeakPosition,\n  };\n}\n\nfunction _positionCard(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n}\n// END PRIVATE FUNCTIONS\n\nexport const __positioningTestPackage = {\n  _finalizePositionData,\n  _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds,\n  _positionBeak,\n  _getPositionData,\n  _getMaxHeightFromTargetRectangle,\n};\n\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCallout(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCard(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(\n  target: Element | MouseEvent | Point | Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number = 0,\n  bounds?: IRectangle,\n  coverTarget?: boolean,\n): number {\n  const mouseTarget: MouseEvent = target as MouseEvent;\n  const elementTarget: Element = target as Element;\n  const rectOrPointTarget: Point & Rectangle = target as Point & Rectangle;\n  let targetRect: Rectangle;\n  const boundingRectangle = bounds\n    ? _getRectangleFromIRect(bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  // eslint-disable-next-line deprecation/deprecation\n  const left = rectOrPointTarget.left || rectOrPointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  const top = rectOrPointTarget.top || rectOrPointTarget.y;\n  const right = rectOrPointTarget.right || left;\n  const bottom = rectOrPointTarget.bottom || top;\n\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  let segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight,\n    };\n  }\n\n  // Logic for determining dual screen scenarios.\n  let x: number | undefined = 0;\n  let y: number | undefined = 0;\n\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!(target as Element).getBoundingClientRect) {\n    const clientRect = (target as Element).getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = (target as Point).left || (target as MouseEvent | Point).x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = (target as Point).top || (target as MouseEvent | Point).y;\n  }\n\n  let bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (const segment of segments) {\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height,\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\n", "import * as React from 'react';\nimport {\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  getPropsWithDefaults,\n  getWindow,\n  modalize,\n} from '../../Utilities';\nimport { useMergedRefs, useAsync, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport type { IPopupProps, IPopupRestoreFocusParams } from './Popup.types';\n\nfunction useScrollbarAsync(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const async = useAsync();\n  const [needsVerticalScrollBarState, setNeedsVerticalScrollBar] = React.useState(false);\n  React.useEffect(() => {\n    async.requestAnimationFrame(() => {\n      // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.\n      if (props.style && props.style.overflowY) {\n        return;\n      }\n\n      let needsVerticalScrollBar = false;\n      if (root && root.current && root.current?.firstElementChild) {\n        // ClientHeight returns the client height of an element rounded to an\n        // integer. On some browsers at different zoom levels this rounding\n        // can generate different results for the root container and child even\n        // though they are the same height. This causes us to show a scroll bar\n        // when not needed. Ideally we would use BoundingClientRect().height\n        // instead however seems that the API is 90% slower than using ClientHeight.\n        // Therefore instead we will calculate the difference between heights and\n        // allow for a 1px difference to still be considered ok and not show the\n        // scroll bar.\n        const rootHeight = root.current.clientHeight;\n        const firstChildHeight = root.current.firstElementChild.clientHeight;\n        if (rootHeight > 0 && firstChildHeight > rootHeight) {\n          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n        }\n      }\n      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {\n        setNeedsVerticalScrollBar(needsVerticalScrollBar);\n      }\n    });\n\n    return () => async.dispose();\n  });\n\n  return needsVerticalScrollBarState;\n}\n\nfunction defaultFocusRestorer(options: IPopupRestoreFocusParams) {\n  const { originalElement, containsFocus } = options;\n\n  if (originalElement && containsFocus && originalElement !== getWindow()) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.\n    // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)\n    setTimeout(() => {\n      originalElement.focus?.();\n    }, 0);\n  }\n}\n\nfunction useRestoreFocus(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const { onRestoreFocus = defaultFocusRestorer } = props;\n  const originalFocusedElement = React.useRef<HTMLElement>();\n  const containsFocus = React.useRef(false);\n\n  React.useEffect(() => {\n    originalFocusedElement.current = getDocument()!.activeElement as HTMLElement;\n\n    if (doesElementContainFocus(root.current!)) {\n      containsFocus.current = true;\n    }\n\n    return () => {\n      onRestoreFocus?.({\n        originalElement: originalFocusedElement.current,\n        containsFocus: containsFocus.current,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n      originalFocusedElement.current = undefined;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []);\n\n  useOnEvent(\n    root,\n    'focus',\n    React.useCallback((): void => {\n      containsFocus.current = true;\n    }, []),\n    true,\n  );\n\n  useOnEvent(\n    root,\n    'blur',\n    React.useCallback((ev: FocusEvent): void => {\n      /** The popup should update this._containsFocus when:\n       * relatedTarget exists AND\n       * the relatedTarget is not contained within the popup.\n       * If the relatedTarget is within the popup, that means the popup still has focus\n       * and focused moved from one element to another within the popup.\n       * If relatedTarget is undefined or null that usually means that a\n       * keyboard event occurred and focus didn't change\n       */\n      if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget as HTMLElement)) {\n        containsFocus.current = false;\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n    }, []),\n    true,\n  );\n}\n\nfunction useHideSiblingNodes(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  // eslint-disable-next-line deprecation/deprecation\n  const shouldHideSiblings = String(props['aria-modal']).toLowerCase() === 'true' && props.enableAriaHiddenSiblings;\n\n  React.useEffect(() => {\n    if (!(shouldHideSiblings && root.current)) {\n      return;\n    }\n\n    const unmodalize = modalize(root.current);\n    return unmodalize;\n  }, [root, shouldHideSiblings]);\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport const Popup: React.FunctionComponent<IPopupProps> = React.forwardRef<HTMLDivElement, IPopupProps>(\n  (propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(\n      { shouldRestoreFocus: true, enableAriaHiddenSiblings: true },\n      propsWithoutDefaults,\n    );\n\n    const root = React.useRef<HTMLDivElement>();\n    const mergedRootRef = useMergedRefs(root, forwardedRef) as React.Ref<HTMLDivElement>;\n\n    useHideSiblingNodes(props, root);\n    useRestoreFocus(props, root);\n\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style, children, onDismiss } = props;\n    const needsVerticalScrollBar = useScrollbarAsync(props, root);\n\n    const onKeyDown = React.useCallback(\n      (ev: React.KeyboardEvent<HTMLElement> | KeyboardEvent): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.escape:\n            if (onDismiss) {\n              onDismiss(ev);\n\n              ev.preventDefault();\n              ev.stopPropagation();\n            }\n\n            break;\n        }\n      },\n      [onDismiss],\n    );\n\n    const win = useWindow();\n    useOnEvent(win, 'keydown', onKeyDown as (ev: Event) => void);\n\n    return (\n      <div\n        ref={mergedRootRef}\n        {...getNativeProps(props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={onKeyDown}\n        style={{ overflowY: needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {children}\n      </div>\n    );\n  },\n);\nPopup.displayName = 'Popup';\n", "import * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  on,\n  shallowCompare,\n  getPropsWithDefaults,\n  Async,\n} from '../../Utilities';\nimport { positionCallout, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../Positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { useMergedRefs, useAsync, useConst, useTarget, useOnEvent } from '@fluentui/react-hooks';\nimport type { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type { ICalloutPositionedInfo, IPositionProps, IPosition } from '../../Positioning';\nimport type { Target } from '@fluentui/react-hooks';\n\nconst COMPONENT_NAME = 'CalloutContentBase';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none',\n};\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nconst DEFAULT_PROPS = {\n  preventDismissOnLostFocus: false,\n  preventDismissOnScroll: false,\n  preventDismissOnResize: false,\n  isBeakVisible: true,\n  beakWidth: 16,\n  gapSpace: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n} as const;\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\n/**\n * (Hook) to return a function to lazily fetch the bounds of the target element for the callout.\n */\nfunction useBounds(\n  { bounds, minPagePadding = DEFAULT_PROPS.minPagePadding, target }: ICalloutProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const [targetWindowResized, setTargetWindowResized] = React.useState(false);\n  const cachedBounds = React.useRef<IRectangle | undefined>();\n\n  const getBounds = React.useCallback((): IRectangle | undefined => {\n    if (!cachedBounds.current || targetWindowResized) {\n      let currentBounds =\n        typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;\n\n      if (!currentBounds && targetWindow) {\n        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);\n        currentBounds = {\n          top: currentBounds.top + minPagePadding,\n          left: currentBounds.left + minPagePadding,\n          right: currentBounds.right! - minPagePadding,\n          bottom: currentBounds.bottom! - minPagePadding,\n          width: currentBounds.width - minPagePadding * 2,\n          height: currentBounds.height - minPagePadding * 2,\n        };\n      }\n      cachedBounds.current = currentBounds;\n      targetWindowResized && setTargetWindowResized(false);\n    }\n\n    return cachedBounds.current;\n  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);\n\n  const async: Async = useAsync();\n  useOnEvent(\n    targetWindow,\n    'resize',\n    async.debounce(\n      () => {\n        setTargetWindowResized(true);\n      },\n      500,\n      { leading: true },\n    ),\n  );\n\n  return getBounds;\n}\n\n/**\n * (Hook) to return the maximum available height for the Callout to render into.\n */\nfunction useMaxHeight(\n  { calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, hidden }: ICalloutProps,\n  getBounds: () => IRectangle | undefined,\n  positions?: ICalloutPositionedInfo,\n) {\n  const [maxHeight, setMaxHeight] = React.useState<number | undefined>();\n  const { top, bottom } = positions?.elementPosition ?? {};\n\n  React.useEffect(() => {\n    const { top: topBounds, bottom: bottomBounds } = getBounds() ?? {};\n    let calculatedHeight: number | undefined;\n\n    if (typeof top === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - top;\n    } else if (typeof bottom === 'number' && typeof topBounds === 'number' && bottomBounds) {\n      calculatedHeight = bottomBounds - topBounds - bottom;\n    }\n\n    if (\n      (!calloutMaxHeight && !hidden) ||\n      (calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight)\n    ) {\n      setMaxHeight(calculatedHeight);\n    } else if (calloutMaxHeight) {\n      setMaxHeight(calloutMaxHeight);\n    } else {\n      setMaxHeight(undefined);\n    }\n  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);\n\n  return maxHeight;\n}\n\n/**\n * (Hook) to find the current position of Callout. If Callout is resized then a new position is calculated.\n */\nfunction usePositions(\n  props: ICalloutProps,\n  hostElement: React.RefObject<HTMLDivElement>,\n  calloutElement: HTMLDivElement | null,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getBounds: () => IRectangle | undefined,\n) {\n  const [positions, setPositions] = React.useState<ICalloutPositionedInfo>();\n  const positionAttempts = React.useRef(0);\n  const previousTarget = React.useRef<Target>();\n  const async = useAsync();\n  const { hidden, target, finalHeight, calloutMaxHeight, onPositioned, directionalHint } = props;\n\n  React.useEffect(() => {\n    if (!hidden) {\n      const timerId = async.requestAnimationFrame(() => {\n        if (hostElement.current && calloutElement) {\n          const currentProps: IPositionProps = {\n            ...props,\n            target: targetRef.current!,\n            bounds: getBounds(),\n          };\n\n          // duplicate calloutElement & remove useMaxHeight's maxHeight for position calc\n          const dupeCalloutElement = calloutElement.cloneNode(true) as HTMLElement;\n          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? `${calloutMaxHeight}` : '';\n          dupeCalloutElement.style.visibility = 'hidden';\n          calloutElement.parentElement?.appendChild(dupeCalloutElement);\n\n          const previousPositions = previousTarget.current === target ? positions : undefined;\n\n          // If there is a finalHeight given then we assume that the user knows and will handle\n          // additional positioning adjustments so we should call positionCard\n          const newPositions: ICalloutPositionedInfo = finalHeight\n            ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions)\n            : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);\n\n          // clean up duplicate calloutElement\n          calloutElement.parentElement?.removeChild(dupeCalloutElement);\n\n          // Set the new position only when the positions do not exist or one of the new callout positions\n          // is different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n            // and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n          } else if (positionAttempts.current > 0) {\n            // Only call the onPositioned callback if the callout has been re-positioned at least once.\n            positionAttempts.current = 0;\n            onPositioned?.(positions);\n          }\n        }\n      }, calloutElement);\n\n      previousTarget.current = target;\n\n      return () => {\n        async.cancelAnimationFrame(timerId);\n        previousTarget.current = undefined;\n      };\n    } else {\n      // When the callout is hidden, clear position state so that it is not accidentally used next render.\n      setPositions(undefined);\n      positionAttempts.current = 0;\n    }\n  }, [\n    hidden,\n    directionalHint,\n    async,\n    calloutElement,\n    calloutMaxHeight,\n    hostElement,\n    targetRef,\n    finalHeight,\n    getBounds,\n    onPositioned,\n    positions,\n    props,\n    target,\n  ]);\n\n  return positions;\n}\n\n/**\n * (Hook) to set up behavior to automatically focus the callout when it appears, if indicated by props.\n */\nfunction useAutoFocus(\n  { hidden, setInitialFocus }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  calloutElement: HTMLDivElement | null,\n) {\n  const async = useAsync();\n  const hasPositions = !!positions;\n  React.useEffect(() => {\n    if (!hidden && setInitialFocus && hasPositions && calloutElement) {\n      const timerId = async.requestAnimationFrame(() => focusFirstChild(calloutElement), calloutElement);\n\n      return () => async.cancelAnimationFrame(timerId);\n    }\n  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);\n}\n\n/**\n * (Hook) to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.\n */\nfunction useDismissHandlers(\n  {\n    hidden,\n    onDismiss,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnScroll,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnResize,\n    // eslint-disable-next-line deprecation/deprecation\n    preventDismissOnLostFocus,\n    dismissOnTargetClick,\n    shouldDismissOnWindowFocus,\n    preventDismissOnEvent,\n  }: ICalloutProps,\n  positions: ICalloutPositionedInfo | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  targetWindow: Window | undefined,\n) {\n  const isMouseDownOnPopup = React.useRef(false);\n  const async = useAsync();\n\n  const mouseDownHandlers = useConst([\n    () => {\n      isMouseDownOnPopup.current = true;\n    },\n    () => {\n      isMouseDownOnPopup.current = false;\n    },\n  ] as const);\n\n  const positionsExists = !!positions;\n\n  React.useEffect(() => {\n    const dismissOnScroll = (ev: Event) => {\n      if (positionsExists && !preventDismissOnScroll) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnResize = (ev: Event) => {\n      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnLostFocus = (ev: Event) => {\n      if (!preventDismissOnLostFocus) {\n        dismissOnClickOrScroll(ev);\n      }\n    };\n\n    const dismissOnClickOrScroll = (ev: Event) => {\n      const eventPaths: Array<EventTarget> = ev.composedPath ? ev.composedPath() : [];\n      const target = eventPaths.length > 0 ? (eventPaths[0] as HTMLElement) : (ev.target as HTMLElement);\n      const isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);\n\n      // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {\n        isMouseDownOnPopup.current = false;\n        return;\n      }\n\n      if (\n        (!targetRef.current && isEventTargetOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          isEventTargetOutsideCallout &&\n          (!targetRef.current ||\n            'stopPropagation' in targetRef.current ||\n            dismissOnTargetClick ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {\n          return;\n        }\n        onDismiss?.(ev);\n      }\n    };\n\n    const dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n\n      if (\n        ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n          (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n        !targetWindow?.document.hasFocus() &&\n        ev.relatedTarget === null\n      ) {\n        onDismiss?.(ev);\n      }\n    };\n\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    const disposablesPromise = new Promise<() => void>(resolve => {\n      async.setTimeout(() => {\n        if (!hidden && targetWindow) {\n          const disposables = [\n            on(targetWindow, 'scroll', dismissOnScroll, true),\n            on(targetWindow, 'resize', dismissOnResize, true),\n            on(targetWindow.document.documentElement, 'focus', dismissOnLostFocus, true),\n            on(targetWindow.document.documentElement, 'click', dismissOnLostFocus, true),\n            on(targetWindow, 'blur', dismissOnTargetWindowBlur, true),\n          ];\n\n          resolve(() => {\n            disposables.forEach(dispose => dispose());\n          });\n        }\n      }, 0);\n    });\n\n    return () => {\n      disposablesPromise.then(dispose => dispose());\n    };\n  }, [\n    hidden,\n    async,\n    hostElement,\n    targetRef,\n    targetWindow,\n    onDismiss,\n    shouldDismissOnWindowFocus,\n    dismissOnTargetClick,\n    preventDismissOnLostFocus,\n    preventDismissOnResize,\n    preventDismissOnScroll,\n    positionsExists,\n    preventDismissOnEvent,\n  ]);\n\n  return mouseDownHandlers;\n}\n\nexport const CalloutContentBase: React.FunctionComponent<ICalloutProps> = React.memo(\n  React.forwardRef<HTMLDivElement, ICalloutProps>((propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n      target,\n      hidden,\n      onLayerMounted,\n      popupProps,\n    } = props;\n\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const [calloutElement, setCalloutElement] = React.useState<HTMLDivElement | null>(null);\n    const calloutCallback = React.useCallback((calloutEl: any) => {\n      setCalloutElement(calloutEl);\n    }, []);\n    const rootRef = useMergedRefs(hostElement, forwardedRef);\n\n    const [targetRef, targetWindow] = useTarget(props.target, {\n      current: calloutElement,\n    });\n    const getBounds = useBounds(props, targetRef, targetWindow);\n    const positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);\n    const maxHeight = useMaxHeight(props, getBounds, positions);\n    const [mouseDownOnPopup, mouseUpOnPopup] = useDismissHandlers(\n      props,\n      positions,\n      hostElement,\n      targetRef,\n      targetWindow,\n    );\n\n    // do not set both top and bottom css props from positions\n    // instead, use maxHeight\n    const isForcedInBounds = positions?.elementPosition.top && positions?.elementPosition.bottom;\n    const cssPositions = {\n      ...positions?.elementPosition,\n      maxHeight,\n    };\n    if (isForcedInBounds) {\n      cssPositions.bottom = undefined;\n    }\n\n    useAutoFocus(props, positions, calloutElement);\n\n    React.useEffect(() => {\n      if (!hidden) {\n        onLayerMounted?.();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if hidden changes\n    }, [hidden]);\n\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!targetWindow) {\n      return null;\n    }\n\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    const classNames = getClassNames(styles!, {\n      theme: props.theme!,\n      className,\n      overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMaxWidth,\n      calloutMinWidth,\n      doNotLayer,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      maxHeight: calloutMaxHeight ? calloutMaxHeight : '100%',\n      ...style,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    return (\n      <div ref={rootRef} className={classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? { ...cssPositions } : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={calloutCallback}\n        >\n          {beakVisible && <div className={classNames.beak} style={getBeakPosition(positions)} />}\n          {beakVisible && <div className={classNames.beakCurtain} />}\n          <Popup\n            // don't use getNativeElementProps for role and roledescription because it will also\n            // pass through data-* props (resulting in them being used in two places)\n            role={props.role}\n            aria-roledescription={props['aria-roledescription']}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            className={classNames.calloutMain}\n            onDismiss={props.onDismiss}\n            onMouseDown={mouseDownOnPopup}\n            onMouseUp={mouseUpOnPopup}\n            onRestoreFocus={props.onRestoreFocus}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n            {...popupProps}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n  }),\n  (previousProps: ICalloutProps, nextProps: ICalloutProps) => {\n    if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n    return shallowCompare(previousProps, nextProps);\n  },\n);\n\n/**\n * (Utility) to find and return the current `Callout` Beak position.\n *\n * @param positions\n */\nfunction getBeakPosition(positions?: ICalloutPositionedInfo): React.CSSProperties {\n  const beakPositionStyle: React.CSSProperties = {\n    ...positions?.beakPosition?.elementPosition,\n    display: positions?.beakPosition?.hideBeak ? 'none' : undefined,\n  };\n\n  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {\n    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;\n    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;\n  }\n\n  return beakPositionStyle;\n}\n\n/**\n * (Utility) used to compare two different elementPositions to determine whether they are equal.\n *\n * @param prevElementPositions\n * @param newElementPosition\n */\nfunction arePositionsEqual(\n  prevElementPositions: ICalloutPositionedInfo,\n  newElementPosition: ICalloutPositionedInfo,\n): boolean {\n  return (\n    comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) &&\n    comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition)\n  );\n}\n\n/**\n * (Utility) used in **arePositionsEqual** to compare two different elementPositions.\n *\n * @param prevElementPositions\n * @param newElementPositions\n */\nfunction comparePositions(prevElementPositions: IPosition, newElementPositions: IPosition): boolean {\n  for (const key in newElementPositions) {\n    if (newElementPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = prevElementPositions[key];\n      const newPositionEdge = newElementPositions[key];\n      if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nCalloutContentBase.displayName = COMPONENT_NAME;\n", "import { HighContrastSelector, focusClear, getGlobalClassNames, ZIndexes } from '../../Styling';\nimport type { IRawStyle } from '../../Styling';\nimport type { ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\n\nfunction getBeakStyle(beakWidth?: number): IRawStyle {\n  return {\n    height: beakWidth,\n    width: beakWidth,\n  };\n}\n\nconst GlobalClassNames = {\n  container: 'ms-Callout-container',\n  root: 'ms-Callout',\n  beak: 'ms-Callout-beak',\n  beakCurtain: 'ms-Callout-beakCurtain',\n  calloutMain: 'ms-Callout-main',\n};\n\nexport const getStyles = (props: ICalloutContentStyleProps): ICalloutContentStyles => {\n  const {\n    theme,\n    className,\n    overflowYHidden,\n    calloutWidth,\n    beakWidth,\n    backgroundColor,\n    calloutMaxWidth,\n    calloutMinWidth,\n    doNotLayer,\n  } = props;\n\n  const classNames = getGlobalClassNames(GlobalClassNames, theme);\n\n  const { semanticColors, effects } = theme;\n\n  return {\n    container: [\n      classNames.container,\n      {\n        position: 'relative',\n      },\n    ],\n    root: [\n      classNames.root,\n      theme.fonts.medium,\n      {\n        position: 'absolute',\n        display: 'flex',\n        zIndex: doNotLayer ? ZIndexes.Layer : undefined,\n        boxSizing: 'border-box',\n        borderRadius: effects.roundedCorner2,\n        boxShadow: effects.elevation16,\n        selectors: {\n          [HighContrastSelector]: {\n            borderWidth: 1,\n            borderStyle: 'solid',\n            borderColor: 'WindowText',\n          },\n        },\n      },\n      focusClear(),\n      className,\n      !!calloutWidth && { width: calloutWidth },\n      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },\n      !!calloutMinWidth && { minWidth: calloutMinWidth },\n    ],\n    beak: [\n      classNames.beak,\n      {\n        position: 'absolute',\n        backgroundColor: semanticColors.menuBackground,\n        boxShadow: 'inherit',\n        border: 'inherit',\n        boxSizing: 'border-box',\n        transform: 'rotate(45deg)',\n      },\n      getBeakStyle(beakWidth),\n      backgroundColor && {\n        backgroundColor,\n      },\n    ],\n    beakCurtain: [\n      classNames.beakCurtain,\n      {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        backgroundColor: semanticColors.menuBackground,\n        borderRadius: effects.roundedCorner2,\n      },\n    ],\n    calloutMain: [\n      classNames.calloutMain,\n      {\n        backgroundColor: semanticColors.menuBackground,\n        overflowX: 'hidden',\n        overflowY: 'auto',\n        position: 'relative',\n        width: '100%',\n        borderRadius: effects.roundedCorner2,\n      },\n      overflowYHidden && {\n        overflowY: 'hidden',\n      },\n      backgroundColor && {\n        backgroundColor,\n      },\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { CalloutContentBase } from './CalloutContent.base';\nimport { getStyles } from './CalloutContent.styles';\nimport type { ICalloutProps } from './Callout.types';\n\nexport const CalloutContent: React.FunctionComponent<ICalloutProps> = styled(CalloutContentBase, getStyles, undefined, {\n  scope: 'CalloutContent',\n});\n", "import * as React from 'react';\nimport { CalloutContent } from './CalloutContent';\nimport { Layer } from '../../Layer';\nimport type { ICalloutProps } from './Callout.types';\n\nexport const Callout: React.FunctionComponent<ICalloutProps> = React.forwardRef<HTMLDivElement, ICalloutProps>(\n  ({ layerProps, doNotLayer, ...rest }, forwardedRef) => {\n    const content = <CalloutContent {...rest} doNotLayer={doNotLayer} ref={forwardedRef} />;\n    return doNotLayer ? content : <Layer {...layerProps}>{content}</Layer>;\n  },\n);\nCallout.displayName = 'Callout';\n", "import * as React from 'react';\n\nimport { Callout } from './Callout';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport type { IFocusTrapCalloutProps } from './FocusTrapCallout.types';\n\n/**\n * A special Callout that uses FocusTrapZone to trap focus\n * @param props - Props for the component\n */\nexport const FocusTrapCallout: React.FunctionComponent<IFocusTrapCalloutProps> = (\n  props: IFocusTrapCalloutProps,\n): JSX.Element => {\n  return (\n    <Callout {...props}>\n      <FocusTrapZone disabled={props.hidden} {...props.focusTrapProps}>\n        {props.children}\n      </FocusTrapZone>\n    </Callout>\n  );\n};\n", "import * as React from 'react';\nimport { classNamesFunction, divProperties, getNativeProps } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nconst getClassNames = classNamesFunction<ITooltipStyleProps, ITooltipStyles>();\n\nexport class TooltipBase extends React.Component<ITooltipProps, any> {\n  // Specify default props values\n  public static defaultProps: Partial<ITooltipProps> = {\n    directionalHint: DirectionalHint.topCenter,\n    maxWidth: '364px',\n    calloutProps: {\n      isBeakVisible: true,\n      beakWidth: 16,\n      gapSpace: 0,\n      setInitialFocus: true,\n      doNotLayer: false,\n    },\n  };\n\n  private _classNames: IProcessedStyleSet<ITooltipStyles>;\n\n  public render(): JSX.Element {\n    const {\n      className,\n      calloutProps,\n      directionalHint,\n      directionalHintForRTL,\n      styles,\n      id,\n      maxWidth,\n      onRenderContent = this._onRenderContent,\n      targetElement,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className: className || (calloutProps && calloutProps.className),\n      beakWidth: calloutProps && calloutProps.isBeakVisible ? calloutProps.beakWidth : 0,\n      gapSpace: calloutProps && calloutProps.gapSpace,\n      maxWidth: maxWidth!,\n    });\n\n    return (\n      <Callout\n        target={targetElement}\n        directionalHint={directionalHint}\n        directionalHintForRTL={directionalHintForRTL}\n        {...calloutProps}\n        {...getNativeProps(this.props, divProperties, ['id'])} // omitting ID due to it being used in the div below\n        className={this._classNames.root}\n      >\n        <div\n          className={this._classNames.content}\n          id={id}\n          onFocus={this.props.onFocus}\n          onMouseEnter={this.props.onMouseEnter}\n          onMouseLeave={this.props.onMouseLeave}\n        >\n          {onRenderContent(this.props, this._onRenderContent)}\n        </div>\n      </Callout>\n    );\n  }\n\n  private _onRenderContent = (props: ITooltipProps): JSX.Element => {\n    if (typeof props.content === 'string') {\n      return <p className={this._classNames.subText}>{props.content}</p>;\n    } else {\n      return <div className={this._classNames.subText}>{props.content}</div>;\n    }\n  };\n}\n", "import { AnimationClassNames } from '../../Styling';\nimport type { ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const getStyles = (props: ITooltipStyleProps): ITooltipStyles => {\n  const { className, beakWidth = 16, gapSpace = 0, maxWidth, theme } = props;\n  const { semanticColors, fonts, effects } = theme;\n\n  // The math here is done to account for the 45 degree rotation of the beak\n  // and sub-pixel rounding that differs across browsers, which is more noticeable when\n  // the device pixel ratio is larger\n  const tooltipGapSpace = -(Math.sqrt((beakWidth * beakWidth) / 2) + gapSpace) + 1 / window.devicePixelRatio;\n\n  return {\n    root: [\n      'ms-Tooltip',\n      theme.fonts.medium,\n      AnimationClassNames.fadeIn200,\n      {\n        background: semanticColors.menuBackground,\n        boxShadow: effects.elevation8,\n        padding: '8px',\n        maxWidth,\n        selectors: {\n          ':after': {\n            content: `''`,\n            position: 'absolute',\n            bottom: tooltipGapSpace,\n            left: tooltipGapSpace,\n            right: tooltipGapSpace,\n            top: tooltipGapSpace,\n            zIndex: 0,\n          },\n        },\n      },\n      className,\n    ],\n    content: [\n      'ms-Tooltip-content',\n      fonts.small,\n      {\n        position: 'relative',\n        zIndex: 1,\n        color: semanticColors.menuItemText,\n        wordWrap: 'break-word',\n        overflowWrap: 'break-word',\n        overflow: 'hidden',\n      },\n    ],\n    subText: [\n      'ms-Tooltip-subtext',\n      {\n        // Using inherit here to avoid unintentional global overrides of the <p> tag.\n        fontSize: 'inherit',\n        fontWeight: 'inherit',\n        color: 'inherit',\n        margin: 0,\n      },\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipBase } from './Tooltip.base';\nimport { getStyles } from './Tooltip.styles';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const Tooltip: React.FunctionComponent<ITooltipProps> = styled<\n  ITooltipProps,\n  ITooltipStyleProps,\n  ITooltipStyles\n>(TooltipBase, getStyles, undefined, {\n  scope: 'Tooltip',\n});\n", "import * as React from 'react';\nimport { TooltipBase } from './Tooltip.base';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRenderFunction, IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltip {}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipProps extends Omit<React.HTMLAttributes<HTMLDivElement | TooltipBase>, 'content'> {\n  /**\n   * Optional callback to access the ITooltip interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltip>;\n\n  /**\n   * Properties to pass through for Callout.\n   * @defaultvalue `{ isBeakVisible: true, beakWidth: 16, gapSpace: 0, setInitialFocus: true, doNotLayer: false }`\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Content to be passed to the tooltip\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Render function to populate tooltip content.\n   */\n  onRenderContent?: IRenderFunction<ITooltipProps>;\n\n  /**\n   * Length of delay. Set to `TooltipDelay.zero` if you do not want a delay.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Max width of tooltip\n   * @defaultvalue 364px\n   */\n  maxWidth?: string | null;\n\n  /**\n   * Element to anchor the Tooltip to.\n   */\n  targetElement?: HTMLElement;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipStyleProps, ITooltipStyles>;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipDelay {\n  zero = 0,\n  /** 300 ms delay before showing the tooltip */\n  medium = 1,\n  /** 500 ms delay before showing the tooltip */\n  long = 2,\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyleProps {\n  theme: ITheme;\n\n  className?: string;\n\n  /**\n   * Delay before tooltip appears.\n   * @deprecated Delay logic moved to TooltipHost vs relying on animation delay.\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Maximum width of tooltip.\n   */\n  maxWidth?: string;\n\n  /**\n   * The gap between the Callout and the target\n   * @defaultvalue 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the Callout's beak\n   * @defaultvalue 16\n   */\n  beakWidth?: number;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyles {\n  /**\n   * Style for the root element.\n   */\n  root: IStyle;\n\n  /**\n   * Style for the content element.\n   */\n  content: IStyle;\n\n  /**\n   * Style for the subtext element.\n   */\n  subText: IStyle;\n}\n", "import * as React from 'react';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { TooltipDelay } from './Tooltip.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ITooltipProps } from './Tooltip.types';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHost {\n  /**\n   * Shows the tooltip.\n   */\n  show: () => void;\n\n  /**\n   * Dismisses the tooltip.\n   */\n  dismiss: () => void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipOverflowMode {\n  /** Only show tooltip if parent DOM element is overflowing */\n  Parent,\n\n  /**\n   * Only show tooltip if tooltip host's content is overflowing.\n   * Note that this does not check the children for overflow, only the TooltipHost root.\n   */\n  Self,\n}\n\n/**\n * TooltipHost props. Note that native props (such as `id`, `className`, and `aria-` props) are\n * passed through to the Tooltip itself, rather than being used on the host element.\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostProps extends Omit<React.HTMLAttributes<HTMLDivElement | TooltipHostBase>, 'content'> {\n  /**\n   * Optional callback to access the ITooltipHost interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltipHost>;\n\n  /**\n   * Additional properties to pass through for Callout.\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Number of milliseconds to delay closing the tooltip, so that the user has time to hover over\n   * the tooltip and interact with it. Hovering over the tooltip will count as hovering over the\n   * host, so that the tooltip will stay open if the user is actively interacting with it.\n   */\n  closeDelay?: number;\n\n  /**\n   * Content to display in the Tooltip.\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Length of delay before showing the tooltip on hover.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used.\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Class name to apply to tooltip host.\n   */\n  hostClassName?: string;\n\n  /**\n   * Class name to apply to the *tooltip itself*, not the host.\n   * To apply a class to the host, use `hostClassName` or `styles.root`.\n   */\n  className?: string;\n\n  /**\n   * If this is unset (the default), the tooltip is always shown even if there's no overflow.\n   *\n   * If set, only show the tooltip if the specified element (`Self` or `Parent`) has overflow.\n   * When set to `Parent`, the parent element is also used as the tooltip's target element.\n   *\n   * Note that even with `Self` mode, the TooltipHost *does not* check whether any children have overflow.\n   */\n  overflowMode?: TooltipOverflowMode;\n\n  /**\n   * Whether or not to mark the TooltipHost root element as described by the tooltip.\n   * Since this applies aria-describedby to a generic <div>, the description will not be\n   * read by screen readers. Instead, the caller should pass an `id` to the TooltipHost\n   * (to be passed through to the Tooltip) and mark the appropriate element as `aria-describedby`\n   * with the `id`.\n   * @defaultvalue true\n   * @deprecated use aria-describedby on the appropriate element instead\n   */\n  setAriaDescribedBy?: boolean;\n\n  /**\n   * Additional properties to pass through for Tooltip.\n   */\n  tooltipProps?: ITooltipProps;\n\n  /**\n   * Optional ID to pass through to the tooltip (not used on the host itself).\n   * Auto-generated if not provided.\n   */\n  id?: string;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipHostStyleProps, ITooltipHostStyles>;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Notifies when tooltip becomes visible or hidden, whatever the trigger was.\n   */\n  onTooltipToggle?(isTooltipVisible: boolean): void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyleProps {\n  theme: ITheme;\n  className?: string;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyles {\n  /**\n   * Style for the host wrapper element.\n   */\n  root: IStyle;\n}\n", "import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nimport type { ITooltipHostProps, ITooltipHostStyles, ITooltipHostStyleProps, ITooltipHost } from './TooltipHost.types';\n\nexport interface ITooltipHostState {\n  /** @deprecated No longer used internally */\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n  private _ignoreNextFocusEvent: boolean;\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      // eslint-disable-next-line deprecation/deprecation\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n\n    const tooltipRenderProps = {\n      id: `${tooltipId}--tooltip`,\n      content,\n      targetElement: this._getTargetElement(),\n      directionalHint,\n      directionalHintForRTL,\n      calloutProps: assign({}, calloutProps, {\n        onDismiss: this._hideTooltip,\n        onFocus: this._onTooltipContentFocus,\n        onMouseEnter: this._onTooltipMouseEnter,\n        onMouseLeave: this._onTooltipMouseLeave,\n      }),\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave,\n      ...getNativeProps(this.props, divProperties, ['id']), // Make sure we use the id above\n      ...tooltipProps,\n    };\n\n    // Get the content of the tooltip for use in the hidden div used for screen readers\n    const tooltipContent = tooltipProps?.onRenderContent\n      ? tooltipProps.onRenderContent(tooltipRenderProps, props => (props?.content ? <>{props.content}</> : null))\n      : content;\n    const showTooltip = isTooltipVisible && !!tooltipContent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipFocus }}\n        {...{ onBlurCapture: this._onTooltipBlur }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        role=\"none\"\n        // WARNING: aria-describedby on this node provides no value, since it isn't allowed generic elements\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && <Tooltip {...tooltipRenderProps} />}\n        <div hidden={true} id={tooltipId} style={hiddenContentStyle as React.CSSProperties}>\n          {tooltipContent}\n        </div>\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  private _onTooltipFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this._ignoreNextFocusEvent) {\n      this._ignoreNextFocusEvent = false;\n      return;\n    }\n\n    this._onTooltipMouseEnter(ev);\n  };\n\n  private _onTooltipContentFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n  };\n\n  private _onTooltipBlur = (ev: React.FocusEvent<HTMLElement>) => {\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement,\n    // and ignoring when it next gets focus back.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    this._ignoreNextFocusEvent = document?.activeElement === ev.target;\n\n    this._dismissTimerId = this._async.setTimeout(() => {\n      this._hideTooltip();\n    }, 0);\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n", "import { getGlobalClassNames } from '../../Styling';\nimport type { ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nconst GlobalClassNames = {\n  root: 'ms-TooltipHost',\n  ariaPlaceholder: 'ms-TooltipHost-aria-placeholder',\n};\n\nexport const getStyles = (props: ITooltipHostStyleProps): ITooltipHostStyles => {\n  const { className, theme } = props;\n  const classNames = getGlobalClassNames(GlobalClassNames, theme);\n\n  return {\n    root: [\n      classNames.root,\n      {\n        display: 'inline',\n      },\n      className,\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { getStyles } from './TooltipHost.styles';\nimport type { ITooltipHostProps, ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nexport const TooltipHost: React.FunctionComponent<ITooltipHostProps> = styled<\n  ITooltipHostProps,\n  ITooltipHostStyleProps,\n  ITooltipHostStyles\n>(TooltipHostBase, getStyles, undefined, {\n  scope: 'TooltipHost',\n});\n"],
  "mappings": "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",
  "names": ["RectangleEdge", "Position", "_a", "_a", "React", "_a", "_b", "_a", "React", "_a", "React", "React", "getClassNames", "TooltipBase", "_a", "getStyles", "_a", "getStyles", "TooltipDelay", "TooltipOverflowMode", "React", "getClassNames", "TooltipHostBase", "_a", "GlobalClassNames", "getStyles", "getStyles"]
}
