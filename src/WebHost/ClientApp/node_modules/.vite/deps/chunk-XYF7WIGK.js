import {
  BaseDecorator,
  FocusZone,
  FocusZoneDirection,
  FocusZoneTabbableElements
} from "./chunk-WPUXA7SQ.js";
import {
  Callout,
  DirectionalHint,
  TooltipHost
} from "./chunk-KDVNYAWK.js";
import {
  FontIcon,
  FontWeights,
  HighContrastSelector,
  Icon,
  IconFontSizes,
  ImageIcon,
  ScreenWidthMaxMedium,
  getFocusStyle,
  getGlobalClassNames,
  getHighContrastNoAdjustStyle,
  getScreenSelector,
  hiddenContentStyle
} from "./chunk-53BTC5C3.js";
import {
  Async,
  EventGroup,
  FocusRects,
  FocusRectsContext,
  IsFocusVisibleClassName,
  KeyCodes,
  WindowContext,
  __assign,
  __decorate,
  __extends,
  __rest,
  __spreadArray,
  addElementAtIndex,
  anchorProperties,
  assign,
  buttonProperties,
  classNamesFunction,
  composeComponentAs,
  composeRenderFunction,
  concatStyleSets,
  concatStyleSetsWithProps,
  createMergedRef,
  css,
  customizable,
  divProperties,
  elementContains,
  find,
  focusFirstChild,
  getDocument,
  getFirstFocusable,
  getId,
  getLastFocusable,
  getNativeProps,
  getPropsWithDefaults,
  getRTL,
  getWindow,
  hoistStatics,
  initializeComponentRef,
  isIOS,
  isMac,
  memoizeFunction,
  mergeAriaAttributeValues,
  mergeStyleSets,
  mergeStyles,
  nullRender,
  portalContainsElement,
  setFocusVisibility,
  shallowCompare,
  shouldWrapFocus,
  styled,
  useAsync,
  useConst,
  useId,
  useIsomorphicLayoutEffect,
  useMergedRefs,
  useOnEvent,
  usePrevious,
  useTarget,
  useWarnings,
  useWindow,
  warn,
  warnConditionallyRequiredProps,
  warnDeprecations
} from "./chunk-T5LOAC42.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@fluentui/react/lib/components/CommandBar/CommandBar.styles.js
var COMMAND_BAR_HEIGHT = 44;
var getStyles = function(props) {
  var className = props.className, theme = props.theme;
  var semanticColors = theme.semanticColors;
  return {
    root: [
      theme.fonts.medium,
      "ms-CommandBar",
      {
        display: "flex",
        backgroundColor: semanticColors.bodyBackground,
        padding: "0 14px 0 24px",
        height: COMMAND_BAR_HEIGHT
      },
      className
    ],
    primarySet: [
      "ms-CommandBar-primaryCommand",
      {
        flexGrow: "1",
        display: "flex",
        alignItems: "stretch"
      }
    ],
    secondarySet: [
      "ms-CommandBar-secondaryCommand",
      {
        flexShrink: "0",
        display: "flex",
        alignItems: "stretch"
      }
    ]
  };
};
var getCommandButtonStyles = memoizeFunction(function(customStyles) {
  var rootStyles = {
    height: "100%"
  };
  var labelStyles = {
    whiteSpace: "nowrap"
  };
  var _a = customStyles || {}, root = _a.root, label = _a.label, restCustomStyles = __rest(_a, ["root", "label"]);
  return __assign(__assign({}, restCustomStyles), { root: root ? [rootStyles, root] : rootStyles, label: label ? [labelStyles, label] : labelStyles });
});

// node_modules/@fluentui/react/lib/components/CommandBar/CommandBar.base.js
var React26 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowSet.base.js
var React2 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowButton.js
var React = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConstants.js
var KTP_PREFIX = "ktp";
var KTP_SEPARATOR = "-";
var KTP_FULL_PREFIX = KTP_PREFIX + KTP_SEPARATOR;
var DATAKTP_TARGET = "data-ktp-target";
var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
var DATAKTP_ARIA_TARGET = "data-ktp-aria-target";
var KTP_LAYER_ID = "ktp-layer-id";
var KTP_ARIA_SEPARATOR = ", ";
var KeytipEvents;
(function(KeytipEvents2) {
  KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
  KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
  KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
  KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
  KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
  KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
  KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
  KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
})(KeytipEvents || (KeytipEvents = {}));

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipManager.js
var KeytipManager = (
  /** @class */
  function() {
    function KeytipManager2() {
      this.keytips = {};
      this.persistedKeytips = {};
      this.sequenceMapping = {};
      this.inKeytipMode = false;
      this.shouldEnterKeytipMode = true;
      this.delayUpdatingKeytipChange = false;
    }
    KeytipManager2.getInstance = function() {
      return this._instance;
    };
    KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
      this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
    };
    KeytipManager2.prototype.register = function(keytipProps, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      var props = keytipProps;
      if (!persisted) {
        props = this.addParentOverflow(keytipProps);
        this.sequenceMapping[props.keySequences.toString()] = props;
      }
      var uniqueKeytip = this._getUniqueKtp(props);
      persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
        EventGroup.raise(this, event_1, {
          keytip: props,
          uniqueID: uniqueKeytip.uniqueID
        });
      }
      return uniqueKeytip.uniqueID;
    };
    KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
      var newKeytipProps = this.addParentOverflow(keytipProps);
      var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
      var oldKeyTip = this.keytips[uniqueID];
      if (oldKeyTip) {
        uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
        this.keytips[uniqueID] = uniqueKeytip;
        delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
        this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
        if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
          EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
            keytip: uniqueKeytip.keytip,
            uniqueID: uniqueKeytip.uniqueID
          });
        }
      }
    };
    KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
      !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
      var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        EventGroup.raise(this, event, {
          keytip: keytipToRemove,
          uniqueID
        });
      }
    };
    KeytipManager2.prototype.enterKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
    };
    KeytipManager2.prototype.exitKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
    };
    KeytipManager2.prototype.getKeytips = function() {
      var _this = this;
      return Object.keys(this.keytips).map(function(key) {
        return _this.keytips[key].keytip;
      });
    };
    KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
      var fullSequence = __spreadArray([], keytipProps.keySequences, true);
      fullSequence.pop();
      if (fullSequence.length !== 0) {
        var parentKeytip = this.sequenceMapping[fullSequence.toString()];
        if (parentKeytip && parentKeytip.overflowSetSequence) {
          return __assign(__assign({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
        }
      }
      return keytipProps;
    };
    KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
      EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
        overflowButtonSequences,
        keytipSequences
      });
    };
    KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
      if (uniqueID === void 0) {
        uniqueID = getId();
      }
      return { keytip: __assign({}, keytipProps), uniqueID };
    };
    KeytipManager2._instance = new KeytipManager2();
    return KeytipManager2;
  }()
);

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowButton.js
var registerPersistedKeytips = function(keytipsToRegister, keytipManager, registeredPersistedKeytips) {
  for (var _i = 0, keytipsToRegister_1 = keytipsToRegister; _i < keytipsToRegister_1.length; _i++) {
    var keytip = keytipsToRegister_1[_i];
    var uniqueID = keytipManager.register(keytip, true);
    registeredPersistedKeytips[uniqueID] = keytip;
  }
};
var unregisterPersistedKeytips = function(keytipManager, registeredPersistedKeytips) {
  for (var _i = 0, _a = Object.keys(registeredPersistedKeytips); _i < _a.length; _i++) {
    var uniqueID = _a[_i];
    keytipManager.unregister(registeredPersistedKeytips[uniqueID], uniqueID, true);
    delete registeredPersistedKeytips[uniqueID];
  }
};
var useKeytipRegistrations = function(registeredPersistedKeytips, keytipsToRegister, keytipManager) {
  var prevPersistedKeytips = usePrevious(registeredPersistedKeytips);
  React.useEffect(function() {
    if (prevPersistedKeytips) {
      unregisterPersistedKeytips(keytipManager, prevPersistedKeytips);
      registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
    }
  });
  React.useEffect(function() {
    registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
    return function() {
      unregisterPersistedKeytips(keytipManager, registeredPersistedKeytips);
    };
  }, []);
};
var OverflowButton = function(props) {
  var keytipManager = KeytipManager.getInstance();
  var className = props.className, overflowItems = props.overflowItems, keytipSequences = props.keytipSequences, itemSubMenuProvider = props.itemSubMenuProvider, onRenderOverflowButton = props.onRenderOverflowButton;
  var persistedKeytips = useConst({});
  var getSubMenuForItem = React.useCallback(function(item) {
    if (itemSubMenuProvider) {
      return itemSubMenuProvider(item);
    }
    if (item.subMenuProps) {
      return item.subMenuProps.items;
    }
    return void 0;
  }, [itemSubMenuProvider]);
  var _a = React.useMemo(function() {
    var newKeytipsToRegister = [];
    var newOverflowItems = [];
    if (keytipSequences) {
      overflowItems === null || overflowItems === void 0 ? void 0 : overflowItems.forEach(function(overflowItem) {
        var _a2;
        var keytip = overflowItem.keytipProps;
        if (keytip) {
          var persistedKeytip = {
            content: keytip.content,
            keySequences: keytip.keySequences,
            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),
            hasDynamicChildren: keytip.hasDynamicChildren,
            hasMenu: keytip.hasMenu
          };
          if (keytip.hasDynamicChildren || getSubMenuForItem(overflowItem)) {
            persistedKeytip.onExecute = keytipManager.menuExecute.bind(keytipManager, keytipSequences, (_a2 = overflowItem === null || overflowItem === void 0 ? void 0 : overflowItem.keytipProps) === null || _a2 === void 0 ? void 0 : _a2.keySequences);
            persistedKeytip.hasOverflowSubMenu = true;
          } else {
            persistedKeytip.onExecute = keytip.onExecute;
          }
          newKeytipsToRegister.push(persistedKeytip);
          var newOverflowItem = __assign(__assign({}, overflowItem), { keytipProps: __assign(__assign({}, keytip), { overflowSetSequence: keytipSequences }) });
          newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(newOverflowItem);
        } else {
          newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(overflowItem);
        }
      });
    } else {
      newOverflowItems = overflowItems;
    }
    return { modifiedOverflowItems: newOverflowItems, keytipsToRegister: newKeytipsToRegister };
  }, [overflowItems, getSubMenuForItem, keytipManager, keytipSequences]), modifiedOverflowItems = _a.modifiedOverflowItems, keytipsToRegister = _a.keytipsToRegister;
  useKeytipRegistrations(persistedKeytips, keytipsToRegister, keytipManager);
  return React.createElement("div", { className }, onRenderOverflowButton(modifiedOverflowItems));
};

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowSet.base.js
var getClassNames = classNamesFunction();
var COMPONENT_NAME = "OverflowSet";
var useComponentRef = function(props, divContainer) {
  React2.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function(_forceIntoFirstElement, bypassHiddenElements) {
        var focusSucceeded = false;
        if (divContainer.current) {
          focusSucceeded = focusFirstChild(divContainer.current, bypassHiddenElements);
        }
        return focusSucceeded;
      },
      focusElement: function(childElement) {
        var focusSucceeded = false;
        if (!childElement) {
          return false;
        }
        if (divContainer.current && elementContains(divContainer.current, childElement)) {
          childElement.focus();
          focusSucceeded = document.activeElement === childElement;
        }
        return focusSucceeded;
      }
    };
  }, [divContainer]);
};
var OverflowSetBase = React2.forwardRef(function(props, forwardedRef) {
  var divContainer = React2.useRef(null);
  var mergedRef = useMergedRefs(divContainer, forwardedRef);
  useComponentRef(props, divContainer);
  var items = props.items, overflowItems = props.overflowItems, className = props.className, styles = props.styles, vertical = props.vertical, role = props.role, _a = props.overflowSide, overflowSide = _a === void 0 ? "end" : _a, onRenderItem = props.onRenderItem;
  var classNames = getClassNames(styles, { className, vertical });
  var showOverflow = !!overflowItems && overflowItems.length > 0;
  return React2.createElement(
    "div",
    __assign({}, getNativeProps(props, divProperties), { role: role || "group", "aria-orientation": role === "menubar" ? vertical === true ? "vertical" : "horizontal" : void 0, className: classNames.root, ref: mergedRef }),
    overflowSide === "start" && showOverflow && React2.createElement(OverflowButton, __assign({}, props, { className: classNames.overflowButton })),
    items && items.map(function(item, i) {
      return React2.createElement("div", { className: classNames.item, key: item.key, role: "none" }, onRenderItem(item));
    }),
    overflowSide === "end" && showOverflow && React2.createElement(OverflowButton, __assign({}, props, { className: classNames.overflowButton }))
  );
});
OverflowSetBase.displayName = COMPONENT_NAME;

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowSet.styles.js
var overflowItemStyle = {
  flexShrink: 0,
  display: "inherit"
};
var getStyles2 = function(props) {
  var className = props.className, vertical = props.vertical;
  return {
    root: [
      "ms-OverflowSet",
      {
        position: "relative",
        display: "flex",
        flexWrap: "nowrap"
      },
      vertical && { flexDirection: "column" },
      className
    ],
    item: ["ms-OverflowSet-item", overflowItemStyle],
    overflowButton: ["ms-OverflowSet-overflowButton", overflowItemStyle]
  };
};

// node_modules/@fluentui/react/lib/components/OverflowSet/OverflowSet.js
var OverflowSet = styled(OverflowSetBase, getStyles2, void 0, {
  scope: "OverflowSet"
});

// node_modules/@fluentui/react/lib/components/ResizeGroup/ResizeGroup.base.js
var React3 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ResizeGroup/ResizeGroup.types.js
var ResizeGroupDirection;
(function(ResizeGroupDirection2) {
  ResizeGroupDirection2[ResizeGroupDirection2["horizontal"] = 0] = "horizontal";
  ResizeGroupDirection2[ResizeGroupDirection2["vertical"] = 1] = "vertical";
})(ResizeGroupDirection || (ResizeGroupDirection = {}));

// node_modules/@fluentui/react/lib/components/ResizeGroup/ResizeGroup.base.js
var RESIZE_DELAY = 16;
var getMeasurementCache = function() {
  var measurementsCache = {};
  return {
    /**
     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a
     * corresponding entry in the measurementsCache, then it will return that value.
     * Returns undefined otherwise.
     */
    getCachedMeasurement: function(data) {
      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {
        return measurementsCache[data.cacheKey];
      }
      return void 0;
    },
    /**
     * Should be called whenever there is a new measurement associated with a given data object.
     * If the data has a cacheKey, store that measurement in the measurementsCache.
     */
    addMeasurementToCache: function(data, measurement) {
      if (data.cacheKey) {
        measurementsCache[data.cacheKey] = measurement;
      }
    }
  };
};
var getNextResizeGroupStateProvider = function(measurementCache) {
  if (measurementCache === void 0) {
    measurementCache = getMeasurementCache();
  }
  var _measurementCache = measurementCache;
  var _containerDimension;
  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {
    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);
    if (cachedDimension !== void 0) {
      return cachedDimension;
    }
    var measuredDimension = getElementToMeasureDimension();
    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);
    return measuredDimension;
  }
  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {
    var dataToMeasure = data;
    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
    while (measuredDimension > _containerDimension) {
      var nextMeasuredData = onReduceData(dataToMeasure);
      if (nextMeasuredData === void 0) {
        return {
          renderedData: dataToMeasure,
          resizeDirection: void 0,
          dataToMeasure: void 0
        };
      }
      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
      if (measuredDimension === void 0) {
        return {
          dataToMeasure: nextMeasuredData,
          resizeDirection: "shrink"
        };
      }
      dataToMeasure = nextMeasuredData;
    }
    return {
      renderedData: dataToMeasure,
      resizeDirection: void 0,
      dataToMeasure: void 0
    };
  }
  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {
    var dataToMeasure = data;
    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
    while (measuredDimension < _containerDimension) {
      var nextMeasuredData = onGrowData(dataToMeasure);
      if (nextMeasuredData === void 0) {
        return {
          renderedData: dataToMeasure,
          resizeDirection: void 0,
          dataToMeasure: void 0
        };
      }
      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
      if (measuredDimension === void 0) {
        return {
          dataToMeasure: nextMeasuredData
        };
      }
      dataToMeasure = nextMeasuredData;
    }
    return __assign({ resizeDirection: "shrink" }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));
  }
  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {
    var nextState;
    if (newDimension > _containerDimension) {
      if (onGrowData) {
        nextState = {
          resizeDirection: "grow",
          dataToMeasure: onGrowData(renderedData)
        };
      } else {
        nextState = {
          resizeDirection: "shrink",
          dataToMeasure: fullDimensionData
        };
      }
    } else {
      nextState = {
        resizeDirection: "shrink",
        dataToMeasure: renderedData
      };
    }
    _containerDimension = newDimension;
    return __assign(__assign({}, nextState), { measureContainer: false });
  }
  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {
    if (newContainerDimension === void 0 && currentState.dataToMeasure === void 0) {
      return void 0;
    }
    if (newContainerDimension) {
      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {
        return __assign(__assign({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));
      }
      _containerDimension = newContainerDimension;
    }
    var nextState = __assign(__assign({}, currentState), { measureContainer: false });
    if (currentState.dataToMeasure) {
      if (currentState.resizeDirection === "grow" && props.onGrowData) {
        nextState = __assign(__assign({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));
      } else {
        nextState = __assign(__assign({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));
      }
    }
    return nextState;
  }
  function shouldRenderDataForMeasurement(dataToMeasure) {
    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== void 0) {
      return false;
    }
    return true;
  }
  function getInitialResizeGroupState(data) {
    return {
      dataToMeasure: __assign({}, data),
      resizeDirection: "grow",
      measureContainer: true
    };
  }
  return {
    getNextState,
    shouldRenderDataForMeasurement,
    getInitialResizeGroupState
  };
};
var MeasuredContext = React3.createContext({ isMeasured: false });
var hiddenDivStyles = { position: "fixed", visibility: "hidden" };
var hiddenParentStyles = { position: "relative" };
var COMPONENT_NAME2 = "ResizeGroup";
function resizeDataReducer(state, action) {
  var _a;
  switch (action.type) {
    case "resizeData":
      return __assign({}, action.value);
    case "dataToMeasure":
      return __assign(__assign({}, state), { dataToMeasure: action.value, resizeDirection: "grow", measureContainer: true });
    default:
      return __assign(__assign({}, state), (_a = {}, _a[action.type] = action.value, _a));
  }
}
function useResizeState(props, nextResizeGroupStateProvider, rootRef) {
  var initialStateData = useConst(function() {
    return nextResizeGroupStateProvider.getInitialResizeGroupState(props.data);
  });
  var _a = React3.useReducer(resizeDataReducer, initialStateData), resizeData = _a[0], dispatchResizeDataAction = _a[1];
  React3.useEffect(function() {
    dispatchResizeDataAction({
      type: "dataToMeasure",
      value: props.data
    });
  }, [props.data]);
  var stateRef = React3.useRef(initialStateData);
  stateRef.current = __assign({}, resizeData);
  var updateResizeState = React3.useCallback(function(nextState) {
    if (nextState) {
      dispatchResizeDataAction({
        type: "resizeData",
        value: nextState
      });
    }
  }, []);
  var remeasure = React3.useCallback(function() {
    if (rootRef.current) {
      dispatchResizeDataAction({
        type: "measureContainer",
        value: true
      });
    }
  }, [rootRef]);
  return [stateRef, updateResizeState, remeasure];
}
function useResizingBehavior(props, rootRef) {
  var nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);
  var initialHiddenDiv = React3.useRef(null);
  var updateHiddenDiv = React3.useRef(null);
  var hasRenderedContent = React3.useRef(false);
  var async = useAsync();
  var _a = useResizeState(props, nextResizeGroupStateProvider, rootRef), stateRef = _a[0], updateResizeState = _a[1], remeasure = _a[2];
  React3.useEffect(function() {
    var _a2;
    if (stateRef.current.renderedData) {
      hasRenderedContent.current = true;
      (_a2 = props.dataDidRender) === null || _a2 === void 0 ? void 0 : _a2.call(props, stateRef.current.renderedData);
    }
  });
  React3.useEffect(function() {
    async.requestAnimationFrame(function() {
      var containerDimension = void 0;
      if (stateRef.current.measureContainer && rootRef.current) {
        var boundingRect = rootRef.current.getBoundingClientRect();
        containerDimension = props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;
      }
      var nextState = nextResizeGroupStateProvider.getNextState(props, stateRef.current, function() {
        var refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;
        if (!refToMeasure.current) {
          return 0;
        }
        var measuredBoundingRect = refToMeasure.current.getBoundingClientRect();
        return props.direction === ResizeGroupDirection.vertical ? measuredBoundingRect.height : measuredBoundingRect.width;
      }, containerDimension);
      updateResizeState(nextState);
    }, rootRef.current);
  });
  var win = useWindow();
  useOnEvent(win, "resize", async.debounce(remeasure, RESIZE_DELAY, { leading: true }));
  var dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(stateRef.current.dataToMeasure);
  var isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;
  return [
    stateRef.current.dataToMeasure,
    stateRef.current.renderedData,
    remeasure,
    initialHiddenDiv,
    updateHiddenDiv,
    dataNeedsMeasuring,
    isInitialMeasure
  ];
}
function useDebugWarnings(props) {
  if (true) {
    useWarnings({
      name: COMPONENT_NAME2,
      props,
      deprecations: { styles: "className" }
    });
  }
}
var measuredContextValue = { isMeasured: true };
var ResizeGroupBase = React3.forwardRef(function(props, forwardedRef) {
  var rootRef = React3.useRef(null);
  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);
  var _a = useResizingBehavior(props, rootRef), dataToMeasure = _a[0], renderedData = _a[1], remeasure = _a[2], initialHiddenDiv = _a[3], updateHiddenDiv = _a[4], dataNeedsMeasuring = _a[5], isInitialMeasure = _a[6];
  React3.useImperativeHandle(props.componentRef, function() {
    return { remeasure };
  }, [remeasure]);
  useDebugWarnings(props);
  var className = props.className, onRenderData = props.onRenderData;
  var divProps = getNativeProps(props, divProperties, ["data"]);
  return React3.createElement(
    "div",
    __assign({}, divProps, { className, ref: mergedRootRef }),
    React3.createElement(
      "div",
      { style: hiddenParentStyles },
      dataNeedsMeasuring && !isInitialMeasure && React3.createElement(
        "div",
        { style: hiddenDivStyles, ref: updateHiddenDiv },
        React3.createElement(MeasuredContext.Provider, { value: measuredContextValue }, onRenderData(dataToMeasure))
      ),
      React3.createElement("div", { ref: initialHiddenDiv, style: isInitialMeasure ? hiddenDivStyles : void 0, "data-automation-id": "visibleContent" }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))
    )
  );
});
ResizeGroupBase.displayName = "ResizeGroupBase";

// node_modules/@fluentui/react/lib/components/ResizeGroup/ResizeGroup.js
var ResizeGroup = ResizeGroupBase;

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var React17 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
var React16 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var React15 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.types.js
var ContextualMenuItemType;
(function(ContextualMenuItemType2) {
  ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
  ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
  ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
  ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));

// node_modules/@fluentui/react/lib/utilities/contextualMenu/contextualMenuUtility.js
function getIsChecked(item) {
  if (item.canCheck) {
    return !!(item.isChecked || item.checked);
  }
  if (typeof item.isChecked === "boolean") {
    return item.isChecked;
  }
  if (typeof item.checked === "boolean") {
    return item.checked;
  }
  return null;
}
function hasSubmenu(item) {
  return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
  return !!(item.isDisabled || item.disabled);
}
function getMenuItemAriaRole(item) {
  var isChecked = getIsChecked(item);
  var canCheck = isChecked !== null;
  return canCheck ? "menuitemcheckbox" : "menuitem";
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.base.js
var React4 = __toESM(require_react());
var defaultIconRenderer = function(props) {
  var item = props.item, classNames = props.classNames;
  var iconProps = item.iconProps;
  return React4.createElement(Icon, __assign({}, iconProps, { className: classNames.icon }));
};
var renderItemIcon = function(props) {
  var item = props.item, hasIcons = props.hasIcons;
  if (!hasIcons) {
    return null;
  }
  if (item.onRenderIcon) {
    return item.onRenderIcon(props, defaultIconRenderer);
  }
  return defaultIconRenderer(props);
};
var renderCheckMarkIcon = function(_a) {
  var onCheckmarkClick = _a.onCheckmarkClick, item = _a.item, classNames = _a.classNames;
  var isItemChecked = getIsChecked(item);
  if (onCheckmarkClick) {
    var onClick = function(e) {
      return onCheckmarkClick(item, e);
    };
    return React4.createElement(Icon, {
      iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
      className: classNames.checkmarkIcon,
      // eslint-disable-next-line react/jsx-no-bind
      onClick
    });
  }
  return null;
};
var renderItemName = function(_a) {
  var item = _a.item, classNames = _a.classNames;
  if (item.text || item.name) {
    return React4.createElement("span", { className: classNames.label }, item.text || item.name);
  }
  return null;
};
var renderSecondaryText = function(_a) {
  var item = _a.item, classNames = _a.classNames;
  if (item.secondaryText) {
    return React4.createElement("span", { className: classNames.secondaryText }, item.secondaryText);
  }
  return null;
};
var renderSubMenuIcon = function(_a) {
  var item = _a.item, classNames = _a.classNames, theme = _a.theme;
  if (hasSubmenu(item)) {
    return React4.createElement(Icon, __assign({ iconName: getRTL(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames.subMenuIcon }));
  }
  return null;
};
var ContextualMenuItemBase = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemBase2, _super);
    function ContextualMenuItemBase2(props) {
      var _this = _super.call(this, props) || this;
      _this.openSubMenu = function() {
        var _a = _this.props, item = _a.item, openSubMenu = _a.openSubMenu, getSubmenuTarget = _a.getSubmenuTarget;
        if (getSubmenuTarget) {
          var submenuTarget = getSubmenuTarget();
          if (hasSubmenu(item) && openSubMenu && submenuTarget) {
            openSubMenu(item, submenuTarget);
          }
        }
      };
      _this.dismissSubMenu = function() {
        var _a = _this.props, item = _a.item, dismissSubMenu = _a.dismissSubMenu;
        if (hasSubmenu(item) && dismissSubMenu) {
          dismissSubMenu();
        }
      };
      _this.dismissMenu = function(dismissAll) {
        var dismissMenu = _this.props.dismissMenu;
        if (dismissMenu) {
          dismissMenu(void 0, dismissAll);
        }
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemBase2.prototype.render = function() {
      var _a = this.props, item = _a.item, classNames = _a.classNames;
      var renderContent = item.onRenderContent || this._renderLayout;
      return React4.createElement("div", { className: item.split ? classNames.linkContentMenu : classNames.linkContent }, renderContent(this.props, {
        renderCheckMarkIcon,
        renderItemIcon,
        renderItemName,
        renderSecondaryText,
        renderSubMenuIcon
      }));
    };
    ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
      return React4.createElement(
        React4.Fragment,
        null,
        defaultRenders.renderCheckMarkIcon(props),
        defaultRenders.renderItemIcon(props),
        defaultRenders.renderItemName(props),
        defaultRenders.renderSecondaryText(props),
        defaultRenders.renderSubMenuIcon(props)
      );
    };
    return ContextualMenuItemBase2;
  }(React4.Component)
);

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.classNames.js
var getDividerClassNames = memoizeFunction(
  // eslint-disable-next-line deprecation/deprecation
  function(theme) {
    return mergeStyleSets({
      wrapper: {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      divider: {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    });
  }
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.cnstyles.js
var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
var getMenuItemStyles = memoizeFunction(function(theme) {
  var _a, _b, _c, _d, _e;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
  var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
  var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
  var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
  var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
  var menuItemStyles = {
    item: [
      fonts.medium,
      {
        color: semanticColors.bodyText,
        position: "relative",
        boxSizing: "border-box"
      }
    ],
    divider: {
      display: "block",
      height: "1px",
      backgroundColor: ContextualMenuItemDividerColor,
      position: "relative"
    },
    root: [
      getFocusStyle(theme),
      fonts.medium,
      {
        color: semanticColors.bodyText,
        backgroundColor: "transparent",
        border: "none",
        width: "100%",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        display: "block",
        cursor: "pointer",
        padding: "0px 8px 0 4px",
        textAlign: "left"
      }
    ],
    rootDisabled: {
      color: semanticColors.disabledBodyText,
      cursor: "default",
      pointerEvents: "none",
      selectors: (_a = {}, _a[HighContrastSelector] = {
        // ensure disabled text looks different than enabled
        color: "GrayText",
        opacity: 1
      }, _a)
    },
    rootHovered: {
      backgroundColor: ContextualMenuItemBackgroundHoverColor,
      color: ContextualMenuItemTextHoverColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDarkAlt
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootFocused: {
      backgroundColor: palette.white
    },
    rootChecked: {
      selectors: {
        ".ms-ContextualMenu-checkmarkIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootPressed: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDark
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootExpanded: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      color: semanticColors.bodyTextChecked,
      selectors: (_b = {
        ".ms-ContextualMenu-submenuIcon": (_c = {}, _c[HighContrastSelector] = {
          // icons inside of anchor tags are not properly inheriting color in high contrast
          color: "inherit"
        }, _c)
      }, _b[HighContrastSelector] = __assign({}, getHighContrastNoAdjustStyle()), _b)
    },
    linkContent: {
      whiteSpace: "nowrap",
      height: "inherit",
      display: "flex",
      alignItems: "center",
      maxWidth: "100%"
    },
    anchorLink: {
      padding: "0px 8px 0 4px",
      textRendering: "auto",
      color: "inherit",
      letterSpacing: "normal",
      wordSpacing: "normal",
      textTransform: "none",
      textIndent: "0px",
      textShadow: "none",
      textDecoration: "none",
      boxSizing: "border-box"
    },
    label: {
      margin: "0 4px",
      verticalAlign: "middle",
      display: "inline-block",
      flexGrow: "1",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    secondaryText: {
      color: theme.palette.neutralSecondary,
      paddingLeft: "20px",
      textAlign: "right"
    },
    icon: {
      display: "inline-block",
      minHeight: "1px",
      maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      fontSize: IconFontSizes.medium,
      width: IconFontSizes.medium,
      margin: "0 4px",
      verticalAlign: "middle",
      flexShrink: "0",
      selectors: (_d = {}, _d[MediumScreenSelector] = {
        fontSize: IconFontSizes.large,
        width: IconFontSizes.large
      }, _d)
    },
    iconColor: {
      color: semanticColors.menuIcon
    },
    iconDisabled: {
      color: semanticColors.disabledBodyText
    },
    checkmarkIcon: {
      color: semanticColors.bodySubtext
    },
    subMenuIcon: {
      height: CONTEXTUAL_MENU_ITEM_HEIGHT,
      lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      color: palette.neutralSecondary,
      textAlign: "center",
      display: "inline-block",
      verticalAlign: "middle",
      flexShrink: "0",
      fontSize: IconFontSizes.small,
      selectors: (_e = {
        ":hover": {
          color: palette.neutralPrimary
        },
        ":active": {
          color: palette.neutralPrimary
        }
      }, _e[MediumScreenSelector] = {
        fontSize: IconFontSizes.medium
        // 16px
      }, _e)
    },
    splitButtonFlexContainer: [
      getFocusStyle(theme),
      {
        display: "flex",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        flexWrap: "nowrap",
        justifyContent: "center",
        alignItems: "flex-start"
      }
    ]
  };
  return concatStyleSets(menuItemStyles);
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.classNames.js
var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
var MediumScreenSelector2 = getScreenSelector(0, ScreenWidthMaxMedium);
var getSplitButtonVerticalDividerClassNames = memoizeFunction(
  /* eslint-disable deprecation/deprecation */
  function(theme) {
    var _a;
    return mergeStyleSets(getDividerClassNames(theme), {
      /* eslint-enable deprecation/deprecation */
      wrapper: {
        position: "absolute",
        right: 28,
        selectors: (_a = {}, _a[MediumScreenSelector2] = {
          right: 32
          // fontSize of the icon increased from 12px to 16px
        }, _a)
      },
      divider: {
        height: 16,
        width: 1
      }
    });
  }
);
var GlobalClassNames = {
  item: "ms-ContextualMenu-item",
  divider: "ms-ContextualMenu-divider",
  root: "ms-ContextualMenu-link",
  isChecked: "is-checked",
  isExpanded: "is-expanded",
  isDisabled: "is-disabled",
  linkContent: "ms-ContextualMenu-linkContent",
  linkContentMenu: "ms-ContextualMenu-linkContent",
  icon: "ms-ContextualMenu-icon",
  iconColor: "ms-ContextualMenu-iconColor",
  checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
  subMenuIcon: "ms-ContextualMenu-submenuIcon",
  label: "ms-ContextualMenu-itemText",
  secondaryText: "ms-ContextualMenu-secondaryText",
  splitMenu: "ms-ContextualMenu-splitMenu",
  screenReaderText: "ms-ContextualMenu-screenReaderText"
};
var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
  var _a, _b, _c, _d;
  var styles = getMenuItemStyles(theme);
  var classNames = getGlobalClassNames(GlobalClassNames, theme);
  return mergeStyleSets({
    item: [classNames.item, styles.item, itemClassName],
    divider: [classNames.divider, styles.divider, dividerClassName],
    root: [
      classNames.root,
      styles.root,
      checked && [classNames.isChecked, styles.rootChecked],
      isAnchorLink && styles.anchorLink,
      expanded && [classNames.isExpanded, styles.rootExpanded],
      disabled && [classNames.isDisabled, styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_a = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _a[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _a[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _a)
        }
      ],
      className
    ],
    splitPrimary: [
      styles.root,
      {
        width: "calc(100% - ".concat(CONTEXTUAL_SPLIT_MENU_MINWIDTH, ")")
      },
      checked && ["is-checked", styles.rootChecked],
      (disabled || primaryDisabled) && ["is-disabled", styles.rootDisabled],
      !(disabled || primaryDisabled) && !checked && [
        {
          selectors: (_b = {
            ":hover": styles.rootHovered
          }, // when hovering over the splitPrimary also affect the splitMenu
          _b[":hover ~ .".concat(classNames.splitMenu)] = styles.rootHovered, _b[":active"] = styles.rootPressed, _b[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _b[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _b)
        }
      ]
    ],
    splitMenu: [
      classNames.splitMenu,
      styles.root,
      {
        flexBasis: "0",
        padding: "0 8px",
        minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
      },
      expanded && ["is-expanded", styles.rootExpanded],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_c = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _c[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _c[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _c)
        }
      ]
    ],
    anchorLink: styles.anchorLink,
    linkContent: [classNames.linkContent, styles.linkContent],
    linkContentMenu: [
      classNames.linkContentMenu,
      styles.linkContent,
      {
        justifyContent: "center"
      }
    ],
    icon: [
      classNames.icon,
      knownIcon && styles.iconColor,
      styles.icon,
      iconClassName,
      disabled && [classNames.isDisabled, styles.iconDisabled]
    ],
    iconColor: styles.iconColor,
    checkmarkIcon: [classNames.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
    subMenuIcon: [
      classNames.subMenuIcon,
      styles.subMenuIcon,
      subMenuClassName,
      expanded && { color: theme.palette.neutralPrimary },
      disabled && [styles.iconDisabled]
    ],
    label: [classNames.label, styles.label],
    secondaryText: [classNames.secondaryText, styles.secondaryText],
    splitContainer: [
      styles.splitButtonFlexContainer,
      !disabled && !checked && [
        {
          selectors: (_d = {}, _d[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _d)
        }
      ]
    ],
    screenReaderText: [
      classNames.screenReaderText,
      styles.screenReaderText,
      hiddenContentStyle,
      { visibility: "hidden" }
    ]
  });
});
var getItemStyles = function(props) {
  var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
  return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.js
var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var React8 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuItemWrapper.js
var React5 = __toESM(require_react());
var ContextualMenuItemWrapper = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemWrapper2, _super);
    function ContextualMenuItemWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this._onItemMouseEnter = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, ev.currentTarget);
        }
      };
      _this._onItemClick = function(ev) {
        var _a = _this.props, item = _a.item, onItemClickBase = _a.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, ev.currentTarget);
        }
      };
      _this._onItemMouseLeave = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseLeave = _a.onItemMouseLeave;
        if (onItemMouseLeave) {
          onItemMouseLeave(item, ev);
        }
      };
      _this._onItemKeyDown = function(ev) {
        var _a = _this.props, item = _a.item, onItemKeyDown = _a.onItemKeyDown;
        if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._onItemMouseMove = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, ev.currentTarget);
        }
      };
      _this._getSubmenuTarget = function() {
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
      return !shallowCompare(newProps, this.props);
    };
    return ContextualMenuItemWrapper2;
  }(React5.Component)
);

// node_modules/@fluentui/react/lib/utilities/keytips/IKeytipTransitionKey.js
function transitionKeysAreEqual(key1, key2) {
  if (key1.key !== key2.key) {
    return false;
  }
  var mod1 = key1.modifierKeys;
  var mod2 = key2.modifierKeys;
  if (!mod1 && mod2 || mod1 && !mod2) {
    return false;
  }
  if (mod1 && mod2) {
    if (mod1.length !== mod2.length) {
      return false;
    }
    mod1 = mod1.sort();
    mod2 = mod2.sort();
    for (var i = 0; i < mod1.length; i++) {
      if (mod1[i] !== mod2[i]) {
        return false;
      }
    }
  }
  return true;
}
function transitionKeysContain(keys, key) {
  return !!find(keys, function(transitionKey) {
    return transitionKeysAreEqual(transitionKey, key);
  });
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConfig.js
function buildKeytipConfigMap(config) {
  var configMap = {};
  for (var _i = 0, _a = config.keytips; _i < _a.length; _i++) {
    var keytip = _a[_i];
    constructKeytip(configMap, [], keytip);
  }
  return configMap;
}
function constructKeytip(configMap, parentSequence, keytip) {
  var sequence = keytip.sequence ? keytip.sequence : keytip.content.toLocaleLowerCase();
  var keytipSequence = parentSequence.concat(sequence);
  var keytipProps = __assign(__assign({}, keytip.optionalProps), { keySequences: keytipSequence, content: keytip.content });
  configMap[keytip.id] = keytipProps;
  if (keytip.children) {
    for (var _i = 0, _a = keytip.children; _i < _a.length; _i++) {
      var child = _a[_i];
      constructKeytip(configMap, keytipSequence, child);
    }
  }
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipUtils.js
function sequencesToID(keySequences) {
  return keySequences.reduce(function(prevValue, keySequence) {
    return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
  }, KTP_PREFIX);
}
function mergeOverflows(keySequences, overflowKeySequences) {
  var overflowSequenceLen = overflowKeySequences.length;
  var overflowSequence = __spreadArray([], overflowKeySequences, true).pop();
  var newKeySequences = __spreadArray([], keySequences, true);
  return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
function ktpTargetFromSequences(keySequences) {
  return "[" + DATAKTP_TARGET + '="' + sequencesToID(keySequences) + '"]';
}
function ktpTargetFromId(keytipId) {
  return "[" + DATAKTP_EXECUTE_TARGET + '="' + keytipId + '"]';
}
function getAriaDescribedBy(keySequences) {
  var describedby = " " + KTP_LAYER_ID;
  if (!keySequences.length) {
    return describedby;
  }
  return describedby + " " + sequencesToID(keySequences);
}

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipData.js
var React6 = __toESM(require_react());
function useKeytipData(options) {
  var uniqueId = React6.useRef();
  var keytipProps = options.keytipProps ? __assign({ disabled: options.disabled }, options.keytipProps) : void 0;
  var keytipManager = useConst(KeytipManager.getInstance());
  var prevOptions = usePrevious(options);
  useIsomorphicLayoutEffect(function() {
    if (uniqueId.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
      keytipManager.update(keytipProps, uniqueId.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (keytipProps) {
      uniqueId.current = keytipManager.register(keytipProps);
    }
    return function() {
      keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
    };
  }, []);
  var nativeKeytipProps = {
    ariaDescribedBy: void 0,
    keytipId: void 0
  };
  if (keytipProps) {
    nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
  }
  return nativeKeytipProps;
}
function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
  var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
  var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
  var keySequences = __spreadArray([], newKeytipProps.keySequences, true);
  if (newKeytipProps.overflowSetSequence) {
    keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
  }
  var keytipId = sequencesToID(keySequences);
  return {
    ariaDescribedBy,
    keytipId
  };
}

// node_modules/@fluentui/react/lib/components/KeytipData/KeytipData.js
var KeytipData = function(props) {
  var _a;
  var children = props.children, keytipDataProps = __rest(props, ["children"]);
  var _b = useKeytipData(keytipDataProps), keytipId = _b.keytipId, ariaDescribedBy = _b.ariaDescribedBy;
  return children((_a = {}, _a[DATAKTP_TARGET] = keytipId, _a[DATAKTP_EXECUTE_TARGET] = keytipId, _a["aria-describedby"] = ariaDescribedBy, _a));
};

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipRef.js
var React7 = __toESM(require_react());
function useKeytipRef(options) {
  var _a = useKeytipData(options), keytipId = _a.keytipId, ariaDescribedBy = _a.ariaDescribedBy;
  var contentRef = React7.useCallback(function(contentElement) {
    if (!contentElement) {
      return;
    }
    var targetElement = findFirstElement(contentElement, DATAKTP_TARGET) || contentElement;
    var executeElement = findFirstElement(contentElement, DATAKTP_EXECUTE_TARGET) || targetElement;
    var ariaElement = findFirstElement(contentElement, DATAKTP_ARIA_TARGET) || executeElement;
    setAttribute(targetElement, DATAKTP_TARGET, keytipId);
    setAttribute(executeElement, DATAKTP_EXECUTE_TARGET, keytipId);
    setAttribute(ariaElement, "aria-describedby", ariaDescribedBy, true);
  }, [keytipId, ariaDescribedBy]);
  return contentRef;
}
function setAttribute(element, attributeName, attributeValue, append) {
  if (append === void 0) {
    append = false;
  }
  if (element && attributeValue) {
    var value = attributeValue;
    if (append) {
      var currentValue = element.getAttribute(attributeName);
      if (currentValue && currentValue.indexOf(attributeValue) === -1) {
        value = "".concat(currentValue, " ").concat(attributeValue);
      }
    }
    element.setAttribute(attributeName, value);
  }
}
function findFirstElement(rootElement, dataAttribute) {
  return rootElement.querySelector("[".concat(dataAttribute, "]"));
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var ContextualMenuAnchor = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuAnchor2, _super);
    function ContextualMenuAnchor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._anchor = React8.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._getSubmenuTarget = function() {
        return _this._anchor.current ? _this._anchor.current : void 0;
      };
      _this._onItemClick = function(ev) {
        var _a = _this.props, item = _a.item, onItemClick = _a.onItemClick;
        if (onItemClick) {
          onItemClick(item, ev);
        }
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React8.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      return _this;
    }
    ContextualMenuAnchor2.prototype.render = function() {
      var _this = this;
      var _a = this.props, item = _a.item, classNames = _a.classNames, index = _a.index, focusableElementIndex = _a.focusableElementIndex, totalItemCount = _a.totalItemCount, hasCheckmarks = _a.hasCheckmarks, hasIcons = _a.hasIcons, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a.expandedMenuItemKey, onItemClick = _a.onItemClick, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
      var anchorRel = item.rel;
      if (item.target && item.target.toLowerCase() === "_blank") {
        anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
      }
      var itemHasSubmenu = hasSubmenu(item);
      var nativeProps = getNativeProps(item, anchorProperties);
      var disabled = isItemDisabled(item);
      var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
      var additionalItemProperties = {
        "aria-describedby": ariaDescribedByIds
      };
      return React8.createElement(
        "div",
        null,
        React8.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
          return React8.createElement(
            "a",
            __assign({}, additionalItemProperties, nativeProps, keytipAttributes, {
              ref: _this._anchor,
              href: item.href,
              target: item.target,
              rel: anchorRel,
              className: classNames.root,
              role: "menuitem",
              "aria-haspopup": itemHasSubmenu || void 0,
              "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
              "aria-posinset": focusableElementIndex + 1,
              "aria-setsize": totalItemCount,
              "aria-disabled": isItemDisabled(item),
              // eslint-disable-next-line deprecation/deprecation
              style: item.style,
              onClick: _this._onItemClick,
              onMouseEnter: _this._onItemMouseEnter,
              onMouseLeave: _this._onItemMouseLeave,
              onMouseMove: _this._onItemMouseMove,
              onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
            }),
            React8.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
            _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
          );
        })
      );
    };
    return ContextualMenuAnchor2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuButton.js
var React9 = __toESM(require_react());
var ContextualMenuButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuButton2, _super);
    function ContextualMenuButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._btn = React9.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React9.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._getSubmenuTarget = function() {
        return _this._btn.current ? _this._btn.current : void 0;
      };
      return _this;
    }
    ContextualMenuButton2.prototype.render = function() {
      var _this = this;
      var _a = this.props, item = _a.item, classNames = _a.classNames, index = _a.index, focusableElementIndex = _a.focusableElementIndex, totalItemCount = _a.totalItemCount, hasCheckmarks = _a.hasCheckmarks, hasIcons = _a.hasIcons, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a.expandedMenuItemKey, onItemMouseDown2 = _a.onItemMouseDown, onItemClick = _a.onItemClick, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
      var isChecked = getIsChecked(item);
      var canCheck = isChecked !== null;
      var defaultRole = getMenuItemAriaRole(item);
      var itemHasSubmenu = hasSubmenu(item);
      var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
      var buttonNativeProperties = getNativeProps(item, buttonProperties);
      delete buttonNativeProperties.disabled;
      var itemRole = item.role || defaultRole;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
      var itemButtonProperties = {
        className: classNames.root,
        onClick: this._onItemClick,
        onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
        onMouseEnter: this._onItemMouseEnter,
        onMouseLeave: this._onItemMouseLeave,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMove,
        href: item.href,
        title: item.title,
        "aria-label": ariaLabel,
        "aria-describedby": ariaDescribedByIds,
        "aria-haspopup": itemHasSubmenu || void 0,
        "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
        "aria-posinset": focusableElementIndex + 1,
        "aria-setsize": totalItemCount,
        "aria-disabled": isItemDisabled(item),
        "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
        "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
        role: itemRole,
        // eslint-disable-next-line deprecation/deprecation
        style: item.style
      };
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      return React9.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React9.createElement(
          "button",
          __assign({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
          React9.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
          _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
        );
      });
    };
    return ContextualMenuButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var React11 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.styles.js
var getStyles3 = function(props) {
  var theme = props.theme, getClassNames5 = props.getClassNames, className = props.className;
  if (!theme) {
    throw new Error("Theme is undefined or null.");
  }
  if (getClassNames5) {
    var names = getClassNames5(theme);
    return {
      wrapper: [names.wrapper],
      divider: [names.divider]
    };
  }
  return {
    wrapper: [
      {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      className
    ],
    divider: [
      {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.base.js
var React10 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var VerticalDividerBase = React10.forwardRef(function(props, ref) {
  var styles = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
  var classNames = getClassNames2(styles, { theme, getClassNames: deprecatedGetClassNames, className });
  return React10.createElement(
    "span",
    { className: classNames.wrapper, ref },
    React10.createElement("span", { className: classNames.divider })
  );
});
VerticalDividerBase.displayName = "VerticalDividerBase";

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.js
var VerticalDivider = styled(VerticalDividerBase, getStyles3, void 0, {
  scope: "VerticalDivider"
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var TouchIdleDelay = 500;
var ContextualMenuSplitButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuSplitButton2, _super);
    function ContextualMenuSplitButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onItemKeyDown = function(ev) {
        var _a = _this.props, item = _a.item, onItemKeyDown = _a.onItemKeyDown;
        if (ev.which === KeyCodes.enter) {
          _this._executeItemClick(ev);
          ev.preventDefault();
          ev.stopPropagation();
        } else if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._getSubmenuTarget = function() {
        return _this._splitButton;
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React11.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._onItemMouseEnterPrimary = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseEnterIcon = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseEnter = _a.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, _this._splitButton);
        }
      };
      _this._onItemMouseMovePrimary = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseMoveIcon = function(ev) {
        var _a = _this.props, item = _a.item, onItemMouseMove = _a.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, _this._splitButton);
        }
      };
      _this._onIconItemClick = function(ev) {
        var _a = _this.props, item = _a.item, onItemClickBase = _a.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
        }
      };
      _this._executeItemClick = function(ev) {
        var _a = _this.props, item = _a.item, executeItemClick = _a.executeItemClick, onItemClick = _a.onItemClick;
        if (item.disabled || item.isDisabled) {
          return;
        }
        if (_this._processingTouch && !item.canCheck && onItemClick) {
          return onItemClick(item, ev);
        }
        if (executeItemClick) {
          executeItemClick(item, ev);
        }
      };
      _this._onTouchStart = function(ev) {
        if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
          _this._handleTouchAndPointerEvent(ev);
        }
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._handleTouchAndPointerEvent(ev);
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      };
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this._dismissLabelId = getId();
      return _this;
    }
    ContextualMenuSplitButton2.prototype.componentDidMount = function() {
      if (this._splitButton && "onpointerdown" in this._splitButton) {
        this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
      }
    };
    ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    ContextualMenuSplitButton2.prototype.render = function() {
      var _this = this;
      var _a;
      var _b = this.props, item = _b.item, classNames = _b.classNames, index = _b.index, focusableElementIndex = _b.focusableElementIndex, totalItemCount = _b.totalItemCount, hasCheckmarks = _b.hasCheckmarks, hasIcons = _b.hasIcons, onItemMouseLeave = _b.onItemMouseLeave, expandedMenuItemKey = _b.expandedMenuItemKey;
      var itemHasSubmenu = hasSubmenu(item);
      var keytipProps = item.keytipProps;
      if (keytipProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var ariaDescription = item.ariaDescription;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaChecked = (_a = getIsChecked(item)) !== null && _a !== void 0 ? _a : void 0;
      return React11.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React11.createElement(
          "div",
          { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
            return _this._splitButton = splitButton;
          }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": ariaChecked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign(__assign({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
          _this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons),
          _this._renderSplitDivider(item),
          _this._renderSplitIconButton(item, classNames, index, keytipAttributes),
          _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
        );
      });
    };
    ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames, index, hasCheckmarks, hasIcons) {
      var _a = this.props, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemClick = _a.onItemClick;
      var itemProps = {
        key: item.key,
        disabled: isItemDisabled(item) || item.primaryDisabled,
        /* eslint-disable deprecation/deprecation */
        name: item.name,
        text: item.text || item.name,
        secondaryText: item.secondaryText,
        /* eslint-enable deprecation/deprecation */
        className: classNames.splitPrimary,
        canCheck: item.canCheck,
        isChecked: item.isChecked,
        checked: item.checked,
        iconProps: item.iconProps,
        id: this._dismissLabelId,
        onRenderIcon: item.onRenderIcon,
        data: item.data,
        "data-is-focusable": false
      };
      var itemComponentProps = item.itemProps;
      return React11.createElement(
        "button",
        __assign({}, getNativeProps(itemProps, buttonProperties)),
        React11.createElement(ChildrenRenderer, __assign({ "data-is-focusable": false, item: itemProps, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
      var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
      return React11.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
    };
    ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames, index, keytipAttributes) {
      var _a = this.props, _b = _a.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemMouseLeave = _a.onItemMouseLeave, onItemMouseDown2 = _a.onItemMouseDown, openSubMenu = _a.openSubMenu, dismissSubMenu = _a.dismissSubMenu, dismissMenu = _a.dismissMenu;
      var itemProps = {
        onClick: this._onIconItemClick,
        disabled: isItemDisabled(item),
        className: classNames.splitMenu,
        subMenuProps: item.subMenuProps,
        submenuIconProps: item.submenuIconProps,
        split: true,
        key: item.key,
        "aria-labelledby": this._dismissLabelId
      };
      var buttonProps = __assign(__assign({}, getNativeProps(itemProps, buttonProperties)), {
        onMouseEnter: this._onItemMouseEnterIcon,
        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMoveIcon,
        "data-is-focusable": false,
        "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
        "aria-haspopup": true
      });
      var itemComponentProps = item.itemProps;
      return React11.createElement(
        "button",
        __assign({}, buttonProps),
        React11.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item: itemProps, classNames, index, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
      var _this = this;
      var onTap = this.props.onTap;
      if (onTap) {
        onTap(ev);
      }
      if (this._lastTouchTimeoutId) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
      }, TouchIdleDelay);
    };
    return ContextualMenuSplitButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var React13 = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var React12 = __toESM(require_react());
var ResponsiveMode;
(function(ResponsiveMode2) {
  ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
  ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
  ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
  ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
  ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
  ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
  ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
})(ResponsiveMode || (ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
var _defaultMode;
var _lastMode;
function setResponsiveMode(responsiveMode) {
  _defaultMode = responsiveMode;
}
function initializeResponsiveMode(element) {
  var currentWindow = getWindow(element);
  if (currentWindow) {
    getResponsiveMode(currentWindow);
  }
}
function getInitialResponsiveMode() {
  var _a;
  return (_a = _defaultMode !== null && _defaultMode !== void 0 ? _defaultMode : _lastMode) !== null && _a !== void 0 ? _a : ResponsiveMode.large;
}
function withResponsiveMode(ComposedComponent) {
  var _a;
  var resultClass = (_a = /** @class */
  function(_super) {
    __extends(WithResponsiveMode, _super);
    function WithResponsiveMode(props) {
      var _this = _super.call(this, props) || this;
      _this._onResize = function() {
        var responsiveMode = getResponsiveMode(_this.context.window);
        if (responsiveMode !== _this.state.responsiveMode) {
          _this.setState({
            responsiveMode
          });
        }
      };
      _this._events = new EventGroup(_this);
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      _this.state = {
        responsiveMode: getInitialResponsiveMode()
      };
      return _this;
    }
    WithResponsiveMode.prototype.componentDidMount = function() {
      this._events.on(this.context.window, "resize", this._onResize);
      this._onResize();
    };
    WithResponsiveMode.prototype.componentWillUnmount = function() {
      this._events.dispose();
    };
    WithResponsiveMode.prototype.render = function() {
      var responsiveMode = this.state.responsiveMode;
      return responsiveMode === ResponsiveMode.unknown ? null : React12.createElement(ComposedComponent, __assign({ ref: this._updateComposedComponentRef, responsiveMode }, this.props));
    };
    return WithResponsiveMode;
  }(BaseDecorator), _a.contextType = WindowContext, _a);
  return hoistStatics(ComposedComponent, resultClass);
}
function getWidthOfCurrentWindow(currentWindow) {
  try {
    return currentWindow.document.documentElement.clientWidth;
  } catch (e) {
    return currentWindow.innerWidth;
  }
}
function getResponsiveMode(currentWindow) {
  var responsiveMode = ResponsiveMode.small;
  if (currentWindow) {
    try {
      while (getWidthOfCurrentWindow(currentWindow) > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
        responsiveMode++;
      }
    } catch (e) {
      responsiveMode = getInitialResponsiveMode();
    }
    _lastMode = responsiveMode;
  } else {
    if (_defaultMode !== void 0) {
      responsiveMode = _defaultMode;
    } else {
      throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
    }
  }
  return responsiveMode;
}

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
  var _a = React13.useState(getInitialResponsiveMode()), lastResponsiveMode = _a[0], setLastResponsiveMode = _a[1];
  var onResize = React13.useCallback(function() {
    var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
    if (lastResponsiveMode !== newResponsiveMode) {
      setLastResponsiveMode(newResponsiveMode);
    }
  }, [elementRef, lastResponsiveMode]);
  var win = useWindow();
  useOnEvent(win, "resize", onResize);
  React13.useEffect(function() {
    if (overrideResponsiveMode === void 0) {
      onResize();
    }
  }, [overrideResponsiveMode]);
  return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
};

// node_modules/@fluentui/react/lib/utilities/MenuContext/MenuContext.js
var React14 = __toESM(require_react());
var MenuContext = React14.createContext({});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var getClassNames3 = classNamesFunction();
var getContextualMenuItemClassNames = classNamesFunction();
var DEFAULT_PROPS = {
  items: [],
  shouldFocusOnMount: true,
  gapSpace: 0,
  directionalHint: DirectionalHint.bottomAutoEdge,
  beakWidth: 16
};
function getItemCount(items) {
  var totalItemCount = 0;
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var item = items_1[_i];
    if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
      var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
      totalItemCount += itemCount;
    }
  }
  return totalItemCount;
}
function getSubmenuItems(item, options) {
  var target = options === null || options === void 0 ? void 0 : options.target;
  var items = item.subMenuProps ? item.subMenuProps.items : item.items;
  if (items) {
    var overrideItems = [];
    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
      var subItem = items_2[_i];
      if (subItem.preferMenuTargetAsEventTarget) {
        var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
        overrideItems.push(__assign(__assign({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
      } else {
        overrideItems.push(subItem);
      }
    }
    return overrideItems;
  }
}
function canAnyMenuItemsCheck(items) {
  return items.some(function(item) {
    if (item.canCheck) {
      return true;
    }
    if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
      return submenuItem.canCheck === true;
    })) {
      return true;
    }
    return false;
  });
}
var NavigationIdleDelay = 250;
var COMPONENT_NAME3 = "ContextualMenu";
var _getMenuItemStylesFunction = memoizeFunction(function() {
  var styles = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styles[_i] = arguments[_i];
  }
  return function(styleProps) {
    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles, false));
  };
});
function useVisibility(props, targetWindow) {
  var _a = props.hidden, hidden = _a === void 0 ? false : _a, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
  var previousHidden = usePrevious(hidden);
  var onMenuOpenedRef = React15.useRef(onMenuOpened);
  var onMenuClosedRef = React15.useRef(onMenuDismissed);
  var propsRef = React15.useRef(props);
  onMenuOpenedRef.current = onMenuOpened;
  onMenuClosedRef.current = onMenuDismissed;
  propsRef.current = props;
  React15.useEffect(function() {
    var _a2, _b;
    if (hidden && previousHidden === false) {
      (_a2 = onMenuClosedRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onMenuClosedRef, propsRef.current);
    } else if (!hidden && previousHidden !== false) {
      (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);
    }
  }, [hidden, previousHidden]);
  React15.useEffect(function() {
    return function() {
      var _a2;
      return (_a2 = onMenuClosedRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onMenuClosedRef, propsRef.current);
    };
  }, []);
}
function useSubMenuState(_a, dismiss) {
  var hidden = _a.hidden, items = _a.items, theme = _a.theme, className = _a.className, id = _a.id, menuTarget = _a.target;
  var _b = React15.useState(), expandedMenuItemKey = _b[0], setExpandedMenuItemKey = _b[1];
  var _c = React15.useState(), submenuTarget = _c[0], setSubmenuTarget = _c[1];
  var _d = React15.useState(), shouldFocusOnContainer = _d[0], setShouldFocusOnContainer = _d[1];
  var subMenuId = useId(COMPONENT_NAME3, id);
  var closeSubMenu = React15.useCallback(function() {
    setShouldFocusOnContainer(void 0);
    setExpandedMenuItemKey(void 0);
    setSubmenuTarget(void 0);
  }, []);
  var openSubMenu = React15.useCallback(function(_a2, target, focusContainer) {
    var submenuItemKey = _a2.key;
    if (expandedMenuItemKey === submenuItemKey) {
      return;
    }
    target.focus();
    setShouldFocusOnContainer(focusContainer);
    setExpandedMenuItemKey(submenuItemKey);
    setSubmenuTarget(target);
  }, [expandedMenuItemKey]);
  React15.useEffect(function() {
    if (hidden) {
      closeSubMenu();
    }
  }, [hidden, closeSubMenu]);
  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
  var getSubmenuProps = function() {
    var item = findItemByKeyFromItems(expandedMenuItemKey, items);
    var submenuProps = null;
    if (item) {
      submenuProps = {
        items: getSubmenuItems(item, { target: menuTarget }),
        target: submenuTarget,
        onDismiss: onSubMenuDismiss,
        isSubMenu: true,
        id: subMenuId,
        shouldFocusOnMount: true,
        shouldFocusOnContainer,
        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
        className,
        gapSpace: 0,
        isBeakVisible: false
      };
      if (item.subMenuProps) {
        assign(submenuProps, item.subMenuProps);
      }
      if (item.preferMenuTargetAsEventTarget) {
        var onItemClick = item.onItemClick;
        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
      }
    }
    return submenuProps;
  };
  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
}
function useShouldUpdateFocusOnMouseMove(_a) {
  var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover, hidden = _a.hidden;
  var shouldUpdateFocusOnMouseEvent = React15.useRef(!delayUpdateFocusOnHover);
  var gotMouseMove = React15.useRef(false);
  React15.useEffect(function() {
    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
  }, [delayUpdateFocusOnHover, hidden]);
  var onMenuFocusCapture = React15.useCallback(function() {
    if (delayUpdateFocusOnHover) {
      shouldUpdateFocusOnMouseEvent.current = false;
    }
  }, [delayUpdateFocusOnHover]);
  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
}
function usePreviousActiveElement(_a, targetWindow, hostElement) {
  var hidden = _a.hidden, onRestoreFocus = _a.onRestoreFocus;
  var previousActiveElement = React15.useRef();
  var tryFocusPreviousActiveElement = React15.useCallback(function(options) {
    var _a2, _b;
    if (onRestoreFocus) {
      onRestoreFocus(options);
    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
      (_b = (_a2 = previousActiveElement.current) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
    }
  }, [onRestoreFocus]);
  useIsomorphicLayoutEffect(function() {
    var _a2, _b;
    if (!hidden) {
      var newElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
      if (!((_a2 = hostElement.current) === null || _a2 === void 0 ? void 0 : _a2.contains(newElement)) && newElement.tagName !== "BODY") {
        previousActiveElement.current = newElement;
      }
    } else if (previousActiveElement.current) {
      tryFocusPreviousActiveElement({
        originalElement: previousActiveElement.current,
        containsFocus: true,
        documentContainsFocus: ((_b = getDocument()) === null || _b === void 0 ? void 0 : _b.hasFocus()) || false
      });
      previousActiveElement.current = void 0;
    }
  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement, hostElement]);
  return [tryFocusPreviousActiveElement];
}
function useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {
  var theme = _a.theme, isSubMenu = _a.isSubMenu, _b = _a.focusZoneProps, _c = _b === void 0 ? {} : _b, checkForNoWrap = _c.checkForNoWrap, _d = _c.direction, focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;
  var lastKeyDownWasAltOrMeta = React15.useRef();
  var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
    var handled = false;
    if (shouldHandleKey(ev)) {
      dismiss(ev, dismissAllMenus);
      ev.preventDefault();
      ev.stopPropagation();
      handled = true;
    }
    return handled;
  };
  var shouldCloseSubMenu = function(ev) {
    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
    if (ev.which !== submenuCloseKey || !isSubMenu) {
      return false;
    }
    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
  };
  var shouldHandleKeyDown = function(ev) {
    return (
      // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)
    );
  };
  var onKeyDown = function(ev) {
    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
  };
  var shouldHandleKeyUp = function(ev) {
    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
    lastKeyDownWasAltOrMeta.current = false;
    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
  };
  var onKeyUp = function(ev) {
    return keyHandler(
      ev,
      shouldHandleKeyUp,
      true
      /* dismissAllMenus */
    );
  };
  var onMenuKeyDown = function(ev) {
    var handled = onKeyDown(ev);
    if (handled || !hostElement.current) {
      return;
    }
    var hasModifier = !!(ev.altKey || ev.metaKey);
    var isUp = ev.which === KeyCodes.up;
    var isDown = ev.which === KeyCodes.down;
    if (!hasModifier && (isUp || isDown)) {
      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
      if (elementToFocus) {
        elementToFocus.focus();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  };
  var onItemKeyDown = function(item, ev) {
    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
    if (!item.disabled && // eslint-disable-next-line deprecation/deprecation
    (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
      openSubMenu(item, ev.currentTarget);
      ev.preventDefault();
    }
  };
  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
}
function useScrollHandler(asyncTracker) {
  var isScrollIdle = React15.useRef(true);
  var scrollIdleTimeoutId = React15.useRef();
  var onScroll = function() {
    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
      scrollIdleTimeoutId.current = void 0;
    } else {
      isScrollIdle.current = false;
    }
    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
      isScrollIdle.current = true;
    }, NavigationIdleDelay);
  };
  return [onScroll, isScrollIdle];
}
function useOnSubmenuDismiss(dismiss, closeSubMenu) {
  var isMountedRef = React15.useRef(false);
  React15.useEffect(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  var onSubMenuDismiss = function(ev, dismissAll) {
    if (dismissAll) {
      dismiss(ev, dismissAll);
    } else if (isMountedRef.current) {
      closeSubMenu();
    }
  };
  return onSubMenuDismiss;
}
function useSubmenuEnterTimer(_a, asyncTracker) {
  var _b = _a.subMenuHoverDelay, subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;
  var enterTimerRef = React15.useRef(void 0);
  var cancelSubMenuTimer = function() {
    if (enterTimerRef.current !== void 0) {
      asyncTracker.clearTimeout(enterTimerRef.current);
      enterTimerRef.current = void 0;
    }
  };
  var startSubmenuTimer = function(onTimerExpired) {
    enterTimerRef.current = asyncTracker.setTimeout(function() {
      onTimerExpired();
      cancelSubMenuTimer();
    }, subMenuHoverDelay);
  };
  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
}
function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
  var menuTarget = props.target;
  var onItemMouseEnterBase = function(item, ev, target) {
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    }
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var onItemMouseMoveBase = function(item, ev, target) {
    var targetElement = ev.currentTarget;
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    } else {
      return;
    }
    if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var shouldIgnoreMouseEvent = function() {
    return !isScrollIdle.current || !gotMouseMove.current;
  };
  var onMouseItemLeave = function(item, ev) {
    var _a;
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey !== void 0) {
      return;
    }
    if (hostElement.current.setActive) {
      try {
        hostElement.current.setActive();
      } catch (e) {
      }
    } else {
      (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  };
  var updateFocusOnMouseEvent = function(item, ev, target) {
    var targetElement = target ? target : ev.currentTarget;
    if (item.key === expandedMenuItemKey) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey === void 0) {
      targetElement.focus();
    }
    if (hasSubmenu(item)) {
      ev.stopPropagation();
      startSubmenuTimer(function() {
        targetElement.focus();
        openSubMenu(item, targetElement, true);
      });
    } else {
      startSubmenuTimer(function() {
        onSubMenuDismiss(ev);
        targetElement.focus();
      });
    }
  };
  var onItemClick = function(item, ev) {
    onItemClickBase(item, ev, ev.currentTarget);
  };
  var onItemClickBase = function(item, ev, target) {
    var items = getSubmenuItems(item, { target: menuTarget });
    cancelSubMenuTimer();
    if (!hasSubmenu(item) && (!items || !items.length)) {
      executeItemClick(item, ev);
    } else {
      if (item.key !== expandedMenuItemKey) {
        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === "boolean" ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        openSubMenu(item, target, shouldFocusOnContainer);
      }
    }
    ev.stopPropagation();
    ev.preventDefault();
  };
  var onAnchorClick = function(item, ev) {
    executeItemClick(item, ev);
    ev.stopPropagation();
  };
  var executeItemClick = function(item, ev) {
    if (item.disabled || item.isDisabled) {
      return;
    }
    if (item.preferMenuTargetAsEventTarget) {
      overrideTarget(ev, menuTarget);
    }
    var shouldDismiss = false;
    if (item.onClick) {
      shouldDismiss = !!item.onClick(ev, item);
    } else if (props.onItemClick) {
      shouldDismiss = !!props.onItemClick(ev, item);
    }
    if (shouldDismiss || !ev.defaultPrevented) {
      dismiss(ev, true);
    }
  };
  return [
    onItemMouseEnterBase,
    onItemMouseMoveBase,
    onMouseItemLeave,
    onItemClick,
    onAnchorClick,
    executeItemClick,
    onItemClickBase
  ];
}
var ContextualMenuBase = React15.memo(React15.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a;
  var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults), ref = _b.ref, props = __rest(_b, ["ref"]);
  var hostElement = React15.useRef(null);
  var asyncTracker = useAsync();
  var menuId = useId(COMPONENT_NAME3, props.id);
  useWarnings({
    name: COMPONENT_NAME3,
    props,
    deprecations: {
      getMenuClassNames: "styles"
    }
  });
  var dismiss = function(ev, dismissAll) {
    var _a2;
    return (_a2 = props.onDismiss) === null || _a2 === void 0 ? void 0 : _a2.call(props, ev, dismissAll);
  };
  var _c = useTarget(props.target, hostElement), targetRef = _c[0], targetWindow = _c[1];
  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow, hostElement)[0];
  var _d = useSubMenuState(props, dismiss), expandedMenuItemKey = _d[0], openSubMenu = _d[1], getSubmenuProps = _d[2], onSubMenuDismiss = _d[3];
  var _e = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e[0], gotMouseMove = _e[1], onMenuFocusCapture = _e[2];
  var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
  var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
  useVisibility(props, targetWindow);
  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
  var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
    var indexCorrection = 0;
    var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
    return React15.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item, index) {
      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
        indexCorrection += indexIncrease;
      }
      return menuItem;
    }));
  };
  var renderFocusZone = function(children, adjustedFocusZoneProps2) {
    var _a2 = props.focusZoneAs, ChildrenRenderer = _a2 === void 0 ? FocusZone : _a2;
    return React15.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps2), children);
  };
  var renderMenuItem = function(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
    var _a2;
    var renderedItems = [];
    var iconProps = item.iconProps || { iconName: "None" };
    var getItemClassNames2 = item.getItemClassNames, itemProps = item.itemProps;
    var styles2 = itemProps ? itemProps.styles : void 0;
    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : void 0;
    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : "";
    var itemClassNames;
    if (getItemClassNames2) {
      itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== "None", item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);
    } else {
      var itemStyleProps = {
        theme: props.theme,
        disabled: isItemDisabled(item),
        expanded: expandedMenuItemKey === item.key,
        checked: !!getIsChecked(item),
        isAnchorLink: !!item.href,
        knownIcon: iconProps.iconName !== "None",
        itemClassName: item.className,
        dividerClassName,
        iconClassName: iconProps.className,
        subMenuClassName: subMenuIconClassName,
        primaryDisabled: item.primaryDisabled
      };
      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a2 = menuClassNames.subComponentStyles) === null || _a2 === void 0 ? void 0 : _a2.menuItem, styles2), itemStyleProps);
    }
    if (item.text === "-" || item.name === "-") {
      item.itemType = ContextualMenuItemType.Divider;
    }
    switch (item.itemType) {
      case ContextualMenuItemType.Divider:
        renderedItems.push(renderSeparator(index, itemClassNames));
        break;
      case ContextualMenuItemType.Header:
        renderedItems.push(renderSeparator(index, itemClassNames));
        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));
        break;
      case ContextualMenuItemType.Section:
        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2));
        break;
      default:
        var defaultRenderNormalItem = function() {
          return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
        };
        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem) : defaultRenderNormalItem();
        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));
        break;
    }
    return React15.createElement(React15.Fragment, { key: item.key }, renderedItems);
  };
  var defaultMenuItemRenderer = function(item, menuClassNames) {
    var index = item.index, focusableElementIndex = item.focusableElementIndex, totalItemCount = item.totalItemCount, hasCheckmarks2 = item.hasCheckmarks, hasIcons2 = item.hasIcons;
    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
  };
  var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var sectionProps = sectionItem.sectionProps;
    if (!sectionProps) {
      return;
    }
    var headerItem;
    var groupProps;
    if (sectionProps.title) {
      var headerContextualMenuItem = void 0;
      var ariaLabelledby = "";
      if (typeof sectionProps.title === "string") {
        var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
        headerContextualMenuItem = {
          key: "section-".concat(sectionProps.title, "-title"),
          itemType: ContextualMenuItemType.Header,
          text: sectionProps.title,
          id: id_1
        };
        ariaLabelledby = id_1;
      } else {
        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), { id: id_2 });
        ariaLabelledby = id_2;
      }
      if (headerContextualMenuItem) {
        groupProps = {
          role: "group",
          "aria-labelledby": ariaLabelledby
        };
        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
      }
    }
    if (sectionProps.items && sectionProps.items.length > 0) {
      var correctedIndex_1 = 0;
      return React15.createElement(
        "li",
        { role: "presentation", key: sectionProps.key || sectionItem.key || "section-".concat(index) },
        React15.createElement(
          "div",
          __assign({}, groupProps),
          React15.createElement(
            "ul",
            { className: menuClassNames.list, role: "presentation" },
            sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true),
            headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title),
            sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
              var menuItem = renderMenuItem(contextualMenuItem, itemsIndex, correctedIndex_1, getItemCount(sectionProps.items), hasCheckmarks2, hasIcons2, menuClassNames);
              if (contextualMenuItem.itemType !== ContextualMenuItemType.Divider && contextualMenuItem.itemType !== ContextualMenuItemType.Header) {
                var indexIncrease = contextualMenuItem.customOnRenderListLength ? contextualMenuItem.customOnRenderListLength : 1;
                correctedIndex_1 += indexIncrease;
              }
              return menuItem;
            }),
            sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)
          )
        )
      );
    }
  };
  var renderListItem = function(content, key, classNames2, title2) {
    return React15.createElement("li", { role: "presentation", title: title2, key, className: classNames2.item }, content);
  };
  var renderSeparator = function(index, classNames2, top, fromSection) {
    if (fromSection || index > 0) {
      return React15.createElement("li", { role: "separator", key: "separator-" + index + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames2.divider, "aria-hidden": "true" });
    }
    return null;
  };
  var renderNormalItem = function(item, classNames2, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
    if (item.onRender) {
      return item.onRender(__assign({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item), dismiss);
    }
    var contextualMenuItemAs = props.contextualMenuItemAs;
    var commonProps = {
      item,
      classNames: classNames2,
      index,
      focusableElementIndex,
      totalItemCount,
      hasCheckmarks: hasCheckmarks2,
      hasIcons: hasIcons2,
      contextualMenuItemAs,
      onItemMouseEnter: onItemMouseEnterBase,
      onItemMouseLeave: onMouseItemLeave,
      onItemMouseMove: onItemMouseMoveBase,
      onItemMouseDown,
      executeItemClick,
      onItemKeyDown,
      expandedMenuItemKey,
      openSubMenu,
      dismissSubMenu: onSubMenuDismiss,
      dismissMenu: dismiss
    };
    if (item.href) {
      return React15.createElement(ContextualMenuAnchor, __assign({}, commonProps, { onItemClick: onAnchorClick }));
    }
    if (item.split && hasSubmenu(item)) {
      return React15.createElement(ContextualMenuSplitButton, __assign({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
    }
    return React15.createElement(ContextualMenuButton, __assign({}, commonProps, { onItemClick, onItemClickBase }));
  };
  var renderHeaderMenuItem = function(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var _a2 = props.contextualMenuItemAs, ChildrenRenderer = _a2 === void 0 ? ContextualMenuItem : _a2;
    var itemProps = item.itemProps, id2 = item.id;
    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
    return (
      // eslint-disable-next-line deprecation/deprecation
      React15.createElement(
        "div",
        __assign({ id: id2, className: menuClassNames.header }, divHtmlProperties, { style: item.style }),
        React15.createElement(ChildrenRenderer, __assign({ item, classNames: itemClassNames, index, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
      )
    );
  };
  var isBeakVisible = props.isBeakVisible;
  var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
    return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);
  } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames3(styles, {
    theme,
    className
  });
  var hasIcons = itemsHaveIcons(items);
  function itemsHaveIcons(contextualMenuItems) {
    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {
      var item = contextualMenuItems_1[_i];
      if (item.iconProps) {
        return true;
      }
      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {
        return true;
      }
    }
    return false;
  }
  var adjustedFocusZoneProps = __assign(__assign({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className) });
  var hasCheckmarks = canAnyMenuItemsCheck(items);
  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
  isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
  var contextMenuStyle;
  var targetAsHtmlElement = targetRef.current;
  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
    var targetWidth = targetBoundingRect.width - 2;
    if (useTargetWidth) {
      contextMenuStyle = {
        width: targetWidth
      };
    } else if (useTargetAsMinWidth) {
      contextMenuStyle = {
        minWidth: targetWidth
      };
    }
  }
  if (items && items.length > 0) {
    var totalItemCount_1 = getItemCount(items);
    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : void 0;
    return React15.createElement(MenuContext.Consumer, null, function(menuContext) {
      return React15.createElement(
        Callout,
        __assign({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget, doNotLayer, className: css("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
        React15.createElement(
          "div",
          { style: contextMenuStyle, ref: hostElement, id, className: classNames.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
          title && React15.createElement(
            "div",
            { className: classNames.title },
            " ",
            title,
            " "
          ),
          items && items.length ? renderFocusZone(onRenderMenuList({
            ariaLabel,
            items,
            totalItemCount: totalItemCount_1,
            hasCheckmarks,
            hasIcons,
            defaultMenuItemRenderer: function(item) {
              return defaultMenuItemRenderer(item, classNames);
            },
            labelElementId
          }, function(menuListProps, defaultRender) {
            return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);
          }), adjustedFocusZoneProps) : null,
          submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
        ),
        React15.createElement(FocusRects, null)
      );
    });
  } else {
    return null;
  }
}), function(prevProps, newProps) {
  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
    return true;
  }
  return shallowCompare(prevProps, newProps);
});
ContextualMenuBase.displayName = "ContextualMenuBase";
function isAltOrMeta(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
function onItemMouseDown(item, ev) {
  var _a;
  (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);
}
function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
  throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
}
function findItemByKeyFromItems(key, items) {
  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
    var item = items_3[_i];
    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
      var match = findItemByKeyFromItems(key, item.sectionProps.items);
      if (match) {
        return match;
      }
    } else if (item.key && item.key === key) {
      return item;
    }
  }
}
function getOnClickWithOverrideTarget(onClick, target) {
  return onClick ? function(ev, item) {
    overrideTarget(ev, target);
    return onClick(ev, item);
  } : onClick;
}
function overrideTarget(ev, target) {
  if (ev && target) {
    ev.persist();
    if (target instanceof Event) {
      ev.target = target.target;
    } else if (target instanceof Element) {
      ev.target = target;
    }
  }
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.styles.js
var GlobalClassNames2 = {
  root: "ms-ContextualMenu",
  container: "ms-ContextualMenu-container",
  list: "ms-ContextualMenu-list",
  header: "ms-ContextualMenu-header",
  title: "ms-ContextualMenu-title",
  isopen: "is-open"
};
var getStyles4 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames = getGlobalClassNames(GlobalClassNames2, theme);
  var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    root: [
      theme.fonts.medium,
      classNames.root,
      classNames.isopen,
      {
        backgroundColor: semanticColors.menuBackground,
        minWidth: "180px"
      },
      className
    ],
    container: [
      classNames.container,
      {
        selectors: {
          ":focus": { outline: 0 }
        }
      }
    ],
    list: [
      classNames.list,
      classNames.isopen,
      {
        listStyleType: "none",
        margin: "0",
        padding: "0"
      }
    ],
    header: [
      classNames.header,
      fonts.small,
      {
        fontWeight: FontWeights.semibold,
        color: semanticColors.menuHeader,
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        cursor: "default",
        padding: "0px 6px",
        userSelect: "none",
        textAlign: "left"
      }
    ],
    title: [
      classNames.title,
      {
        fontSize: fonts.mediumPlus.fontSize,
        paddingRight: "14px",
        paddingLeft: "14px",
        paddingBottom: "5px",
        paddingTop: "5px",
        backgroundColor: semanticColors.menuItemBackgroundPressed
      }
    ],
    subComponentStyles: {
      callout: {
        root: {
          boxShadow: effects.elevation8
        }
      },
      menuItem: {}
    }
  };
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
function onRenderSubMenu(subMenuProps) {
  return React16.createElement(LocalContextualMenu, __assign({}, subMenuProps));
}
var LocalContextualMenu = styled(ContextualMenuBase, getStyles4, function(props) {
  return {
    onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
  };
}, { scope: "ContextualMenu" });
var ContextualMenu = LocalContextualMenu;
ContextualMenu.displayName = "ContextualMenu";

// node_modules/@fluentui/react/lib/components/Button/BaseButton.classNames.js
var ButtonGlobalClassNames = {
  msButton: "ms-Button",
  msButtonHasMenu: "ms-Button--hasMenu",
  msButtonIcon: "ms-Button-icon",
  msButtonMenuIcon: "ms-Button-menuIcon",
  msButtonLabel: "ms-Button-label",
  msButtonDescription: "ms-Button-description",
  msButtonScreenReaderText: "ms-Button-screenReaderText",
  msButtonFlexContainer: "ms-Button-flexContainer",
  msButtonTextContainer: "ms-Button-textContainer"
};
var getBaseButtonClassNames = memoizeFunction(function(theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
  var _a, _b;
  var classNames = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
  var isExpanded = expanded && !isSplit;
  return mergeStyleSets({
    root: [
      classNames.msButton,
      styles.root,
      variantClassName,
      checked && ["is-checked", styles.rootChecked],
      isExpanded && [
        "is-expanded",
        styles.rootExpanded,
        {
          selectors: (_a = {}, _a[":hover .".concat(classNames.msButtonIcon)] = styles.iconExpandedHovered, // menuIcon falls back to rootExpandedHovered to support original behavior
          _a[":hover .".concat(classNames.msButtonMenuIcon)] = styles.menuIconExpandedHovered || styles.rootExpandedHovered, _a[":hover"] = styles.rootExpandedHovered, _a)
        }
      ],
      hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles.rootHasMenu],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !isExpanded && !checked && {
        selectors: (_b = {
          ":hover": styles.rootHovered
        }, _b[":hover .".concat(classNames.msButtonLabel)] = styles.labelHovered, _b[":hover .".concat(classNames.msButtonIcon)] = styles.iconHovered, _b[":hover .".concat(classNames.msButtonDescription)] = styles.descriptionHovered, _b[":hover .".concat(classNames.msButtonMenuIcon)] = styles.menuIconHovered, _b[":focus"] = styles.rootFocused, _b[":active"] = styles.rootPressed, _b[":active .".concat(classNames.msButtonIcon)] = styles.iconPressed, _b[":active .".concat(classNames.msButtonDescription)] = styles.descriptionPressed, _b[":active .".concat(classNames.msButtonMenuIcon)] = styles.menuIconPressed, _b)
      },
      disabled && checked && [styles.rootCheckedDisabled],
      !disabled && checked && {
        selectors: {
          ":hover": styles.rootCheckedHovered,
          ":active": styles.rootCheckedPressed
        }
      },
      className
    ],
    flexContainer: [classNames.msButtonFlexContainer, styles.flexContainer],
    textContainer: [classNames.msButtonTextContainer, styles.textContainer],
    icon: [
      classNames.msButtonIcon,
      iconClassName,
      styles.icon,
      isExpanded && styles.iconExpanded,
      checked && styles.iconChecked,
      disabled && styles.iconDisabled
    ],
    label: [classNames.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
    menuIcon: [
      classNames.msButtonMenuIcon,
      menuIconClassName,
      styles.menuIcon,
      checked && styles.menuIconChecked,
      disabled && !isSplit && styles.menuIconDisabled,
      !disabled && !isExpanded && !checked && {
        selectors: {
          ":hover": styles.menuIconHovered,
          ":active": styles.menuIconPressed
        }
      },
      isExpanded && ["is-expanded", styles.menuIconExpanded]
    ],
    description: [
      classNames.msButtonDescription,
      styles.description,
      checked && styles.descriptionChecked,
      disabled && styles.descriptionDisabled
    ],
    screenReaderText: [classNames.msButtonScreenReaderText, styles.screenReaderText]
  });
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.classNames.js
var getSplitButtonClassNames = memoizeFunction(function(styles, disabled, expanded, checked, primaryDisabled) {
  return {
    root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
      {
        selectors: {
          ":focus": styles.splitButtonMenuFocused
        }
      }
    ]),
    splitButtonContainer: mergeStyles(styles.splitButtonContainer, !disabled && checked && [
      styles.splitButtonContainerChecked,
      {
        selectors: {
          ":hover": styles.splitButtonContainerCheckedHovered
        }
      }
    ], !disabled && !checked && [
      {
        selectors: {
          ":hover": styles.splitButtonContainerHovered,
          ":focus": styles.splitButtonContainerFocused
        }
      }
    ], disabled && styles.splitButtonContainerDisabled),
    icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles.splitButtonMenuIcon),
    flexContainer: mergeStyles(styles.splitButtonFlexContainer),
    divider: mergeStyles(styles.splitButtonDivider, (primaryDisabled || disabled) && styles.splitButtonDividerDisabled)
  };
});

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var TouchIdleDelay2 = 500;
var COMPONENT_NAME4 = "BaseButton";
var BaseButton = (
  /** @class */
  function(_super) {
    __extends(BaseButton2, _super);
    function BaseButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._buttonElement = React17.createRef();
      _this._splitButtonContainer = React17.createRef();
      _this._mergedRef = createMergedRef();
      _this._renderedVisibleMenu = false;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onRenderIcon = function(buttonProps, defaultRender) {
        var iconProps = _this.props.iconProps;
        if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
          var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
          if (iconProps.styles) {
            return React17.createElement(Icon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
          if (iconProps.iconName) {
            return React17.createElement(FontIcon, __assign({ className: css(_this._classNames.icon, className) }, rest));
          }
          if (imageProps) {
            return React17.createElement(ImageIcon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
        }
        return null;
      };
      _this._onRenderTextContents = function() {
        var _a = _this.props, text = _a.text, children = _a.children, _b = _a.secondaryText, secondaryText = _b === void 0 ? _this.props.description : _b, _c = _a.onRenderText, onRenderText = _c === void 0 ? _this._onRenderText : _c, _d = _a.onRenderDescription, onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;
        if (text || typeof children === "string" || secondaryText) {
          return React17.createElement(
            "span",
            { className: _this._classNames.textContainer },
            onRenderText(_this.props, _this._onRenderText),
            onRenderDescription(_this.props, _this._onRenderDescription)
          );
        }
        return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
      };
      _this._onRenderText = function() {
        var text = _this.props.text;
        var children = _this.props.children;
        if (text === void 0 && typeof children === "string") {
          text = children;
        }
        if (_this._hasText()) {
          return React17.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text);
        }
        return null;
      };
      _this._onRenderChildren = function() {
        var children = _this.props.children;
        if (typeof children === "string") {
          return null;
        }
        return children;
      };
      _this._onRenderDescription = function(props2) {
        var _a = props2.secondaryText, secondaryText = _a === void 0 ? _this.props.description : _a;
        return secondaryText ? React17.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
      };
      _this._onRenderAriaDescription = function() {
        var ariaDescription = _this.props.ariaDescription;
        return ariaDescription ? React17.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
      };
      _this._onRenderMenuIcon = function(props2) {
        var menuIconProps = _this.props.menuIconProps;
        return React17.createElement(FontIcon, __assign({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
      };
      _this._onRenderMenu = function(menuProps) {
        var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
        return React17.createElement(MenuType, __assign({}, menuProps));
      };
      _this._onDismissMenu = function(ev) {
        var menuProps = _this.props.menuProps;
        if (menuProps && menuProps.onDismiss) {
          menuProps.onDismiss(ev);
        }
        if (!ev || !ev.defaultPrevented) {
          _this._dismissMenu();
        }
      };
      _this._dismissMenu = function() {
        _this._menuShouldFocusOnMount = void 0;
        _this._menuShouldFocusOnContainer = void 0;
        _this.setState({ menuHidden: true });
      };
      _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
        if (shouldFocusOnMount === void 0) {
          shouldFocusOnMount = true;
        }
        if (_this.props.menuProps) {
          _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
          _this._menuShouldFocusOnMount = shouldFocusOnMount;
          _this._renderedVisibleMenu = true;
          _this.setState({ menuHidden: false });
        }
      };
      _this._onToggleMenu = function(shouldFocusOnContainer) {
        var shouldFocusOnMount = true;
        if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
          shouldFocusOnMount = false;
        }
        _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
      };
      _this._onSplitContainerFocusCapture = function(ev) {
        var container = _this._splitButtonContainer.current;
        if (!container || ev.target && portalContainsElement(ev.target, container)) {
          return;
        }
        container.focus();
      };
      _this._onSplitButtonPrimaryClick = function(ev) {
        if (!_this.state.menuHidden) {
          _this._dismissMenu();
        }
        var singleTouchTarget = _this._processingTouch && !_this.props.toggle;
        if (!singleTouchTarget && _this.props.onClick) {
          _this.props.onClick(ev);
        } else if (singleTouchTarget) {
          _this._onMenuClick(ev);
        }
      };
      _this._onKeyDown = function(ev) {
        if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuKeyDown(ev);
          } else if (_this.props.onKeyDown !== void 0) {
            _this.props.onKeyDown(ev);
          }
        }
      };
      _this._onKeyUp = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
          _this.props.onKeyUp(ev);
        }
      };
      _this._onKeyPress = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
          _this.props.onKeyPress(ev);
        }
      };
      _this._onMouseUp = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
          _this.props.onMouseUp(ev);
        }
      };
      _this._onMouseDown = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
          _this.props.onMouseDown(ev);
        }
      };
      _this._onClick = function(ev) {
        if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuClick(ev);
          } else if (_this.props.onClick !== void 0) {
            _this.props.onClick(ev);
          }
        }
      };
      _this._onSplitButtonContainerKeyDown = function(ev) {
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          if (_this._buttonElement.current) {
            _this._buttonElement.current.click();
            ev.preventDefault();
            ev.stopPropagation();
          }
        } else {
          _this._onMenuKeyDown(ev);
        }
      };
      _this._onMenuKeyDown = function(ev) {
        var _a;
        if (_this.props.disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        var isUp = ev.which === KeyCodes.up;
        var isDown = ev.which === KeyCodes.down;
        if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
          var onMenuClick = _this.props.onMenuClick;
          if (onMenuClick) {
            onMenuClick(ev, _this.props);
          }
          _this._onToggleMenu(false);
          ev.preventDefault();
          ev.stopPropagation();
        }
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          setFocusVisibility(true, ev.target, (_a = _this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);
        }
        if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
          if (!_this.state.menuHidden && _this.props.menuProps) {
            var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
            if (!currentShouldFocusOnMount) {
              ev.preventDefault();
              ev.stopPropagation();
              _this._menuShouldFocusOnMount = true;
              _this.forceUpdate();
            }
          }
        }
      };
      _this._onTouchStart = function() {
        if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
          _this._handleTouchAndPointerEvent();
        }
      };
      _this._onMenuClick = function(ev) {
        var _a = _this.props, onMenuClick = _a.onMenuClick, menuProps = _a.menuProps;
        if (onMenuClick) {
          onMenuClick(ev, _this.props);
        }
        var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === "boolean" ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        if (!ev.defaultPrevented) {
          _this._onToggleMenu(shouldFocusOnContainer);
          ev.preventDefault();
          ev.stopPropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      warnConditionallyRequiredProps(COMPONENT_NAME4, props, ["menuProps", "onClick"], "split", _this.props.split);
      warnDeprecations(COMPONENT_NAME4, props, {
        rootProps: void 0,
        description: "secondaryText",
        toggled: "checked"
      });
      _this._labelId = getId();
      _this._descriptionId = getId();
      _this._ariaDescriptionId = getId();
      _this.state = {
        menuHidden: true
      };
      return _this;
    }
    Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
      get: function() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
      },
      enumerable: false,
      configurable: true
    });
    BaseButton2.prototype.render = function() {
      var _a;
      var _b = this.props, ariaDescription = _b.ariaDescription, ariaLabel = _b.ariaLabel, ariaHidden = _b.ariaHidden, className = _b.className, disabled = _b.disabled, allowDisabledFocus = _b.allowDisabledFocus, primaryDisabled = _b.primaryDisabled, _c = _b.secondaryText, secondaryText = _c === void 0 ? this.props.description : _c, href = _b.href, iconProps = _b.iconProps, menuIconProps = _b.menuIconProps, styles = _b.styles, checked = _b.checked, variantClassName = _b.variantClassName, theme = _b.theme, toggle = _b.toggle, getClassNames5 = _b.getClassNames, role = _b.role;
      var menuHidden = this.state.menuHidden;
      var isPrimaryButtonDisabled = disabled || primaryDisabled;
      this._classNames = getClassNames5 ? getClassNames5(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
      var _d = this, _ariaDescriptionId = _d._ariaDescriptionId, _labelId = _d._labelId, _descriptionId = _d._descriptionId;
      var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
      var tag = renderAsAnchor ? "a" : "button";
      var nativeProps = getNativeProps(
        // eslint-disable-next-line deprecation/deprecation
        assign(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
        renderAsAnchor ? anchorProperties : buttonProperties,
        [
          "disabled"
          // let disabled buttons be focused and styled as disabled.
        ]
      );
      var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
      var ariaDescribedBy = void 0;
      if (ariaDescription) {
        ariaDescribedBy = _ariaDescriptionId;
      } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
        ariaDescribedBy = _descriptionId;
      } else if (nativeProps["aria-describedby"]) {
        ariaDescribedBy = nativeProps["aria-describedby"];
      }
      var ariaLabelledBy = void 0;
      if (nativeProps["aria-labelledby"]) {
        ariaLabelledBy = nativeProps["aria-labelledby"];
      } else if (ariaDescribedBy && !resolvedAriaLabel) {
        ariaLabelledBy = this._hasText() ? _labelId : void 0;
      }
      var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
      var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
      var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
      var buttonProps = assign(nativeProps, (_a = {
        className: this._classNames.root,
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._buttonElement),
        disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onClick: this._onClick,
        "aria-label": resolvedAriaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isPrimaryButtonDisabled,
        "data-is-focusable": dataIsFocusable
      }, // aria-pressed attribute should only be present for toggle buttons
      // aria-checked attribute should only be present for toggle buttons with checkbox type role
      _a[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a));
      if (ariaHidden) {
        buttonProps["aria-hidden"] = true;
      }
      if (this._isSplitButton) {
        return this._onRenderSplitButtonContent(tag, buttonProps);
      } else if (this.props.menuProps) {
        var _e = this.props.menuProps.id, id = _e === void 0 ? "".concat(this._labelId, "-menu") : _e;
        assign(buttonProps, {
          "aria-expanded": !menuHidden,
          "aria-controls": !menuHidden ? id : null,
          "aria-haspopup": true
        });
      }
      return this._onRenderContent(tag, buttonProps);
    };
    BaseButton2.prototype.componentDidMount = function() {
      if (this._isSplitButton && this._splitButtonContainer.current) {
        if ("onpointerdown" in this._splitButtonContainer.current) {
          this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
        }
        if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
          this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
        }
      }
    };
    BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
        this.props.onAfterMenuDismiss();
      }
    };
    BaseButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    BaseButton2.prototype.focus = function() {
      var _a, _b;
      if (this._isSplitButton && this._splitButtonContainer.current) {
        setFocusVisibility(true, void 0, (_a = this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);
        this._splitButtonContainer.current.focus();
      } else if (this._buttonElement.current) {
        setFocusVisibility(true, void 0, (_b = this.context) === null || _b === void 0 ? void 0 : _b.registeredProviders);
        this._buttonElement.current.focus();
      }
    };
    BaseButton2.prototype.dismissMenu = function() {
      this._dismissMenu();
    };
    BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
      this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
    };
    BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
      var _this = this;
      var props = this.props;
      var Tag = tag;
      var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a = props.onRenderIcon, onRenderIcon = _a === void 0 ? this._onRenderIcon : _a, _b = props.onRenderAriaDescription, onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b, _c = props.onRenderChildren, onRenderChildren = _c === void 0 ? this._onRenderChildren : _c, _d = props.onRenderMenu, onRenderMenu = _d === void 0 ? this._onRenderMenu : _d, _e = props.onRenderMenuIcon, onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e, disabled = props.disabled;
      var keytipProps = props.keytipProps;
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var Button2 = function(keytipAttributes) {
        return React17.createElement(
          Tag,
          __assign({}, buttonProps, keytipAttributes),
          React17.createElement(
            "span",
            { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
            onRenderIcon(props, _this._onRenderIcon),
            _this._onRenderTextContents(),
            onRenderAriaDescription(props, _this._onRenderAriaDescription),
            onRenderChildren(props, _this._onRenderChildren),
            !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
            menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
          )
        );
      };
      var Content = keytipProps ? (
        // If we're making a split button, we won't put the keytip here
        React17.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
          return Button2(keytipAttributes);
        })
      ) : Button2();
      if (menuProps && menuProps.doNotLayer) {
        return React17.createElement(
          React17.Fragment,
          null,
          Content,
          this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
        );
      }
      return React17.createElement(
        React17.Fragment,
        null,
        Content,
        React17.createElement(FocusRects, null)
      );
    };
    BaseButton2.prototype._shouldRenderMenu = function() {
      var menuHidden = this.state.menuHidden;
      var _a = this.props, persistMenu = _a.persistMenu, renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;
      if (!menuHidden) {
        return true;
      } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
        return true;
      }
      return false;
    };
    BaseButton2.prototype._hasText = function() {
      return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
    };
    BaseButton2.prototype._getMenuProps = function(menuProps) {
      var persistMenu = this.props.persistMenu;
      var menuHidden = this.state.menuHidden;
      if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
        menuProps = __assign(__assign({}, menuProps), { labelElementId: this._labelId });
      }
      return __assign(__assign({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
    };
    BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
      var _this = this;
      var _a = this.props, _b = _a.styles, styles = _b === void 0 ? {} : _b, disabled = _a.disabled, allowDisabledFocus = _a.allowDisabledFocus, checked = _a.checked, getSplitButtonClassNames2 = _a.getSplitButtonClassNames, primaryDisabled = _a.primaryDisabled, menuProps = _a.menuProps, toggle = _a.toggle, role = _a.role, primaryActionButtonProps = _a.primaryActionButtonProps;
      var keytipProps = this.props.keytipProps;
      var menuHidden = this.state.menuHidden;
      var classNames = getSplitButtonClassNames2 ? getSplitButtonClassNames2(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
      assign(buttonProps, {
        onClick: void 0,
        onPointerDown: void 0,
        onPointerUp: void 0,
        tabIndex: -1,
        "data-is-focusable": false
      });
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var containerProps = getNativeProps(buttonProps, [], ["disabled"]);
      if (primaryActionButtonProps) {
        assign(buttonProps, primaryActionButtonProps);
      }
      var SplitButton = function(keytipAttributes) {
        return React17.createElement(
          "div",
          __assign({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames && classNames.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
          React17.createElement(
            "span",
            { style: { display: "flex", width: "100%" } },
            _this._onRenderContent(tag, buttonProps),
            _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes),
            _this._onRenderSplitButtonDivider(classNames)
          )
        );
      };
      return keytipProps ? React17.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
        return SplitButton(keytipAttributes);
      }) : SplitButton();
    };
    BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames) {
      if (classNames && classNames.divider) {
        var onClick = function(ev) {
          ev.stopPropagation();
        };
        return React17.createElement("span", { className: classNames.divider, "aria-hidden": true, onClick });
      }
      return null;
    };
    BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames, keytipAttributes) {
      var _a = this.props, allowDisabledFocus = _a.allowDisabledFocus, checked = _a.checked, disabled = _a.disabled, splitButtonMenuProps = _a.splitButtonMenuProps, splitButtonAriaLabel = _a.splitButtonAriaLabel, primaryDisabled = _a.primaryDisabled;
      var menuHidden = this.state.menuHidden;
      var menuIconProps = this.props.menuIconProps;
      if (menuIconProps === void 0) {
        menuIconProps = {
          iconName: "ChevronDown"
        };
      }
      var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), { styles: classNames, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign(__assign({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
      return React17.createElement(BaseButton2, __assign({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
    };
    BaseButton2.prototype._onPointerDown = function(ev) {
      var onPointerDown = this.props.onPointerDown;
      if (onPointerDown) {
        onPointerDown(ev);
      }
      if (ev.pointerType === "touch") {
        this._handleTouchAndPointerEvent();
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
    };
    BaseButton2.prototype._handleTouchAndPointerEvent = function() {
      var _this = this;
      if (this._lastTouchTimeoutId !== void 0) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
        if (_this.state.menuHidden) {
          _this.focus();
        }
      }, TouchIdleDelay2);
    };
    BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
      if (this.props.menuTriggerKeyCode) {
        return ev.which === this.props.menuTriggerKeyCode;
      } else if (this.props.menuProps) {
        return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
      }
      return false;
    };
    BaseButton2.defaultProps = {
      baseClassName: "ms-Button",
      styles: {},
      split: false
    };
    BaseButton2.contextType = FocusRectsContext;
    return BaseButton2;
  }(React17.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.types.js
var ElementType;
(function(ElementType2) {
  ElementType2[ElementType2["button"] = 0] = "button";
  ElementType2[ElementType2["anchor"] = 1] = "anchor";
})(ElementType || (ElementType = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2[ButtonType2["normal"] = 0] = "normal";
  ButtonType2[ButtonType2["primary"] = 1] = "primary";
  ButtonType2[ButtonType2["hero"] = 2] = "hero";
  ButtonType2[ButtonType2["compound"] = 3] = "compound";
  ButtonType2[ButtonType2["command"] = 4] = "command";
  ButtonType2[ButtonType2["icon"] = 5] = "icon";
  ButtonType2[ButtonType2["default"] = 6] = "default";
})(ButtonType || (ButtonType = {}));

// node_modules/@fluentui/react/lib/components/Button/Button.js
var React23 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var React18 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/BaseButton.styles.js
var noOutline = {
  outline: 0
};
var iconStyle = function(fontSize) {
  return {
    fontSize,
    margin: "0 4px",
    height: "16px",
    lineHeight: "16px",
    textAlign: "center",
    flexShrink: 0
  };
};
var getStyles5 = memoizeFunction(function(theme) {
  var _a, _b;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var border = semanticColors.buttonBorder;
  var disabledBackground = semanticColors.disabledBackground;
  var disabledText = semanticColors.disabledText;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    outlineColor: "ButtonText"
  };
  return {
    root: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      theme.fonts.medium,
      {
        border: "1px solid " + border,
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        cursor: "pointer",
        display: "inline-block",
        padding: "0 16px",
        textDecoration: "none",
        textAlign: "center",
        userSelect: "none",
        selectors: {
          // IE11 workaround for preventing shift of child elements of a button when active.
          ":active > span": {
            position: "relative",
            left: 0,
            top: 0
          }
        }
      }
    ],
    rootDisabled: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      {
        backgroundColor: disabledBackground,
        borderColor: disabledBackground,
        color: disabledText,
        cursor: "default",
        selectors: {
          ":hover": noOutline,
          ":focus": noOutline
        }
      }
    ],
    iconDisabled: {
      color: disabledText,
      selectors: (_a = {}, _a[HighContrastSelector] = {
        color: "GrayText"
      }, _a)
    },
    menuIconDisabled: {
      color: disabledText,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        color: "GrayText"
      }, _b)
    },
    flexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    description: {
      display: "block"
    },
    textContainer: {
      flexGrow: 1,
      display: "block"
    },
    icon: iconStyle(fonts.mediumPlus.fontSize),
    menuIcon: iconStyle(fonts.small.fontSize),
    label: {
      margin: "0 4px",
      lineHeight: "100%",
      display: "block"
    },
    screenReaderText: hiddenContentStyle
  };
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.styles.js
var getStyles6 = memoizeFunction(function(theme, customStyles) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
  var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    border: "none"
  };
  var splitButtonDividerBaseStyles2 = {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
  var splitButtonStyles = {
    splitButtonContainer: [
      getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2, pointerEvents: "none" }),
      {
        display: "inline-flex",
        selectors: {
          ".ms-Button--default": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            borderRight: "none",
            flexGrow: "1"
          },
          ".ms-Button--primary": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            border: "none",
            flexGrow: "1",
            selectors: (_a = {}, _a[HighContrastSelector] = __assign({ color: "WindowText", backgroundColor: "Window", border: "1px solid WindowText", borderRightWidth: "0" }, getHighContrastNoAdjustStyle()), _a[":hover"] = {
              border: "none"
            }, _a[":active"] = {
              border: "none"
            }, _a)
          },
          ".ms-Button--primary + .ms-Button": {
            border: "none",
            selectors: (_b = {}, _b[HighContrastSelector] = {
              border: "1px solid WindowText",
              borderLeftWidth: "0"
            }, _b)
          }
        }
      }
    ],
    splitButtonContainerHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_c = {}, _c[HighContrastSelector] = {
            color: "Window",
            backgroundColor: "Highlight"
          }, _c)
        },
        ".ms-Button.is-disabled": {
          color: semanticColors.buttonTextDisabled,
          selectors: (_d = {}, _d[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _d)
        }
      }
    },
    splitButtonContainerChecked: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_e = {}, _e[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _e)
        }
      }
    },
    splitButtonContainerCheckedHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_f = {}, _f[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _f)
        }
      }
    },
    splitButtonContainerFocused: {
      outline: "none!important"
    },
    splitButtonMenuButton: (_g = {
      padding: 6,
      height: "auto",
      boxSizing: "border-box",
      borderRadius: 0,
      borderTopRightRadius: effects.roundedCorner2,
      borderBottomRightRadius: effects.roundedCorner2,
      border: "1px solid ".concat(palette.neutralSecondaryAlt),
      borderLeft: "none",
      outline: "transparent",
      userSelect: "none",
      display: "inline-block",
      textDecoration: "none",
      textAlign: "center",
      cursor: "pointer",
      verticalAlign: "top",
      width: 32,
      marginLeft: -1,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    }, _g[HighContrastSelector] = {
      ".ms-Button-menuIcon": {
        color: "WindowText"
      }
    }, _g),
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_h = {}, _h[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _h) }),
    splitButtonDividerDisabled: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_j = {}, _j[HighContrastSelector] = {
      backgroundColor: "GrayText"
    }, _j) }),
    splitButtonMenuButtonDisabled: {
      pointerEvents: "none",
      border: "none",
      selectors: (_k = {
        ":hover": {
          cursor: "default"
        },
        ".ms-Button--primary": {
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _l)
        },
        ".ms-Button-menuIcon": {
          selectors: (_m = {}, _m[HighContrastSelector] = {
            color: "GrayText"
          }, _m)
        }
      }, _k[HighContrastSelector] = {
        color: "GrayText",
        border: "1px solid GrayText",
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonFlexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    splitButtonContainerDisabled: {
      outline: "none",
      border: "none",
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", borderColor: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuFocused: __assign({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }))
  };
  return concatStyleSets(splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ButtonThemes.js
var splitButtonDividerBaseStyles = function() {
  return {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
};
function standardStyles(theme) {
  var _a, _b, _c, _d, _e;
  var s = theme.semanticColors, p = theme.palette;
  var buttonBackground = s.buttonBackground;
  var buttonBackgroundPressed = s.buttonBackgroundPressed;
  var buttonBackgroundHovered = s.buttonBackgroundHovered;
  var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
  var buttonText = s.buttonText;
  var buttonTextHovered = s.buttonTextHovered;
  var buttonTextDisabled = s.buttonTextDisabled;
  var buttonTextChecked = s.buttonTextChecked;
  var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
  return {
    root: {
      backgroundColor: buttonBackground,
      color: buttonText
    },
    rootHovered: {
      backgroundColor: buttonBackgroundHovered,
      color: buttonTextHovered,
      selectors: (_a = {}, _a[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a)
    },
    rootPressed: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootExpanded: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootChecked: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootCheckedHovered: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextCheckedHovered
    },
    rootDisabled: {
      color: buttonTextDisabled,
      backgroundColor: buttonBackgroundDisabled,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _b)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_c = {}, _c[HighContrastSelector] = {
        border: "none"
      }, _c)
    },
    splitButtonMenuButton: {
      color: p.white,
      backgroundColor: "transparent",
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLight,
          selectors: (_d = {}, _d[HighContrastSelector] = {
            color: "Highlight"
          }, _d)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.buttonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.buttonBackgroundDisabled
        }
      }
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e = {}, _e[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _e) }),
    splitButtonDividerDisabled: {
      backgroundColor: theme.palette.neutralTertiaryAlt
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.buttonText
    },
    splitButtonMenuIconDisabled: {
      color: s.buttonTextDisabled
    }
  };
}
function primaryStyles(theme) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  var p = theme.palette, s = theme.semanticColors;
  return {
    root: {
      backgroundColor: s.primaryButtonBackground,
      border: "1px solid ".concat(s.primaryButtonBackground),
      color: s.primaryButtonText,
      selectors: (_a = {}, _a[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _a[".".concat(IsFocusVisibleClassName, " &:focus")] = {
        selectors: {
          ":after": {
            border: "none",
            outlineColor: p.white
          }
        }
      }, _a)
    },
    rootHovered: {
      backgroundColor: s.primaryButtonBackgroundHovered,
      border: "1px solid ".concat(s.primaryButtonBackgroundHovered),
      color: s.primaryButtonTextHovered,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        color: "Window",
        backgroundColor: "Highlight",
        borderColor: "Highlight"
      }, _b)
    },
    rootPressed: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      border: "1px solid ".concat(s.primaryButtonBackgroundPressed),
      color: s.primaryButtonTextPressed,
      selectors: (_c = {}, _c[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c)
    },
    rootExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootCheckedHovered: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootDisabled: {
      color: s.primaryButtonTextDisabled,
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: (_d = {}, _d[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _d)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_e = {}, _e[HighContrastSelector] = {
        border: "none"
      }, _e)
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {}, _f[HighContrastSelector] = {
      backgroundColor: "Window"
    }, _f) }),
    splitButtonMenuButton: {
      backgroundColor: s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_g = {}, _g[HighContrastSelector] = {
        backgroundColor: "Canvas"
      }, _g[":hover"] = {
        backgroundColor: s.primaryButtonBackgroundHovered,
        selectors: (_h = {}, _h[HighContrastSelector] = {
          color: "Highlight"
        }, _h)
      }, _g)
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundDisabled
        }
      }
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.primaryButtonText
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary,
      selectors: (_j = {}, _j[HighContrastSelector] = {
        color: "GrayText"
      }, _j)
    }
  };
}

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.styles.js
var DEFAULT_BUTTON_HEIGHT = "32px";
var DEFAULT_BUTTON_MIN_WIDTH = "80px";
var getStyles7 = memoizeFunction(function(theme, customStyles, primary) {
  var baseButtonStyles = getStyles5(theme);
  var splitButtonStyles = getStyles6(theme);
  var defaultButtonStyles = {
    root: {
      minWidth: DEFAULT_BUTTON_MIN_WIDTH,
      height: DEFAULT_BUTTON_HEIGHT
    },
    label: {
      fontWeight: FontWeights.semibold
    }
  };
  return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var DefaultButton = (
  /** @class */
  function(_super) {
    __extends(DefaultButton2, _super);
    function DefaultButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultButton2.prototype.render = function() {
      var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
      return React18.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--primary" : "ms-Button--default", styles: getStyles7(theme, styles, primary), onRenderDescription: nullRender }));
    };
    DefaultButton2 = __decorate([
      customizable("DefaultButton", ["theme", "styles"], true)
    ], DefaultButton2);
    return DefaultButton2;
  }(React18.Component)
);

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var React19 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.styles.js
var DEFAULT_BUTTON_HEIGHT2 = "40px";
var DEFAULT_PADDING = "0 4px";
var getStyles8 = memoizeFunction(function(theme, customStyles) {
  var _a, _b, _c;
  var baseButtonStyles = getStyles5(theme);
  var actionButtonStyles = {
    root: {
      padding: DEFAULT_PADDING,
      height: DEFAULT_BUTTON_HEIGHT2,
      color: theme.palette.neutralPrimary,
      backgroundColor: "transparent",
      border: "1px solid transparent",
      selectors: (_a = {}, _a[HighContrastSelector] = {
        borderColor: "Window"
      }, _a)
    },
    rootHovered: {
      color: theme.palette.themePrimary,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        color: "Highlight"
      }, _b)
    },
    iconHovered: {
      color: theme.palette.themePrimary
    },
    rootPressed: {
      color: theme.palette.black
    },
    rootExpanded: {
      color: theme.palette.themePrimary
    },
    iconPressed: {
      color: theme.palette.themeDarker
    },
    rootDisabled: {
      color: theme.palette.neutralTertiary,
      backgroundColor: "transparent",
      borderColor: "transparent",
      selectors: (_c = {}, _c[HighContrastSelector] = {
        color: "GrayText"
      }, _c)
    },
    rootChecked: {
      color: theme.palette.black
    },
    iconChecked: {
      color: theme.palette.themeDarker
    },
    flexContainer: {
      justifyContent: "flex-start"
    },
    icon: {
      color: theme.palette.themeDarkAlt
    },
    iconDisabled: {
      color: "inherit"
    },
    menuIcon: {
      color: theme.palette.neutralSecondary
    },
    textContainer: {
      flexGrow: 0
    }
  };
  return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var ActionButton = (
  /** @class */
  function(_super) {
    __extends(ActionButton2, _super);
    function ActionButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActionButton2.prototype.render = function() {
      var _a = this.props, styles = _a.styles, theme = _a.theme;
      return React19.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles8(theme, styles), onRenderDescription: nullRender }));
    };
    ActionButton2 = __decorate([
      customizable("ActionButton", ["theme", "styles"], true)
    ], ActionButton2);
    return ActionButton2;
  }(React19.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var React20 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.styles.js
var getStyles9 = memoizeFunction(function(theme, customStyles, primary) {
  var _a, _b, _c, _d, _e;
  var fonts = theme.fonts, palette = theme.palette;
  var baseButtonStyles = getStyles5(theme);
  var splitButtonStyles = getStyles6(theme);
  var compoundButtonStyles = {
    root: {
      maxWidth: "280px",
      minHeight: "72px",
      height: "auto",
      padding: "16px 12px"
    },
    flexContainer: {
      flexDirection: "row",
      alignItems: "flex-start",
      minWidth: "100%",
      margin: ""
    },
    textContainer: {
      textAlign: "left"
    },
    icon: {
      fontSize: "2em",
      lineHeight: "1em",
      height: "1em",
      margin: "0px 8px 0px 0px",
      flexBasis: "1em",
      flexShrink: "0"
    },
    label: {
      margin: "0 0 5px",
      lineHeight: "100%",
      fontWeight: FontWeights.semibold
    },
    description: [
      fonts.small,
      {
        lineHeight: "100%"
      }
    ]
  };
  var standardCompoundTheme = {
    description: {
      color: palette.neutralSecondary
    },
    descriptionHovered: {
      color: palette.neutralDark
    },
    descriptionPressed: {
      color: "inherit"
    },
    descriptionChecked: {
      color: "inherit"
    },
    descriptionDisabled: {
      color: "inherit"
    }
  };
  var primaryCompoundTheme = {
    description: {
      color: palette.white,
      selectors: (_a = {}, _a[HighContrastSelector] = __assign({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _a)
    },
    descriptionHovered: {
      color: palette.white,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "Window"
      }, _b)
    },
    descriptionPressed: {
      color: "inherit",
      selectors: (_c = {}, _c[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c)
    },
    descriptionChecked: {
      color: "inherit",
      selectors: (_d = {}, _d[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _d)
    },
    descriptionDisabled: {
      color: "inherit",
      selectors: (_e = {}, _e[HighContrastSelector] = {
        color: "inherit"
      }, _e)
    }
  };
  return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var CompoundButton = (
  /** @class */
  function(_super) {
    __extends(CompoundButton2, _super);
    function CompoundButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CompoundButton2.prototype.render = function() {
      var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
      return React20.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--compoundPrimary" : "ms-Button--compound", styles: getStyles9(theme, styles, primary) }));
    };
    CompoundButton2 = __decorate([
      customizable("CompoundButton", ["theme", "styles"], true)
    ], CompoundButton2);
    return CompoundButton2;
  }(React20.Component)
);

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var React21 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.styles.js
var getStyles10 = memoizeFunction(function(theme, customStyles) {
  var _a;
  var baseButtonStyles = getStyles5(theme);
  var splitButtonStyles = getStyles6(theme);
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var iconButtonStyles = {
    root: {
      padding: "0 4px",
      width: "32px",
      height: "32px",
      backgroundColor: "transparent",
      border: "none",
      color: semanticColors.link
    },
    rootHovered: {
      color: palette.themeDarkAlt,
      backgroundColor: palette.neutralLighter,
      selectors: (_a = {}, _a[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a)
    },
    rootHasMenu: {
      width: "auto"
    },
    rootPressed: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootExpanded: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootChecked: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootCheckedHovered: {
      color: palette.themeDark,
      backgroundColor: palette.neutralQuaternaryAlt
    },
    rootDisabled: {
      color: palette.neutralTertiaryAlt
    }
  };
  return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var IconButton = (
  /** @class */
  function(_super) {
    __extends(IconButton2, _super);
    function IconButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IconButton2.prototype.render = function() {
      var _a = this.props, styles = _a.styles, theme = _a.theme;
      return React21.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles10(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender }));
    };
    IconButton2 = __decorate([
      customizable("IconButton", ["theme", "styles"], true)
    ], IconButton2);
    return IconButton2;
  }(React21.Component)
);

// node_modules/@fluentui/react/lib/components/Button/PrimaryButton/PrimaryButton.js
var React22 = __toESM(require_react());
var PrimaryButton = (
  /** @class */
  function(_super) {
    __extends(PrimaryButton2, _super);
    function PrimaryButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PrimaryButton2.prototype.render = function() {
      return React22.createElement(DefaultButton, __assign({}, this.props, { primary: true, onRenderDescription: nullRender }));
    };
    PrimaryButton2 = __decorate([
      customizable("PrimaryButton", ["theme", "styles"], true)
    ], PrimaryButton2);
    return PrimaryButton2;
  }(React22.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(props) {
      var _this = _super.call(this, props) || this;
      warn("The Button component has been deprecated. Use specific variants instead. (PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
      return _this;
    }
    Button2.prototype.render = function() {
      var props = this.props;
      switch (props.buttonType) {
        case ButtonType.command:
          return React23.createElement(ActionButton, __assign({}, props));
        case ButtonType.compound:
          return React23.createElement(CompoundButton, __assign({}, props));
        case ButtonType.icon:
          return React23.createElement(IconButton, __assign({}, props));
        case ButtonType.primary:
          return React23.createElement(PrimaryButton, __assign({}, props));
        default:
          return React23.createElement(DefaultButton, __assign({}, props));
      }
    };
    return Button2;
  }(React23.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var React24 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.styles.js
var getStyles11 = memoizeFunction(function(theme, customStyles, focusInset, focusColor) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  var baseButtonStyles = getStyles5(theme);
  var baseSplitButtonStyles = getStyles6(theme);
  var p = theme.palette, semanticColors = theme.semanticColors;
  var commandButtonHighContrastFocus = {
    left: 4,
    top: 4,
    bottom: 4,
    right: 4,
    border: "none"
  };
  var commandButtonStyles = {
    root: [
      getFocusStyle(theme, {
        inset: 2,
        highContrastStyle: commandButtonHighContrastFocus,
        borderColor: "transparent"
      }),
      theme.fonts.medium,
      {
        minWidth: "40px",
        backgroundColor: p.white,
        color: p.neutralPrimary,
        padding: "0 4px",
        border: "none",
        borderRadius: 0,
        selectors: (_a = {}, _a[HighContrastSelector] = {
          border: "none"
        }, _a)
      }
    ],
    rootHovered: {
      backgroundColor: p.neutralLighter,
      color: p.neutralDark,
      selectors: (_b = {}, _b[HighContrastSelector] = {
        color: "Highlight"
      }, _b[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDarkAlt
      }, _b[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _b)
    },
    rootPressed: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_c = {}, _c[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _c[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _c)
    },
    rootChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_d = {}, _d[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _d[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _d)
    },
    rootCheckedHovered: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: (_e = {}, _e[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _e[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _e)
    },
    rootExpanded: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_f = {}, _f[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _f[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _f)
    },
    rootExpandedHovered: {
      backgroundColor: p.neutralQuaternaryAlt
    },
    rootDisabled: {
      backgroundColor: p.white,
      selectors: (_g = {}, _g[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: semanticColors.disabledBodySubtext,
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _h)
      }, _g[HighContrastSelector] = __assign({ color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _g)
    },
    // Split button styles
    splitButtonContainer: {
      height: "100%",
      selectors: (_j = {}, _j[HighContrastSelector] = {
        border: "none"
      }, _j)
    },
    splitButtonDividerDisabled: {
      selectors: (_k = {}, _k[HighContrastSelector] = {
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonDivider: {
      backgroundColor: p.neutralTertiaryAlt
    },
    splitButtonMenuButton: {
      backgroundColor: p.white,
      border: "none",
      borderTopRightRadius: "0",
      borderBottomRightRadius: "0",
      color: p.neutralSecondary,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLighter,
          color: p.neutralDark,
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "Highlight"
          }, _l[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _l)
        },
        ":active": {
          backgroundColor: p.neutralLight,
          selectors: (_m = {}, _m[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _m)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: p.white,
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", border: "none", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralLight,
      color: p.black,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: p.neutralPrimary
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary
    },
    label: {
      fontWeight: "normal"
      // theme.fontWeights.semibold,
    },
    icon: {
      color: p.themePrimary
    },
    menuIcon: (_p = {
      color: p.neutralSecondary
    }, _p[HighContrastSelector] = {
      color: "GrayText"
    }, _p)
  };
  return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var CommandBarButton = (
  /** @class */
  function(_super) {
    __extends(CommandBarButton2, _super);
    function CommandBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CommandBarButton2.prototype.render = function() {
      var _a = this.props, styles = _a.styles, theme = _a.theme;
      return React24.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles11(theme, styles), onRenderDescription: nullRender }));
    };
    CommandBarButton2 = __decorate([
      customizable("CommandBarButton", ["theme", "styles"], true)
    ], CommandBarButton2);
    return CommandBarButton2;
  }(React24.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandButton/CommandButton.js
var CommandButton = ActionButton;

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var React25 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.styles.js
var getStyles12 = memoizeFunction(function(theme, customStyles) {
  return concatStyleSets({
    root: [
      getFocusStyle(theme, {
        inset: 1,
        highContrastStyle: {
          outlineOffset: "-4px",
          outline: "1px solid Window"
        },
        borderColor: "transparent"
      }),
      {
        height: 24
      }
    ]
  }, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var MessageBarButton = (
  /** @class */
  function(_super) {
    __extends(MessageBarButton2, _super);
    function MessageBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MessageBarButton2.prototype.render = function() {
      var _a = this.props, styles = _a.styles, theme = _a.theme;
      return React25.createElement(DefaultButton, __assign({}, this.props, { styles: getStyles12(theme, styles), onRenderDescription: nullRender }));
    };
    MessageBarButton2 = __decorate([
      customizable("MessageBarButton", ["theme", "styles"], true)
    ], MessageBarButton2);
    return MessageBarButton2;
  }(React25.Component)
);

// node_modules/@fluentui/react/lib/components/CommandBar/CommandBar.base.js
var getClassNames4 = classNamesFunction();
var CommandBarBase = (
  /** @class */
  function(_super) {
    __extends(CommandBarBase2, _super);
    function CommandBarBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._overflowSet = React26.createRef();
      _this._resizeGroup = React26.createRef();
      _this._onRenderData = function(data) {
        var _a = _this.props, ariaLabel = _a.ariaLabel, primaryGroupAriaLabel = _a.primaryGroupAriaLabel, farItemsGroupAriaLabel = _a.farItemsGroupAriaLabel;
        var hasSecondSet = data.farItems && data.farItems.length > 0;
        return React26.createElement(
          FocusZone,
          { className: css(_this._classNames.root), direction: FocusZoneDirection.horizontal, role: "menubar", "aria-label": ariaLabel },
          React26.createElement(OverflowSet, { role: hasSecondSet ? "group" : "none", "aria-label": hasSecondSet ? primaryGroupAriaLabel : void 0, componentRef: _this._overflowSet, className: css(_this._classNames.primarySet), items: data.primaryItems, overflowItems: data.overflowItems.length ? data.overflowItems : void 0, onRenderItem: _this._onRenderItem, onRenderOverflowButton: _this._onRenderOverflowButton }),
          hasSecondSet && React26.createElement(OverflowSet, { role: "group", "aria-label": farItemsGroupAriaLabel, className: css(_this._classNames.secondarySet), items: data.farItems, onRenderItem: _this._onRenderItem, onRenderOverflowButton: nullRender })
        );
      };
      _this._onRenderItem = function(item) {
        if (item.onRender) {
          return item.onRender(item, function() {
            return void 0;
          });
        }
        var itemText = item.text || item.name;
        var commandButtonProps = __assign(__assign({ allowDisabledFocus: true, role: "menuitem" }, item), { styles: getCommandButtonStyles(item.buttonStyles), className: css("ms-CommandBarItem-link", item.className), text: !item.iconOnly ? itemText : void 0, menuProps: item.subMenuProps, onClick: _this._onButtonClick(item) });
        if (item.iconOnly && (itemText !== void 0 || item.tooltipHostProps)) {
          return React26.createElement(TooltipHost, __assign({ role: "none", content: itemText, setAriaDescribedBy: false }, item.tooltipHostProps), _this._commandButton(item, commandButtonProps));
        }
        return _this._commandButton(item, commandButtonProps);
      };
      _this._commandButton = function(item, props2) {
        var ButtonAs = _this.props.buttonAs;
        var CommandBarButtonAs = item.commandBarButtonAs;
        var DefaultButtonAs = CommandBarButton;
        var Type = DefaultButtonAs;
        if (CommandBarButtonAs) {
          Type = composeComponentAs(CommandBarButtonAs, Type);
        }
        if (ButtonAs) {
          Type = composeComponentAs(ButtonAs, Type);
        }
        return React26.createElement(Type, __assign({}, props2));
      };
      _this._onRenderOverflowButton = function(overflowItems) {
        var _a = _this.props.overflowButtonProps, overflowButtonProps = _a === void 0 ? {} : _a;
        var combinedOverflowItems = __spreadArray(__spreadArray([], overflowButtonProps.menuProps ? overflowButtonProps.menuProps.items : [], true), overflowItems, true);
        var overflowProps = __assign(__assign({ role: "menuitem" }, overflowButtonProps), { styles: __assign({ menuIcon: { fontSize: "17px" } }, overflowButtonProps.styles), className: css("ms-CommandBar-overflowButton", overflowButtonProps.className), menuProps: __assign(__assign({}, overflowButtonProps.menuProps), { items: combinedOverflowItems }), menuIconProps: __assign({ iconName: "More" }, overflowButtonProps.menuIconProps) });
        var OverflowButtonType = _this.props.overflowButtonAs ? composeComponentAs(_this.props.overflowButtonAs, CommandBarButton) : CommandBarButton;
        return React26.createElement(OverflowButtonType, __assign({}, overflowProps));
      };
      _this._onReduceData = function(data) {
        var _a = _this.props, shiftOnReduce = _a.shiftOnReduce, onDataReduced = _a.onDataReduced;
        var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
        var farItems = data.farItems;
        var movedItem = primaryItems[shiftOnReduce ? 0 : primaryItems.length - 1];
        if (movedItem !== void 0) {
          movedItem.renderedInOverflow = true;
          overflowItems = __spreadArray([movedItem], overflowItems, true);
          primaryItems = shiftOnReduce ? primaryItems.slice(1) : primaryItems.slice(0, -1);
          var newData = __assign(__assign({}, data), { primaryItems, overflowItems });
          cacheKey = _this._computeCacheKey({ primaryItems, overflow: overflowItems.length > 0, farItems });
          if (onDataReduced) {
            onDataReduced(movedItem);
          }
          newData.cacheKey = cacheKey;
          return newData;
        }
        return void 0;
      };
      _this._onGrowData = function(data) {
        var _a = _this.props, shiftOnReduce = _a.shiftOnReduce, onDataGrown = _a.onDataGrown;
        var minimumOverflowItems = data.minimumOverflowItems;
        var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
        var farItems = data.farItems;
        var movedItem = overflowItems[0];
        if (movedItem !== void 0 && overflowItems.length > minimumOverflowItems) {
          movedItem.renderedInOverflow = false;
          overflowItems = overflowItems.slice(1);
          primaryItems = shiftOnReduce ? __spreadArray([movedItem], primaryItems, true) : __spreadArray(__spreadArray([], primaryItems, true), [movedItem], false);
          var newData = __assign(__assign({}, data), { primaryItems, overflowItems });
          cacheKey = _this._computeCacheKey({ primaryItems, overflow: overflowItems.length > 0, farItems });
          if (onDataGrown) {
            onDataGrown(movedItem);
          }
          newData.cacheKey = cacheKey;
          return newData;
        }
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    CommandBarBase2.prototype.render = function() {
      var _a = this.props, items = _a.items, overflowItems = _a.overflowItems, farItems = _a.farItems, styles = _a.styles, theme = _a.theme, dataDidRender = _a.dataDidRender, _b = _a.onReduceData, onReduceData = _b === void 0 ? this._onReduceData : _b, _c = _a.onGrowData, onGrowData = _c === void 0 ? this._onGrowData : _c, _d = _a.resizeGroupAs, ResizeGroupAs = _d === void 0 ? ResizeGroup : _d;
      var commandBarData = {
        primaryItems: __spreadArray([], items, true),
        overflowItems: __spreadArray([], overflowItems, true),
        minimumOverflowItems: __spreadArray([], overflowItems, true).length,
        farItems,
        cacheKey: this._computeCacheKey({
          primaryItems: __spreadArray([], items, true),
          overflow: overflowItems && overflowItems.length > 0,
          farItems
        })
      };
      this._classNames = getClassNames4(styles, { theme });
      var nativeProps = getNativeProps(this.props, divProperties);
      return React26.createElement(ResizeGroupAs, __assign({}, nativeProps, { componentRef: this._resizeGroup, data: commandBarData, onReduceData, onGrowData, onRenderData: this._onRenderData, dataDidRender }));
    };
    CommandBarBase2.prototype.focus = function() {
      var overflowSet = this._overflowSet.current;
      overflowSet && overflowSet.focus();
    };
    CommandBarBase2.prototype.remeasure = function() {
      this._resizeGroup.current && this._resizeGroup.current.remeasure();
    };
    CommandBarBase2.prototype._onButtonClick = function(item) {
      return function(ev) {
        if (item.inactive) {
          return;
        }
        if (item.onClick) {
          item.onClick(ev, item);
        }
      };
    };
    CommandBarBase2.prototype._computeCacheKey = function(data) {
      var primaryItems = data.primaryItems, overflow = data.overflow, farItems = data.farItems;
      var returnKey = function(acc, current) {
        var _a = current.cacheKey, cacheKey = _a === void 0 ? current.key : _a;
        return acc + cacheKey;
      };
      var primaryKey = primaryItems && primaryItems.reduce(returnKey, "");
      var overflowKey = overflow ? "overflow" : "";
      var farKey = farItems && farItems.reduce(returnKey, "");
      return [primaryKey, overflowKey, farKey].join("");
    };
    CommandBarBase2.defaultProps = {
      items: [],
      overflowItems: []
    };
    return CommandBarBase2;
  }(React26.Component)
);

// node_modules/@fluentui/react/lib/components/CommandBar/CommandBar.js
var CommandBar = styled(CommandBarBase, getStyles, void 0, {
  scope: "CommandBar"
});

export {
  getStyles,
  getCommandButtonStyles,
  KTP_PREFIX,
  KTP_SEPARATOR,
  KTP_FULL_PREFIX,
  DATAKTP_TARGET,
  DATAKTP_EXECUTE_TARGET,
  DATAKTP_ARIA_TARGET,
  KTP_LAYER_ID,
  KTP_ARIA_SEPARATOR,
  KeytipEvents,
  KeytipManager,
  OverflowSetBase,
  OverflowSet,
  ResizeGroupDirection,
  getMeasurementCache,
  getNextResizeGroupStateProvider,
  MeasuredContext,
  ResizeGroupBase,
  ResizeGroup,
  ContextualMenuItemType,
  ContextualMenuItemBase,
  getMenuItemStyles,
  getItemClassNames,
  getItemStyles,
  ContextualMenuItem,
  transitionKeysAreEqual,
  transitionKeysContain,
  buildKeytipConfigMap,
  constructKeytip,
  sequencesToID,
  mergeOverflows,
  ktpTargetFromSequences,
  ktpTargetFromId,
  getAriaDescribedBy,
  KeytipData,
  useKeytipRef,
  VerticalDivider,
  ResponsiveMode,
  setResponsiveMode,
  initializeResponsiveMode,
  getInitialResponsiveMode,
  withResponsiveMode,
  getResponsiveMode,
  useResponsiveMode,
  getSubmenuItems,
  canAnyMenuItemsCheck,
  ContextualMenuBase,
  ContextualMenu,
  ButtonGlobalClassNames,
  getSplitButtonClassNames,
  BaseButton,
  ElementType,
  ButtonType,
  getStyles5 as getStyles2,
  DefaultButton,
  getStyles8 as getStyles3,
  ActionButton,
  CompoundButton,
  IconButton,
  PrimaryButton,
  Button,
  CommandBarButton,
  CommandButton,
  MessageBarButton,
  CommandBarBase,
  CommandBar
};
//# sourceMappingURL=chunk-XYF7WIGK.js.map
